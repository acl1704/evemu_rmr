/*  EVEmu: EVE Online Server Emulator
  
  **************************************************************
  This file is automatically generated, DO NOT EDIT IT DIRECTLY.
  **************************************************************
  
  (If you need to customize an object, you must copy that object
  into another source file, and give up the ability to generate it)
  
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; version 2 of the License.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY except by those people which sell it, which
  are required to give you total support for your newly bought product;
  without even the implied warranty of MERCHANTABILITY or FITNESS FOR
  A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/


#include <string>
#include "../packets/../packets/General.h"
#include "../common/PyRep.h"




util_Row::util_Row() {
	/* object of type util.Row */
}

util_Row::~util_Row() {
}

void util_Row::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sutil_Row", pfx);
	_log(l_type, "%sObject of type util.Row:", pfx);
	_log(l_type, "%sheader: String list with %d enetires", pfx, header.size());
	std::vector<std::string>::const_iterator header_cur, header_end;
	header_cur = header.begin();
	header_end = header.end();
	int header_index;
	for(header_index = 0; header_cur != header_end; header_cur++, header_index++) {
		_log(l_type, "%s   [%02d] %s", pfx, header_index, (*header_cur).c_str());
	}
	
	_log(l_type, "%sline: ", pfx);
	std::string line_n(pfx);
	line_n += "    ";
	line.Dump(l_type, line_n.c_str());
}

PyRepObject *util_Row::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	
	PyRepList *list2 = new PyRepList();
	std::vector<std::string>::iterator header_cur, header_end;
	header_cur = header.begin();
	header_end = header.end();
	for(; header_cur != header_end; header_cur++) {
		list2->items.push_back(
			new PyRepString(*header_cur)
		);
	}
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = line.Clone();
	dict1->items[
		new PyRepString("line")
	] = dict1_1;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.Row",
			args0
		);
	

	return(res);
}

PyRepObject *util_Row::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	
	PyRepList *list2 = new PyRepList();
	std::vector<std::string>::iterator header_cur, header_end;
	header_cur = header.begin();
	header_end = header.end();
	for(; header_cur != header_end; header_cur++) {
		list2->items.push_back(
			new PyRepString(*header_cur)
		);
	}
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	
	PyRepList *list3 = new PyRepList();
	list3->items = line.items;
	line.items.clear();
	dict1_1 = list3;
	dict1->items[
		new PyRepString("line")
	] = dict1_1;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.Row",
			args0
		);
	

	return(res);
}

bool util_Row::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool util_Row::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode util_Row failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "util.Row") {
		_log(NET__PACKET_ERROR, "Decode util_Row failed: obj_0 is the wrong object type. Expected 'util.Row', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode util_Row failed: dict1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict1_header = false;
	bool dict1_line = false;
	PyRepDict *dict1 = (PyRepDict *) obj_0->arguments;
	
	PyRepDict::iterator dict1_cur, dict1_end;
	dict1_cur = dict1->items.begin();
	dict1_end = dict1->items.end();
	for(; dict1_cur != dict1_end; dict1_cur++) {
		PyRep *key__ = dict1_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode util_Row failed: a key in dict1 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "header") {
			dict1_header = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode util_Row failed: header is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	header.clear();
	PyRepList *list_2 = (PyRepList *) dict1_cur->second;
	PyRepList::iterator header_cur, header_end;
	header_cur = list_2->items.begin();
	header_end = list_2->items.end();
	int header_index;
	for(header_index = 0; header_cur != header_end; header_cur++, header_index++) {
		if(!(*header_cur)->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode util_Row failed: Element %d in list header is not a string: %s", header_index, (*header_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *t = (PyRepString *) (*header_cur);
		header.push_back(t->value);
	}

		} else
		if(key_string__->value == "line") {
			dict1_line = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode util_Row failed: line is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_line = (PyRepList *) dict1_cur->second;	line.items = list_line->items;
	list_line->items.clear();
	
		} else
		{
			_log(NET__PACKET_ERROR, "Decode util_Row failed: Unknown key string '%s' in dict1", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict1_header) {
		_log(NET__PACKET_ERROR, "Decode util_Row failed: Missing dict entry for 'header' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_line) {
		_log(NET__PACKET_ERROR, "Decode util_Row failed: Missing dict entry for 'line' in dict1");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

util_Row *util_Row::Clone() const {
	util_Row *res = new util_Row;
	res->CloneFrom(this);
	return(res);
}

void util_Row::CloneFrom(const util_Row *from) {
	/* object of type util.Row */
	header = from->header;
	line.CloneFrom(&from->line);
	
}


util_Rowset::util_Rowset() {
	/* object of type util.Rowset */
	rowclass = "util.Row";
}

util_Rowset::~util_Rowset() {
}

void util_Rowset::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sutil_Rowset", pfx);
	_log(l_type, "%sObject of type util.Rowset:", pfx);
	_log(l_type, "%sheader: String list with %d enetires", pfx, header.size());
	std::vector<std::string>::const_iterator header_cur, header_end;
	header_cur = header.begin();
	header_end = header.end();
	int header_index;
	for(header_index = 0; header_cur != header_end; header_cur++, header_index++) {
		_log(l_type, "%s   [%02d] %s", pfx, header_index, (*header_cur).c_str());
	}
	
	_log(l_type, "%srowclass='%s'", pfx, rowclass.c_str());
	_log(l_type, "%slines: ", pfx);
	std::string lines_n(pfx);
	lines_n += "    ";
	lines.Dump(l_type, lines_n.c_str());
}

PyRepObject *util_Rowset::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	
	PyRepList *list2 = new PyRepList();
	std::vector<std::string>::iterator header_cur, header_end;
	header_cur = header.begin();
	header_end = header.end();
	for(; header_cur != header_end; header_cur++) {
		list2->items.push_back(
			new PyRepString(*header_cur)
		);
	}
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepString(rowclass, true);
	dict1->items[
		new PyRepString("RowClass")
	] = dict1_1;
	PyRep *dict1_2;
	dict1_2 = lines.Clone();
	dict1->items[
		new PyRepString("lines")
	] = dict1_2;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.Rowset",
			args0
		);
	

	return(res);
}

PyRepObject *util_Rowset::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	
	PyRepList *list2 = new PyRepList();
	std::vector<std::string>::iterator header_cur, header_end;
	header_cur = header.begin();
	header_end = header.end();
	for(; header_cur != header_end; header_cur++) {
		list2->items.push_back(
			new PyRepString(*header_cur)
		);
	}
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepString(rowclass, true);
	dict1->items[
		new PyRepString("RowClass")
	] = dict1_1;
	PyRep *dict1_2;
	
	PyRepList *list3 = new PyRepList();
	list3->items = lines.items;
	lines.items.clear();
	dict1_2 = list3;
	dict1->items[
		new PyRepString("lines")
	] = dict1_2;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.Rowset",
			args0
		);
	

	return(res);
}

bool util_Rowset::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool util_Rowset::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode util_Rowset failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "util.Rowset") {
		_log(NET__PACKET_ERROR, "Decode util_Rowset failed: obj_0 is the wrong object type. Expected 'util.Rowset', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode util_Rowset failed: dict1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict1_header = false;
	bool dict1_rowclass = false;
	bool dict1_lines = false;
	PyRepDict *dict1 = (PyRepDict *) obj_0->arguments;
	
	PyRepDict::iterator dict1_cur, dict1_end;
	dict1_cur = dict1->items.begin();
	dict1_end = dict1->items.end();
	for(; dict1_cur != dict1_end; dict1_cur++) {
		PyRep *key__ = dict1_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode util_Rowset failed: a key in dict1 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "header") {
			dict1_header = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode util_Rowset failed: header is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	header.clear();
	PyRepList *list_2 = (PyRepList *) dict1_cur->second;
	PyRepList::iterator header_cur, header_end;
	header_cur = list_2->items.begin();
	header_end = list_2->items.end();
	int header_index;
	for(header_index = 0; header_cur != header_end; header_cur++, header_index++) {
		if(!(*header_cur)->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode util_Rowset failed: Element %d in list header is not a string: %s", header_index, (*header_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *t = (PyRepString *) (*header_cur);
		header.push_back(t->value);
	}

		} else
		if(key_string__->value == "RowClass") {
			dict1_rowclass = true;
	if(!dict1_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode util_Rowset failed: rowclass is not a string: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) dict1_cur->second;
	rowclass = string_3->value;
	if(string_3->is_type_1 != true) {
		_log(NET__PACKET_ERROR, "Decode util_Rowset: String type mismatch on rowclass: expected %d got %d. Continuing anyhow.", true, string_3->is_type_1);
	}
		} else
		if(key_string__->value == "lines") {
			dict1_lines = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode util_Rowset failed: lines is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_lines = (PyRepList *) dict1_cur->second;	lines.items = list_lines->items;
	list_lines->items.clear();
	
		} else
		{
			_log(NET__PACKET_ERROR, "Decode util_Rowset failed: Unknown key string '%s' in dict1", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict1_header) {
		_log(NET__PACKET_ERROR, "Decode util_Rowset failed: Missing dict entry for 'header' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_rowclass) {
		_log(NET__PACKET_ERROR, "Decode util_Rowset failed: Missing dict entry for 'rowclass' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_lines) {
		_log(NET__PACKET_ERROR, "Decode util_Rowset failed: Missing dict entry for 'lines' in dict1");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

util_Rowset *util_Rowset::Clone() const {
	util_Rowset *res = new util_Rowset;
	res->CloneFrom(this);
	return(res);
}

void util_Rowset::CloneFrom(const util_Rowset *from) {
	/* object of type util.Rowset */
	header = from->header;
	rowclass = from->rowclass;
	lines.CloneFrom(&from->lines);
	
}


util_IndexRowset::util_IndexRowset() {
	/* object of type util.IndexRowset */
	rowclass = "";
	idName = "";
}

util_IndexRowset::~util_IndexRowset() {
	std::map<uint32, PyRep *>::iterator items_cur, items_end;
	//free any existing elements first
	items_cur = items.begin();
	items_end = items.end();
	for(; items_cur != items_end; items_cur++) {
		delete items_cur->second;
	}
	
}

void util_IndexRowset::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sutil_IndexRowset", pfx);
	_log(l_type, "%sObject of type util.IndexRowset:", pfx);
	_log(l_type, "%sheader: String list with %d enetires", pfx, header.size());
	std::vector<std::string>::const_iterator header_cur, header_end;
	header_cur = header.begin();
	header_end = header.end();
	int header_index;
	for(header_index = 0; header_cur != header_end; header_cur++, header_index++) {
		_log(l_type, "%s   [%02d] %s", pfx, header_index, (*header_cur).c_str());
	}
	
	_log(l_type, "%srowclass='%s'", pfx, rowclass.c_str());
	_log(l_type, "%sidName='%s'", pfx, idName.c_str());
	_log(l_type, "%sitems: Dictionaty with %d enetires", pfx, items.size());
	std::map<uint32, PyRep *>::const_iterator items_cur, items_end;
	items_cur = items.begin();
	items_end = items.end();
	for(; items_cur != items_end; items_cur++) {
		_log(l_type, "%s   Key: %lu", pfx, items_cur->first);
		std::string n(pfx);
		n += "        ";
		items_cur->second->Dump(stdout, n.c_str());
	}
	
}

PyRepObject *util_IndexRowset::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	
	PyRepList *list2 = new PyRepList();
	std::vector<std::string>::iterator header_cur, header_end;
	header_cur = header.begin();
	header_end = header.end();
	for(; header_cur != header_end; header_cur++) {
		list2->items.push_back(
			new PyRepString(*header_cur)
		);
	}
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepString(rowclass, true);
	dict1->items[
		new PyRepString("RowClass")
	] = dict1_1;
	PyRep *dict1_2;
	dict1_2 = new PyRepString(idName);
	dict1->items[
		new PyRepString("idName")
	] = dict1_2;
	PyRep *dict1_3;
	
	PyRepDict *dict3 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator items_cur, items_end;
	items_cur = items.begin();
	items_end = items.end();
	for(; items_cur != items_end; items_cur++) {
		dict3->items[
			new PyRepInteger(items_cur->first)
		] = items_cur->second->Clone();
	}
	dict1_3 = dict3;
	
	dict1->items[
		new PyRepString("items")
	] = dict1_3;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.IndexRowset",
			args0
		);
	

	return(res);
}

PyRepObject *util_IndexRowset::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	
	PyRepList *list2 = new PyRepList();
	std::vector<std::string>::iterator header_cur, header_end;
	header_cur = header.begin();
	header_end = header.end();
	for(; header_cur != header_end; header_cur++) {
		list2->items.push_back(
			new PyRepString(*header_cur)
		);
	}
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepString(rowclass, true);
	dict1->items[
		new PyRepString("RowClass")
	] = dict1_1;
	PyRep *dict1_2;
	dict1_2 = new PyRepString(idName);
	dict1->items[
		new PyRepString("idName")
	] = dict1_2;
	PyRep *dict1_3;
	
	PyRepDict *dict3 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator items_cur, items_end;
	items_cur = items.begin();
	items_end = items.end();
	for(; items_cur != items_end; items_cur++) {
		dict3->items[
			new PyRepInteger(items_cur->first)
		] = items_cur->second;
	}
	items.clear();
	dict1_3 = dict3;
	
	dict1->items[
		new PyRepString("items")
	] = dict1_3;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.IndexRowset",
			args0
		);
	

	return(res);
}

bool util_IndexRowset::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool util_IndexRowset::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode util_IndexRowset failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "util.IndexRowset") {
		_log(NET__PACKET_ERROR, "Decode util_IndexRowset failed: obj_0 is the wrong object type. Expected 'util.IndexRowset', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode util_IndexRowset failed: dict1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict1_header = false;
	bool dict1_rowclass = false;
	bool dict1_idName = false;
	bool dict1_items = false;
	PyRepDict *dict1 = (PyRepDict *) obj_0->arguments;
	
	PyRepDict::iterator dict1_cur, dict1_end;
	dict1_cur = dict1->items.begin();
	dict1_end = dict1->items.end();
	for(; dict1_cur != dict1_end; dict1_cur++) {
		PyRep *key__ = dict1_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode util_IndexRowset failed: a key in dict1 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "header") {
			dict1_header = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode util_IndexRowset failed: header is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	header.clear();
	PyRepList *list_2 = (PyRepList *) dict1_cur->second;
	PyRepList::iterator header_cur, header_end;
	header_cur = list_2->items.begin();
	header_end = list_2->items.end();
	int header_index;
	for(header_index = 0; header_cur != header_end; header_cur++, header_index++) {
		if(!(*header_cur)->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode util_IndexRowset failed: Element %d in list header is not a string: %s", header_index, (*header_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *t = (PyRepString *) (*header_cur);
		header.push_back(t->value);
	}

		} else
		if(key_string__->value == "RowClass") {
			dict1_rowclass = true;
	if(!dict1_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode util_IndexRowset failed: rowclass is not a string: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) dict1_cur->second;
	rowclass = string_3->value;
	if(string_3->is_type_1 != true) {
		_log(NET__PACKET_ERROR, "Decode util_IndexRowset: String type mismatch on rowclass: expected %d got %d. Continuing anyhow.", true, string_3->is_type_1);
	}
		} else
		if(key_string__->value == "idName") {
			dict1_idName = true;
	if(!dict1_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode util_IndexRowset failed: idName is not a string: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_4 = (PyRepString *) dict1_cur->second;
	idName = string_4->value;
		} else
		if(key_string__->value == "items") {
			dict1_items = true;
	if(!dict1_cur->second->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode util_IndexRowset failed: items is not a dict: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	items.clear();
	PyRepDict *dict_5 = (PyRepDict *) dict1_cur->second;
	PyRepDict::iterator items_cur, items_end;
	items_cur = dict_5->items.begin();
	items_end = dict_5->items.end();
	int items_index;
	for(items_index = 0; items_cur != items_end; items_cur++, items_index++) {
		if(!items_cur->first->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode util_IndexRowset failed: Key %d in dict items is not an integer: %s", items_index, items_cur->first->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *k = (PyRepInteger *) items_cur->first;
		if(k->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode util_IndexRowset: truncating 64 bit into into 32 bit int in key of entry %d in field items", items_index);
		}
		items[k->value] = items_cur->second->Clone();
	}
	
		} else
		{
			_log(NET__PACKET_ERROR, "Decode util_IndexRowset failed: Unknown key string '%s' in dict1", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict1_header) {
		_log(NET__PACKET_ERROR, "Decode util_IndexRowset failed: Missing dict entry for 'header' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_rowclass) {
		_log(NET__PACKET_ERROR, "Decode util_IndexRowset failed: Missing dict entry for 'rowclass' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_idName) {
		_log(NET__PACKET_ERROR, "Decode util_IndexRowset failed: Missing dict entry for 'idName' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_items) {
		_log(NET__PACKET_ERROR, "Decode util_IndexRowset failed: Missing dict entry for 'items' in dict1");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

util_IndexRowset *util_IndexRowset::Clone() const {
	util_IndexRowset *res = new util_IndexRowset;
	res->CloneFrom(this);
	return(res);
}

void util_IndexRowset::CloneFrom(const util_IndexRowset *from) {
	/* object of type util.IndexRowset */
	header = from->header;
	rowclass = from->rowclass;
	idName = from->idName;
	std::map<uint32, PyRep *>::const_iterator items_cur, items_end;
	//free any existing elements first
	items_cur = items.begin();
	items_end = items.end();
	for(; items_cur != items_end; items_cur++) {
		delete items_cur->second;
	}
	items.clear();
	//now we can copy in the new ones...
	items_cur = from->items.begin();
	items_end = from->items.end();
	for(; items_cur != items_end; items_cur++) {
		items[items_cur->first] = items_cur->second->Clone();
	}
	
	
}

	/*  this object is not really an object type on live, just convenience here  */

util_Tupleset::util_Tupleset() {
}

util_Tupleset::~util_Tupleset() {
}

void util_Tupleset::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sutil_Tupleset", pfx);
	_log(l_type, "%sheader: String list with %d enetires", pfx, header.size());
	std::vector<std::string>::const_iterator header_cur, header_end;
	header_cur = header.begin();
	header_end = header.end();
	int header_index;
	for(header_index = 0; header_cur != header_end; header_cur++, header_index++) {
		_log(l_type, "%s   [%02d] %s", pfx, header_index, (*header_cur).c_str());
	}
	
	_log(l_type, "%slines: ", pfx);
	std::string lines_n(pfx);
	lines_n += "    ";
	lines.Dump(l_type, lines_n.c_str());
}

PyRepTuple *util_Tupleset::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	
	PyRepList *list1 = new PyRepList();
	std::vector<std::string>::iterator header_cur, header_end;
	header_cur = header.begin();
	header_end = header.end();
	for(; header_cur != header_end; header_cur++) {
		list1->items.push_back(
			new PyRepString(*header_cur)
		);
	}
	tuple0->items[0] = list1;
	
	tuple0->items[1] = lines.Clone();
	res = tuple0;
	

	return(res);
}

PyRepTuple *util_Tupleset::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	
	PyRepList *list1 = new PyRepList();
	std::vector<std::string>::iterator header_cur, header_end;
	header_cur = header.begin();
	header_end = header.end();
	for(; header_cur != header_end; header_cur++) {
		list1->items.push_back(
			new PyRepString(*header_cur)
		);
	}
	tuple0->items[0] = list1;
	
	
	PyRepList *list2 = new PyRepList();
	list2->items = lines.items;
	lines.items.clear();
	tuple0->items[1] = list2;
	res = tuple0;
	

	return(res);
}

bool util_Tupleset::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool util_Tupleset::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode util_Tupleset failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode util_Tupleset failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode util_Tupleset failed: header is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	header.clear();
	PyRepList *list_1 = (PyRepList *) tuple0->items[0];
	PyRepList::iterator header_cur, header_end;
	header_cur = list_1->items.begin();
	header_end = list_1->items.end();
	int header_index;
	for(header_index = 0; header_cur != header_end; header_cur++, header_index++) {
		if(!(*header_cur)->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode util_Tupleset failed: Element %d in list header is not a string: %s", header_index, (*header_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *t = (PyRepString *) (*header_cur);
		header.push_back(t->value);
	}

	if(!tuple0->items[1]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode util_Tupleset failed: lines is not a list: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_lines = (PyRepList *) tuple0->items[1];	lines.items = list_lines->items;
	list_lines->items.clear();
	

	delete packet;
	return(true);
}

util_Tupleset *util_Tupleset::Clone() const {
	util_Tupleset *res = new util_Tupleset;
	res->CloneFrom(this);
	return(res);
}

void util_Tupleset::CloneFrom(const util_Tupleset *from) {
	header = from->header;
	lines.CloneFrom(&from->lines);
	
}


list_rowset::list_rowset() {
	/*  0  */
	/*  1  */
	/*  each element of this list is a list itself, with one element per element in header  */
}

list_rowset::~list_rowset() {
	/*  0  */
	/*  1  */
	/*  each element of this list is a list itself, with one element per element in header  */
}

void list_rowset::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%slist_rowset", pfx);
	/*  0  */
	_log(l_type, "%sheader: String list with %d enetires", pfx, header.size());
	std::vector<std::string>::const_iterator header_cur, header_end;
	header_cur = header.begin();
	header_end = header.end();
	int header_index;
	for(header_index = 0; header_cur != header_end; header_cur++, header_index++) {
		_log(l_type, "%s   [%02d] %s", pfx, header_index, (*header_cur).c_str());
	}
	
	/*  1  */
	/*  each element of this list is a list itself, with one element per element in header  */
	_log(l_type, "%slines: ", pfx);
	std::string lines_n(pfx);
	lines_n += "    ";
	lines.Dump(l_type, lines_n.c_str());
}

PyRepTuple *list_rowset::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	
	PyRepList *list1 = new PyRepList();
	std::vector<std::string>::iterator header_cur, header_end;
	header_cur = header.begin();
	header_end = header.end();
	for(; header_cur != header_end; header_cur++) {
		list1->items.push_back(
			new PyRepString(*header_cur)
		);
	}
	tuple0->items[0] = list1;
	
	/*  1  */
	/*  each element of this list is a list itself, with one element per element in header  */
	tuple0->items[1] = lines.Clone();
	res = tuple0;
	

	return(res);
}

PyRepTuple *list_rowset::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	
	PyRepList *list1 = new PyRepList();
	std::vector<std::string>::iterator header_cur, header_end;
	header_cur = header.begin();
	header_end = header.end();
	for(; header_cur != header_end; header_cur++) {
		list1->items.push_back(
			new PyRepString(*header_cur)
		);
	}
	tuple0->items[0] = list1;
	
	/*  1  */
	/*  each element of this list is a list itself, with one element per element in header  */
	
	PyRepList *list2 = new PyRepList();
	list2->items = lines.items;
	lines.items.clear();
	tuple0->items[1] = list2;
	res = tuple0;
	

	return(res);
}

bool list_rowset::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool list_rowset::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode list_rowset failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode list_rowset failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode list_rowset failed: header is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	header.clear();
	PyRepList *list_1 = (PyRepList *) tuple0->items[0];
	PyRepList::iterator header_cur, header_end;
	header_cur = list_1->items.begin();
	header_end = list_1->items.end();
	int header_index;
	for(header_index = 0; header_cur != header_end; header_cur++, header_index++) {
		if(!(*header_cur)->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode list_rowset failed: Element %d in list header is not a string: %s", header_index, (*header_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *t = (PyRepString *) (*header_cur);
		header.push_back(t->value);
	}

	/*  1  */
	/*  each element of this list is a list itself, with one element per element in header  */
	if(!tuple0->items[1]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode list_rowset failed: lines is not a list: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_lines = (PyRepList *) tuple0->items[1];	lines.items = list_lines->items;
	list_lines->items.clear();
	

	delete packet;
	return(true);
}

list_rowset *list_rowset::Clone() const {
	list_rowset *res = new list_rowset;
	res->CloneFrom(this);
	return(res);
}

void list_rowset::CloneFrom(const list_rowset *from) {
	/*  0  */
	header = from->header;
	/*  1  */
	/*  each element of this list is a list itself, with one element per element in header  */
	lines.CloneFrom(&from->lines);
	
}

	/*  This should prolly find a new home some day, as its really a detail of the marshalling procedure  */

dbutil_RowList_header::dbutil_RowList_header() {
	type = "dbutil.RowList";
	packed_header = NULL;
}

dbutil_RowList_header::~dbutil_RowList_header() {
	delete packed_header;
}

void dbutil_RowList_header::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sdbutil_RowList_header", pfx);
	_log(l_type, "%stype='%s'", pfx, type.c_str());
	_log(l_type, "%spacked_header:", pfx);
	std::string packed_header_n(pfx);
	packed_header_n += "    ";
	if(packed_header == NULL) {
		_log(l_type, "%sERROR: NULL REP!", packed_header_n.c_str());
	} else {
		packed_header->Dump(l_type, packed_header_n.c_str());
	}
	_log(l_type, "%scolumns: String list with %d enetires", pfx, columns.size());
	std::vector<std::string>::const_iterator columns_cur, columns_end;
	columns_cur = columns.begin();
	columns_end = columns.end();
	int columns_index;
	for(columns_index = 0; columns_cur != columns_end; columns_cur++, columns_index++) {
		_log(l_type, "%s   [%02d] %s", pfx, columns_index, (*columns_cur).c_str());
	}
	
}

PyRepTuple *dbutil_RowList_header::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	PyRepTuple *tuple1 = new PyRepTuple(1);
	tuple1->items[0] = new PyRepString(type, true);
	tuple0->items[0] = tuple1;
	
	PyRepDict *dict2 = new PyRepDict();
	PyRep *dict2_0;
	if(packed_header == NULL) {
		_log(NET__PACKET_ERROR, "Encode dbutil_RowList_header: packed_header is NULL! hacking in a PyRepNone");
		packed_header = new PyRepNone();
	}
	dict2_0 = packed_header->Clone();
	dict2->items[
		new PyRepString("header")
	] = dict2_0;
	PyRep *dict2_1;
	
	PyRepList *list3 = new PyRepList();
	std::vector<std::string>::iterator columns_cur, columns_end;
	columns_cur = columns.begin();
	columns_end = columns.end();
	for(; columns_cur != columns_end; columns_cur++) {
		list3->items.push_back(
			new PyRepString(*columns_cur)
		);
	}
	dict2_1 = list3;
	
	dict2->items[
		new PyRepString("columns")
	] = dict2_1;
	tuple0->items[1] = dict2;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *dbutil_RowList_header::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	PyRepTuple *tuple1 = new PyRepTuple(1);
	tuple1->items[0] = new PyRepString(type, true);
	tuple0->items[0] = tuple1;
	
	PyRepDict *dict2 = new PyRepDict();
	PyRep *dict2_0;
	if(packed_header == NULL) {
		_log(NET__PACKET_ERROR, "Encode dbutil_RowList_header: packed_header is NULL! hacking in a PyRepNone");
		packed_header = new PyRepNone();
	}
	dict2_0 = packed_header;
	packed_header = NULL;
	dict2->items[
		new PyRepString("header")
	] = dict2_0;
	PyRep *dict2_1;
	
	PyRepList *list3 = new PyRepList();
	std::vector<std::string>::iterator columns_cur, columns_end;
	columns_cur = columns.begin();
	columns_end = columns.end();
	for(; columns_cur != columns_end; columns_cur++) {
		list3->items.push_back(
			new PyRepString(*columns_cur)
		);
	}
	dict2_1 = list3;
	
	dict2->items[
		new PyRepString("columns")
	] = dict2_1;
	tuple0->items[1] = dict2;
	
	res = tuple0;
	

	return(res);
}

bool dbutil_RowList_header::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool dbutil_RowList_header::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode dbutil_RowList_header failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode dbutil_RowList_header failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode dbutil_RowList_header failed: tuple1 is the wrong type: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple1 = (PyRepTuple *) tuple0->items[0];
	if(tuple1->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode dbutil_RowList_header failed: tuple1 is the wrong size: expected 1, but got %d", tuple1->items.size());
		delete packet;
		return(false);
	}

	if(!tuple1->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode dbutil_RowList_header failed: type is not a string: %s", tuple1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple1->items[0];
	type = string_2->value;
	if(string_2->is_type_1 != true) {
		_log(NET__PACKET_ERROR, "Decode dbutil_RowList_header: String type mismatch on type: expected %d got %d. Continuing anyhow.", true, string_2->is_type_1);
	}
	if(!tuple0->items[1]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode dbutil_RowList_header failed: dict3 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	bool dict3_packed_header = false;
	bool dict3_columns = false;
	PyRepDict *dict3 = (PyRepDict *) tuple0->items[1];
	
	PyRepDict::iterator dict3_cur, dict3_end;
	dict3_cur = dict3->items.begin();
	dict3_end = dict3->items.end();
	for(; dict3_cur != dict3_end; dict3_cur++) {
		PyRep *key__ = dict3_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode dbutil_RowList_header failed: a key in dict3 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "header") {
			dict3_packed_header = true;
	delete packed_header;
	packed_header = dict3_cur->second;
	dict3_cur->second = NULL;
	
		} else
		if(key_string__->value == "columns") {
			dict3_columns = true;
	if(!dict3_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode dbutil_RowList_header failed: columns is not a list: %s", dict3_cur->second->TypeString());
		delete packet;
		return(false);
	}
	columns.clear();
	PyRepList *list_4 = (PyRepList *) dict3_cur->second;
	PyRepList::iterator columns_cur, columns_end;
	columns_cur = list_4->items.begin();
	columns_end = list_4->items.end();
	int columns_index;
	for(columns_index = 0; columns_cur != columns_end; columns_cur++, columns_index++) {
		if(!(*columns_cur)->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode dbutil_RowList_header failed: Element %d in list columns is not a string: %s", columns_index, (*columns_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *t = (PyRepString *) (*columns_cur);
		columns.push_back(t->value);
	}

		} else
		{
			_log(NET__PACKET_ERROR, "Decode dbutil_RowList_header failed: Unknown key string '%s' in dict3", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict3_packed_header) {
		_log(NET__PACKET_ERROR, "Decode dbutil_RowList_header failed: Missing dict entry for 'packed_header' in dict3");
		delete packet;
		return(false);
	}
	
	if(!dict3_columns) {
		_log(NET__PACKET_ERROR, "Decode dbutil_RowList_header failed: Missing dict entry for 'columns' in dict3");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

dbutil_RowList_header *dbutil_RowList_header::Clone() const {
	dbutil_RowList_header *res = new dbutil_RowList_header;
	res->CloneFrom(this);
	return(res);
}

void dbutil_RowList_header::CloneFrom(const dbutil_RowList_header *from) {
	type = from->type;
	delete packed_header;
	if(from->packed_header == NULL) {
		packed_header = NULL;
	} else {
		packed_header = from->packed_header->Clone();
	}
	columns = from->columns;
	
}


dbutil_RowDict_header::dbutil_RowDict_header() {
	type = "dbutil.RowDict";
	packed_header = NULL;
	key = "";
}

dbutil_RowDict_header::~dbutil_RowDict_header() {
	delete packed_header;
}

void dbutil_RowDict_header::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sdbutil_RowDict_header", pfx);
	_log(l_type, "%stype='%s'", pfx, type.c_str());
	_log(l_type, "%spacked_header:", pfx);
	std::string packed_header_n(pfx);
	packed_header_n += "    ";
	if(packed_header == NULL) {
		_log(l_type, "%sERROR: NULL REP!", packed_header_n.c_str());
	} else {
		packed_header->Dump(l_type, packed_header_n.c_str());
	}
	_log(l_type, "%scolumns: String list with %d enetires", pfx, columns.size());
	std::vector<std::string>::const_iterator columns_cur, columns_end;
	columns_cur = columns.begin();
	columns_end = columns.end();
	int columns_index;
	for(columns_index = 0; columns_cur != columns_end; columns_cur++, columns_index++) {
		_log(l_type, "%s   [%02d] %s", pfx, columns_index, (*columns_cur).c_str());
	}
	
	_log(l_type, "%skey='%s'", pfx, key.c_str());
}

PyRepTuple *dbutil_RowDict_header::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	PyRepTuple *tuple1 = new PyRepTuple(1);
	tuple1->items[0] = new PyRepString(type, true);
	tuple0->items[0] = tuple1;
	
	PyRepDict *dict2 = new PyRepDict();
	PyRep *dict2_0;
	if(packed_header == NULL) {
		_log(NET__PACKET_ERROR, "Encode dbutil_RowDict_header: packed_header is NULL! hacking in a PyRepNone");
		packed_header = new PyRepNone();
	}
	dict2_0 = packed_header->Clone();
	dict2->items[
		new PyRepString("header")
	] = dict2_0;
	PyRep *dict2_1;
	
	PyRepList *list3 = new PyRepList();
	std::vector<std::string>::iterator columns_cur, columns_end;
	columns_cur = columns.begin();
	columns_end = columns.end();
	for(; columns_cur != columns_end; columns_cur++) {
		list3->items.push_back(
			new PyRepString(*columns_cur)
		);
	}
	dict2_1 = list3;
	
	dict2->items[
		new PyRepString("columns")
	] = dict2_1;
	PyRep *dict2_2;
	dict2_2 = new PyRepString(key);
	dict2->items[
		new PyRepString("key")
	] = dict2_2;
	tuple0->items[1] = dict2;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *dbutil_RowDict_header::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	PyRepTuple *tuple1 = new PyRepTuple(1);
	tuple1->items[0] = new PyRepString(type, true);
	tuple0->items[0] = tuple1;
	
	PyRepDict *dict2 = new PyRepDict();
	PyRep *dict2_0;
	if(packed_header == NULL) {
		_log(NET__PACKET_ERROR, "Encode dbutil_RowDict_header: packed_header is NULL! hacking in a PyRepNone");
		packed_header = new PyRepNone();
	}
	dict2_0 = packed_header;
	packed_header = NULL;
	dict2->items[
		new PyRepString("header")
	] = dict2_0;
	PyRep *dict2_1;
	
	PyRepList *list3 = new PyRepList();
	std::vector<std::string>::iterator columns_cur, columns_end;
	columns_cur = columns.begin();
	columns_end = columns.end();
	for(; columns_cur != columns_end; columns_cur++) {
		list3->items.push_back(
			new PyRepString(*columns_cur)
		);
	}
	dict2_1 = list3;
	
	dict2->items[
		new PyRepString("columns")
	] = dict2_1;
	PyRep *dict2_2;
	dict2_2 = new PyRepString(key);
	dict2->items[
		new PyRepString("key")
	] = dict2_2;
	tuple0->items[1] = dict2;
	
	res = tuple0;
	

	return(res);
}

bool dbutil_RowDict_header::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool dbutil_RowDict_header::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode dbutil_RowDict_header failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode dbutil_RowDict_header failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode dbutil_RowDict_header failed: tuple1 is the wrong type: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple1 = (PyRepTuple *) tuple0->items[0];
	if(tuple1->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode dbutil_RowDict_header failed: tuple1 is the wrong size: expected 1, but got %d", tuple1->items.size());
		delete packet;
		return(false);
	}

	if(!tuple1->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode dbutil_RowDict_header failed: type is not a string: %s", tuple1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple1->items[0];
	type = string_2->value;
	if(string_2->is_type_1 != true) {
		_log(NET__PACKET_ERROR, "Decode dbutil_RowDict_header: String type mismatch on type: expected %d got %d. Continuing anyhow.", true, string_2->is_type_1);
	}
	if(!tuple0->items[1]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode dbutil_RowDict_header failed: dict3 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	bool dict3_packed_header = false;
	bool dict3_columns = false;
	bool dict3_key = false;
	PyRepDict *dict3 = (PyRepDict *) tuple0->items[1];
	
	PyRepDict::iterator dict3_cur, dict3_end;
	dict3_cur = dict3->items.begin();
	dict3_end = dict3->items.end();
	for(; dict3_cur != dict3_end; dict3_cur++) {
		PyRep *key__ = dict3_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode dbutil_RowDict_header failed: a key in dict3 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "header") {
			dict3_packed_header = true;
	delete packed_header;
	packed_header = dict3_cur->second;
	dict3_cur->second = NULL;
	
		} else
		if(key_string__->value == "columns") {
			dict3_columns = true;
	if(!dict3_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode dbutil_RowDict_header failed: columns is not a list: %s", dict3_cur->second->TypeString());
		delete packet;
		return(false);
	}
	columns.clear();
	PyRepList *list_4 = (PyRepList *) dict3_cur->second;
	PyRepList::iterator columns_cur, columns_end;
	columns_cur = list_4->items.begin();
	columns_end = list_4->items.end();
	int columns_index;
	for(columns_index = 0; columns_cur != columns_end; columns_cur++, columns_index++) {
		if(!(*columns_cur)->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode dbutil_RowDict_header failed: Element %d in list columns is not a string: %s", columns_index, (*columns_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *t = (PyRepString *) (*columns_cur);
		columns.push_back(t->value);
	}

		} else
		if(key_string__->value == "key") {
			dict3_key = true;
	if(!dict3_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode dbutil_RowDict_header failed: key is not a string: %s", dict3_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_5 = (PyRepString *) dict3_cur->second;
	key = string_5->value;
		} else
		{
			_log(NET__PACKET_ERROR, "Decode dbutil_RowDict_header failed: Unknown key string '%s' in dict3", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict3_packed_header) {
		_log(NET__PACKET_ERROR, "Decode dbutil_RowDict_header failed: Missing dict entry for 'packed_header' in dict3");
		delete packet;
		return(false);
	}
	
	if(!dict3_columns) {
		_log(NET__PACKET_ERROR, "Decode dbutil_RowDict_header failed: Missing dict entry for 'columns' in dict3");
		delete packet;
		return(false);
	}
	
	if(!dict3_key) {
		_log(NET__PACKET_ERROR, "Decode dbutil_RowDict_header failed: Missing dict entry for 'key' in dict3");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

dbutil_RowDict_header *dbutil_RowDict_header::Clone() const {
	dbutil_RowDict_header *res = new dbutil_RowDict_header;
	res->CloneFrom(this);
	return(res);
}

void dbutil_RowDict_header::CloneFrom(const dbutil_RowDict_header *from) {
	type = from->type;
	delete packed_header;
	if(from->packed_header == NULL) {
		packed_header = NULL;
	} else {
		packed_header = from->packed_header->Clone();
	}
	columns = from->columns;
	key = from->key;
	
}

	/*  
empty calls:
CallPing
CallGetPostAuthenticationMessage
CallGetCharactersToSelect
CallGetCharCreationInfo
CallGetAttributeTypes
CallShipGetInfo
CallCharGetInfo
CallGetMyKillRights
CallGetBookmarks
CallGetChannels
CallGetInitialState
CallGetMyMessages
CallGetFactionInfo
CallGetStuckSystems
CallGetOwnerNoteLabels
CallGetStationItemBits
CallGetStationExtraInfo
CallGetCorporateStationInfo
CallGetCorporation
CallList (inventory)
CallGetAgents
CallGetGuests
 */

CallGetMultiOwnersEx::CallGetMultiOwnersEx() {
	/*  0  */
}

CallGetMultiOwnersEx::~CallGetMultiOwnersEx() {
	/*  0  */
}

void CallGetMultiOwnersEx::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallGetMultiOwnersEx", pfx);
	/*  0  */
	_log(l_type, "%sentities: Integer list with %d enetires", pfx, entities.size());
	std::vector<uint32>::const_iterator entities_cur, entities_end;
	entities_cur = entities.begin();
	entities_end = entities.end();
	int entities_index;
	for(entities_index = 0; entities_cur != entities_end; entities_cur++, entities_index++) {
		_log(l_type, "%s   [%02d] %d", pfx, entities_index, *entities_cur);
	}
	
}

PyRepTuple *CallGetMultiOwnersEx::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator entities_cur, entities_end;
	entities_cur = entities.begin();
	entities_end = entities.end();
	for(; entities_cur != entities_end; entities_cur++) {
		list1->items.push_back(
			new PyRepInteger(*entities_cur)
		);
	}
	tuple0->items[0] = list1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *CallGetMultiOwnersEx::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator entities_cur, entities_end;
	entities_cur = entities.begin();
	entities_end = entities.end();
	for(; entities_cur != entities_end; entities_cur++) {
		list1->items.push_back(
			new PyRepInteger(*entities_cur)
		);
	}
	tuple0->items[0] = list1;
	
	res = tuple0;
	

	return(res);
}

bool CallGetMultiOwnersEx::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallGetMultiOwnersEx::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallGetMultiOwnersEx failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode CallGetMultiOwnersEx failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode CallGetMultiOwnersEx failed: entities is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	entities.clear();
	PyRepList *list_1 = (PyRepList *) tuple0->items[0];
	PyRepList::iterator entities_cur, entities_end;
	entities_cur = list_1->items.begin();
	entities_end = list_1->items.end();
	int entities_index;
	for(entities_index = 0; entities_cur != entities_end; entities_cur++, entities_index++) {
		if(!(*entities_cur)->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode CallGetMultiOwnersEx failed: Element %d in list entities is not an integer: %s", entities_index, (*entities_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *t = (PyRepInteger *) (*entities_cur);
		if(t->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode CallGetMultiOwnersEx: truncating 64 bit into into 32 bit int for item %d in field entities", entities_index);
		}
		entities.push_back(t->value);
	}


	delete packet;
	return(true);
}

CallGetMultiOwnersEx *CallGetMultiOwnersEx::Clone() const {
	CallGetMultiOwnersEx *res = new CallGetMultiOwnersEx;
	res->CloneFrom(this);
	return(res);
}

void CallGetMultiOwnersEx::CloneFrom(const CallGetMultiOwnersEx *from) {
	/*  0  */
	entities = from->entities;
	
}


RspGetMultiOwnersEx::RspGetMultiOwnersEx() {
	/*  0  */
}

RspGetMultiOwnersEx::~RspGetMultiOwnersEx() {
	/*  0  */
}

void RspGetMultiOwnersEx::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspGetMultiOwnersEx", pfx);
	/*  0  */
	_log(l_type, "%srowset:", pfx);
	std::string rowset_n(pfx);
	rowset_n += "    ";
	rowset.Dump(l_type, rowset_n.c_str());
}

PyRepTuple *RspGetMultiOwnersEx::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
		ss_1 = rowset.Encode();
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

PyRepTuple *RspGetMultiOwnersEx::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
		ss_1 = rowset.FastEncode();
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspGetMultiOwnersEx::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspGetMultiOwnersEx::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetMultiOwnersEx failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspGetMultiOwnersEx failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspGetMultiOwnersEx failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspGetMultiOwnersEx failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	PyRep *rep_2 = ss_1->decoded;
	ss_1->decoded = NULL;
	if(!rowset.Decode(&rep_2)) {
		_log(NET__PACKET_ERROR, "Decode RspGetMultiOwnersEx failed: unable to decode element rowset");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

RspGetMultiOwnersEx *RspGetMultiOwnersEx::Clone() const {
	RspGetMultiOwnersEx *res = new RspGetMultiOwnersEx;
	res->CloneFrom(this);
	return(res);
}

void RspGetMultiOwnersEx::CloneFrom(const RspGetMultiOwnersEx *from) {
	/*  0  */
	rowset.CloneFrom(&from->rowset);
	
}


CallMachoResolveObject::CallMachoResolveObject() {
	/*  0  */
	entitySpec = NULL;
	/*  1  */
	justQuery = 0;
}

CallMachoResolveObject::~CallMachoResolveObject() {
	/*  0  */
	delete entitySpec;
	/*  1  */
}

void CallMachoResolveObject::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallMachoResolveObject", pfx);
	/*  0  */
	_log(l_type, "%sentitySpec:", pfx);
	std::string entitySpec_n(pfx);
	entitySpec_n += "    ";
	if(entitySpec == NULL) {
		_log(l_type, "%sERROR: NULL REP!", entitySpec_n.c_str());
	} else {
		entitySpec->Dump(l_type, entitySpec_n.c_str());
	}
	/*  1  */
	_log(l_type, "%sjustQuery=%lu", pfx, justQuery);
}

PyRepTuple *CallMachoResolveObject::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	if(entitySpec == NULL) {
		_log(NET__PACKET_ERROR, "Encode CallMachoResolveObject: entitySpec is NULL! hacking in a PyRepNone");
		entitySpec = new PyRepNone();
	}
	tuple0->items[0] = entitySpec->Clone();
	/*  1  */
	tuple0->items[1] = new PyRepInteger(justQuery);
	res = tuple0;
	

	return(res);
}

PyRepTuple *CallMachoResolveObject::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	if(entitySpec == NULL) {
		_log(NET__PACKET_ERROR, "Encode CallMachoResolveObject: entitySpec is NULL! hacking in a PyRepNone");
		entitySpec = new PyRepNone();
	}
	tuple0->items[0] = entitySpec;
	entitySpec = NULL;
	/*  1  */
	tuple0->items[1] = new PyRepInteger(justQuery);
	res = tuple0;
	

	return(res);
}

bool CallMachoResolveObject::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallMachoResolveObject::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallMachoResolveObject failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode CallMachoResolveObject failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	delete entitySpec;
	entitySpec = tuple0->items[0];
	tuple0->items[0] = NULL;
	
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallMachoResolveObject failed: justQuery is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[1];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallMachoResolveObject: truncating 64 bit into into 32 bit int for field justQuery");
	}
	justQuery = int_1->value;

	delete packet;
	return(true);
}

CallMachoResolveObject *CallMachoResolveObject::Clone() const {
	CallMachoResolveObject *res = new CallMachoResolveObject;
	res->CloneFrom(this);
	return(res);
}

void CallMachoResolveObject::CloneFrom(const CallMachoResolveObject *from) {
	/*  0  */
	delete entitySpec;
	if(from->entitySpec == NULL) {
		entitySpec = NULL;
	} else {
		entitySpec = from->entitySpec->Clone();
	}
	/*  1  */
	justQuery = from->justQuery;
	
}


RspMachoResolveObject::RspMachoResolveObject() {
	/*  0  */
	nodeID = 0;
}

RspMachoResolveObject::~RspMachoResolveObject() {
	/*  0  */
}

void RspMachoResolveObject::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspMachoResolveObject", pfx);
	/*  0  */
	_log(l_type, "%snodeID=%lu", pfx, nodeID);
}

PyRepTuple *RspMachoResolveObject::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	ss_1 = new PyRepInteger(nodeID);
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

PyRepTuple *RspMachoResolveObject::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	ss_1 = new PyRepInteger(nodeID);
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspMachoResolveObject::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspMachoResolveObject::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspMachoResolveObject failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspMachoResolveObject failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspMachoResolveObject failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspMachoResolveObject failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	if(!ss_1->decoded->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode RspMachoResolveObject failed: nodeID is not an int: %s", ss_1->decoded->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) ss_1->decoded;
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode RspMachoResolveObject: truncating 64 bit into into 32 bit int for field nodeID");
	}
	nodeID = int_2->value;

	delete packet;
	return(true);
}

RspMachoResolveObject *RspMachoResolveObject::Clone() const {
	RspMachoResolveObject *res = new RspMachoResolveObject;
	res->CloneFrom(this);
	return(res);
}

void RspMachoResolveObject::CloneFrom(const RspMachoResolveObject *from) {
	/*  0  */
	nodeID = from->nodeID;
	
}


CallMachoBindObject_call::CallMachoBindObject_call() {
	/*  0  */
	method_name = "";
	/*  1  */
	arguments = NULL;
	/*  2  */
}

CallMachoBindObject_call::~CallMachoBindObject_call() {
	/*  0  */
	/*  1  */
	delete arguments;
	/*  2  */
}

void CallMachoBindObject_call::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallMachoBindObject_call", pfx);
	/*  0  */
	_log(l_type, "%smethod_name='%s'", pfx, method_name.c_str());
	/*  1  */
	_log(l_type, "%sarguments:", pfx);
	std::string arguments_n(pfx);
	arguments_n += "    ";
	if(arguments == NULL) {
		_log(l_type, "%sERROR: NULL TUPLE!", arguments_n.c_str());
	} else {
		arguments->Dump(l_type, arguments_n.c_str());
	}
	/*  2  */
	_log(l_type, "%sdict_arguments: ", pfx);
	std::string dict_arguments_n(pfx);
	dict_arguments_n += "    ";
	dict_arguments.Dump(l_type, dict_arguments_n.c_str());
}

PyRepTuple *CallMachoBindObject_call::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	/*  0  */
	tuple0->items[0] = new PyRepString(method_name);
	/*  1  */
	if(arguments == NULL) {
		_log(NET__PACKET_ERROR, "Encode CallMachoBindObject_call: arguments is NULL! hacking in an empty tuple.");
		arguments = new PyRepTuple(0);
	}
	tuple0->items[1] = arguments->Clone();
	/*  2  */
	tuple0->items[2] = dict_arguments.Clone();
	res = tuple0;
	

	return(res);
}

PyRepTuple *CallMachoBindObject_call::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	/*  0  */
	tuple0->items[0] = new PyRepString(method_name);
	/*  1  */
	if(arguments == NULL) {
		_log(NET__PACKET_ERROR, "Encode CallMachoBindObject_call: arguments is NULL! hacking in an empty tuple.");
		arguments = new PyRepTuple(0);
	}
	
	PyRepTuple *list1 = new PyRepTuple(0);
	list1->items = arguments->items;
	arguments->items.clear();
	tuple0->items[1] = list1;
	/*  2  */
	
	PyRepDict *dict2 = new PyRepDict();
	dict2->items = dict_arguments.items;
	dict_arguments.items.clear();
	tuple0->items[2] = dict2;
	res = tuple0;
	

	return(res);
}

bool CallMachoBindObject_call::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallMachoBindObject_call::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallMachoBindObject_call failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode CallMachoBindObject_call failed: tuple0 is the wrong size: expected 3, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode CallMachoBindObject_call failed: method_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	method_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallMachoBindObject_call failed: arguments is not a tuple: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	arguments = (PyRepTuple *) tuple0->items[1];
	tuple0->items[1] = NULL;
	
	/*  2  */
	if(!tuple0->items[2]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode CallMachoBindObject_call failed: dict_arguments is not a dict: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepDict *list_dict_arguments = (PyRepDict *) tuple0->items[2];	dict_arguments.items = list_dict_arguments->items;
	list_dict_arguments->items.clear();
	

	delete packet;
	return(true);
}

CallMachoBindObject_call *CallMachoBindObject_call::Clone() const {
	CallMachoBindObject_call *res = new CallMachoBindObject_call;
	res->CloneFrom(this);
	return(res);
}

void CallMachoBindObject_call::CloneFrom(const CallMachoBindObject_call *from) {
	/*  0  */
	method_name = from->method_name;
	/*  1  */
	delete arguments;
	if(from->arguments == NULL) {
		arguments = NULL;
	} else {
		arguments = from->arguments->TypedClone();
	}
	/*  2  */
	dict_arguments.CloneFrom(&from->dict_arguments);
	
}


CallMachoBindObject::CallMachoBindObject() {
	/*  0  */
	entitySpec = NULL;
	/*  1  */
	/*  either 'None', or a CallMachoBindObject_call  */
	call = NULL;
}

CallMachoBindObject::~CallMachoBindObject() {
	/*  0  */
	delete entitySpec;
	/*  1  */
	/*  either 'None', or a CallMachoBindObject_call  */
	delete call;
}

void CallMachoBindObject::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallMachoBindObject", pfx);
	/*  0  */
	_log(l_type, "%sentitySpec:", pfx);
	std::string entitySpec_n(pfx);
	entitySpec_n += "    ";
	if(entitySpec == NULL) {
		_log(l_type, "%sERROR: NULL REP!", entitySpec_n.c_str());
	} else {
		entitySpec->Dump(l_type, entitySpec_n.c_str());
	}
	/*  1  */
	/*  either 'None', or a CallMachoBindObject_call  */
	_log(l_type, "%scall:", pfx);
	std::string call_n(pfx);
	call_n += "    ";
	if(call == NULL) {
		_log(l_type, "%sERROR: NULL REP!", call_n.c_str());
	} else {
		call->Dump(l_type, call_n.c_str());
	}
}

PyRepTuple *CallMachoBindObject::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	if(entitySpec == NULL) {
		_log(NET__PACKET_ERROR, "Encode CallMachoBindObject: entitySpec is NULL! hacking in a PyRepNone");
		entitySpec = new PyRepNone();
	}
	tuple0->items[0] = entitySpec->Clone();
	/*  1  */
	/*  either 'None', or a CallMachoBindObject_call  */
	if(call == NULL) {
		_log(NET__PACKET_ERROR, "Encode CallMachoBindObject: call is NULL! hacking in a PyRepNone");
		call = new PyRepNone();
	}
	tuple0->items[1] = call->Clone();
	res = tuple0;
	

	return(res);
}

PyRepTuple *CallMachoBindObject::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	if(entitySpec == NULL) {
		_log(NET__PACKET_ERROR, "Encode CallMachoBindObject: entitySpec is NULL! hacking in a PyRepNone");
		entitySpec = new PyRepNone();
	}
	tuple0->items[0] = entitySpec;
	entitySpec = NULL;
	/*  1  */
	/*  either 'None', or a CallMachoBindObject_call  */
	if(call == NULL) {
		_log(NET__PACKET_ERROR, "Encode CallMachoBindObject: call is NULL! hacking in a PyRepNone");
		call = new PyRepNone();
	}
	tuple0->items[1] = call;
	call = NULL;
	res = tuple0;
	

	return(res);
}

bool CallMachoBindObject::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallMachoBindObject::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallMachoBindObject failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode CallMachoBindObject failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	delete entitySpec;
	entitySpec = tuple0->items[0];
	tuple0->items[0] = NULL;
	
	/*  1  */
	/*  either 'None', or a CallMachoBindObject_call  */
	delete call;
	call = tuple0->items[1];
	tuple0->items[1] = NULL;
	

	delete packet;
	return(true);
}

CallMachoBindObject *CallMachoBindObject::Clone() const {
	CallMachoBindObject *res = new CallMachoBindObject;
	res->CloneFrom(this);
	return(res);
}

void CallMachoBindObject::CloneFrom(const CallMachoBindObject *from) {
	/*  0  */
	delete entitySpec;
	if(from->entitySpec == NULL) {
		entitySpec = NULL;
	} else {
		entitySpec = from->entitySpec->Clone();
	}
	/*  1  */
	/*  either 'None', or a CallMachoBindObject_call  */
	delete call;
	if(from->call == NULL) {
		call = NULL;
	} else {
		call = from->call->Clone();
	}
	
}


BoundObject::BoundObject() {
	/*  0  */
	bindspec = "";
	/*  1  */
	timestamp = 0;
}

BoundObject::~BoundObject() {
	/*  0  */
	/*  1  */
}

void BoundObject::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sBoundObject", pfx);
	/*  0  */
	_log(l_type, "%sbindspec='%s'", pfx, bindspec.c_str());
	/*  1  */
	_log(l_type, "%stimestamp=" I64u, pfx, timestamp);
}

PyRepSubStruct *BoundObject::Encode() {
	PyRepSubStruct *res = NULL;
	PyRep *ss_0;
	PyRep *ss_1;
	PyRepTuple *tuple2 = new PyRepTuple(2);
	/*  0  */
	tuple2->items[0] = new PyRepString(bindspec);
	/*  1  */
	tuple2->items[1] = new PyRepInteger(timestamp);
	ss_1 = tuple2;
	
	ss_0 = new PyRepSubStream(ss_1);
	res = new PyRepSubStruct(ss_0);

	return(res);
}

PyRepSubStruct *BoundObject::FastEncode() {
	PyRepSubStruct *res = NULL;
	PyRep *ss_0;
	PyRep *ss_1;
	PyRepTuple *tuple2 = new PyRepTuple(2);
	/*  0  */
	tuple2->items[0] = new PyRepString(bindspec);
	/*  1  */
	tuple2->items[1] = new PyRepInteger(timestamp);
	ss_1 = tuple2;
	
	ss_0 = new PyRepSubStream(ss_1);
	res = new PyRepSubStruct(ss_0);

	return(res);
}

bool BoundObject::Decode(PyRepSubStruct **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool BoundObject::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::SubStruct)) {
		_log(NET__PACKET_ERROR, "Decode BoundObject failed: ss_0 is not a substruct: %s", packet->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStruct *ss_0 = (PyRepSubStruct *) packet;
	
	if(!ss_0->sub->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode BoundObject failed: ss_1 is not a substream: %s", ss_0->sub->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) ss_0->sub;
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode BoundObject failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	if(!ss_1->decoded->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode BoundObject failed: tuple2 is the wrong type: %s", ss_1->decoded->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) ss_1->decoded;
	if(tuple2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode BoundObject failed: tuple2 is the wrong size: expected 2, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple2->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode BoundObject failed: bindspec is not a string: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) tuple2->items[0];
	bindspec = string_3->value;
	/*  1  */
	if(!tuple2->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode BoundObject failed: timestamp is not an int: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_4 = (PyRepInteger *) tuple2->items[1];
	timestamp = int64_4->value;

	delete packet;
	return(true);
}

BoundObject *BoundObject::Clone() const {
	BoundObject *res = new BoundObject;
	res->CloneFrom(this);
	return(res);
}

void BoundObject::CloneFrom(const BoundObject *from) {
	/*  0  */
	bindspec = from->bindspec;
	/*  1  */
	timestamp = from->timestamp;
	
}


RspMachoBindObject::RspMachoBindObject() {
	/*  0  */
	/*  0  */
	/*  1  */
	call_return = NULL;
}

RspMachoBindObject::~RspMachoBindObject() {
	/*  0  */
	/*  0  */
	/*  1  */
	delete call_return;
}

void RspMachoBindObject::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspMachoBindObject", pfx);
	/*  0  */
	/*  0  */
	_log(l_type, "%sbind:", pfx);
	std::string bind_n(pfx);
	bind_n += "    ";
	bind.Dump(l_type, bind_n.c_str());
	/*  1  */
	_log(l_type, "%scall_return:", pfx);
	std::string call_return_n(pfx);
	call_return_n += "    ";
	if(call_return == NULL) {
		_log(l_type, "%sERROR: NULL REP!", call_return_n.c_str());
	} else {
		call_return->Dump(l_type, call_return_n.c_str());
	}
}

PyRepTuple *RspMachoBindObject::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	PyRepTuple *tuple2 = new PyRepTuple(2);
	/*  0  */
		tuple2->items[0] = bind.Encode();
	/*  1  */
	if(call_return == NULL) {
		_log(NET__PACKET_ERROR, "Encode RspMachoBindObject: call_return is NULL! hacking in a PyRepNone");
		call_return = new PyRepNone();
	}
	tuple2->items[1] = call_return->Clone();
	ss_1 = tuple2;
	
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

PyRepTuple *RspMachoBindObject::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	PyRepTuple *tuple2 = new PyRepTuple(2);
	/*  0  */
		tuple2->items[0] = bind.FastEncode();
	/*  1  */
	if(call_return == NULL) {
		_log(NET__PACKET_ERROR, "Encode RspMachoBindObject: call_return is NULL! hacking in a PyRepNone");
		call_return = new PyRepNone();
	}
	tuple2->items[1] = call_return;
	call_return = NULL;
	ss_1 = tuple2;
	
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspMachoBindObject::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspMachoBindObject::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspMachoBindObject failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspMachoBindObject failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspMachoBindObject failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspMachoBindObject failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	if(!ss_1->decoded->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspMachoBindObject failed: tuple2 is the wrong type: %s", ss_1->decoded->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) ss_1->decoded;
	if(tuple2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode RspMachoBindObject failed: tuple2 is the wrong size: expected 2, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	PyRep *rep_3 = tuple2->items[0];
	tuple2->items[0] = NULL;
	if(!bind.Decode(&rep_3)) {
		_log(NET__PACKET_ERROR, "Decode RspMachoBindObject failed: unable to decode element bind");
		delete packet;
		return(false);
	}
	
	/*  1  */
	delete call_return;
	call_return = tuple2->items[1];
	tuple2->items[1] = NULL;
	

	delete packet;
	return(true);
}

RspMachoBindObject *RspMachoBindObject::Clone() const {
	RspMachoBindObject *res = new RspMachoBindObject;
	res->CloneFrom(this);
	return(res);
}

void RspMachoBindObject::CloneFrom(const RspMachoBindObject *from) {
	/*  0  */
	/*  0  */
	bind.CloneFrom(&from->bind);
	/*  1  */
	delete call_return;
	if(from->call_return == NULL) {
		call_return = NULL;
	} else {
		call_return = from->call_return->Clone();
	}
	
}


ErrorResponseBody::ErrorResponseBody() {
	/*  0  */
	CauseMsgType = 0;
	/*  1  */
	ErrorCode = 0;
	/*  2  */
	/*  0  */
	payload = NULL;
}

ErrorResponseBody::~ErrorResponseBody() {
	/*  0  */
	/*  1  */
	/*  2  */
	/*  0  */
	delete payload;
}

void ErrorResponseBody::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sErrorResponseBody", pfx);
	/*  0  */
	_log(l_type, "%sCauseMsgType=%lu", pfx, CauseMsgType);
	/*  1  */
	_log(l_type, "%sErrorCode=%lu", pfx, ErrorCode);
	/*  2  */
	/*  0  */
	_log(l_type, "%spayload:", pfx);
	std::string payload_n(pfx);
	payload_n += "    ";
	if(payload == NULL) {
		_log(l_type, "%sERROR: NULL REP!", payload_n.c_str());
	} else {
		payload->Dump(l_type, payload_n.c_str());
	}
}

PyRepTuple *ErrorResponseBody::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	/*  0  */
	tuple0->items[0] = new PyRepInteger(CauseMsgType);
	/*  1  */
	tuple0->items[1] = new PyRepInteger(ErrorCode);
	/*  2  */
	PyRepTuple *tuple1 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_2;
	if(payload == NULL) {
		_log(NET__PACKET_ERROR, "Encode ErrorResponseBody: payload is NULL! hacking in a PyRepNone");
		payload = new PyRepNone();
	}
	ss_2 = payload->Clone();
	tuple1->items[0] = new PyRepSubStream(ss_2);
	tuple0->items[2] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *ErrorResponseBody::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	/*  0  */
	tuple0->items[0] = new PyRepInteger(CauseMsgType);
	/*  1  */
	tuple0->items[1] = new PyRepInteger(ErrorCode);
	/*  2  */
	PyRepTuple *tuple1 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_2;
	if(payload == NULL) {
		_log(NET__PACKET_ERROR, "Encode ErrorResponseBody: payload is NULL! hacking in a PyRepNone");
		payload = new PyRepNone();
	}
	ss_2 = payload;
	payload = NULL;
	tuple1->items[0] = new PyRepSubStream(ss_2);
	tuple0->items[2] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool ErrorResponseBody::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool ErrorResponseBody::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode ErrorResponseBody failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode ErrorResponseBody failed: tuple0 is the wrong size: expected 3, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode ErrorResponseBody failed: CauseMsgType is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode ErrorResponseBody: truncating 64 bit into into 32 bit int for field CauseMsgType");
	}
	CauseMsgType = int_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode ErrorResponseBody failed: ErrorCode is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode ErrorResponseBody: truncating 64 bit into into 32 bit int for field ErrorCode");
	}
	ErrorCode = int_2->value;
	/*  2  */
	if(!tuple0->items[2]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode ErrorResponseBody failed: tuple3 is the wrong type: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple3 = (PyRepTuple *) tuple0->items[2];
	if(tuple3->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode ErrorResponseBody failed: tuple3 is the wrong size: expected 1, but got %d", tuple3->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple3->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode ErrorResponseBody failed: ss_4 is not a substream: %s", tuple3->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_4 = (PyRepSubStream *) tuple3->items[0];
	//make sure its decoded
	ss_4->DecodeData();
	if(ss_4->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode ErrorResponseBody failed: Unable to decode ss_4");
		delete packet;
		return(false);
	}
	
	delete payload;
	payload = ss_4->decoded;
	ss_4->decoded = NULL;
	

	delete packet;
	return(true);
}

ErrorResponseBody *ErrorResponseBody::Clone() const {
	ErrorResponseBody *res = new ErrorResponseBody;
	res->CloneFrom(this);
	return(res);
}

void ErrorResponseBody::CloneFrom(const ErrorResponseBody *from) {
	/*  0  */
	CauseMsgType = from->CauseMsgType;
	/*  1  */
	ErrorCode = from->ErrorCode;
	/*  2  */
	/*  0  */
	delete payload;
	if(from->payload == NULL) {
		payload = NULL;
	} else {
		payload = from->payload->Clone();
	}
	
}


macho_WrongMachoNode::macho_WrongMachoNode() {
	/* object of type macho.WrongMachoNode */
	nodeID = 0;
}

macho_WrongMachoNode::~macho_WrongMachoNode() {
}

void macho_WrongMachoNode::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%smacho_WrongMachoNode", pfx);
	_log(l_type, "%sObject of type macho.WrongMachoNode:", pfx);
	_log(l_type, "%snodeID=%lu", pfx, nodeID);
}

PyRepObject *macho_WrongMachoNode::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	dict1_0 = new PyRepInteger(nodeID);
	dict1->items[
		new PyRepString("payload")
	] = dict1_0;
	args0 = dict1;
	
	res = new PyRepObject(
			"macho.WrongMachoNode",
			args0
		);
	

	return(res);
}

PyRepObject *macho_WrongMachoNode::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	dict1_0 = new PyRepInteger(nodeID);
	dict1->items[
		new PyRepString("payload")
	] = dict1_0;
	args0 = dict1;
	
	res = new PyRepObject(
			"macho.WrongMachoNode",
			args0
		);
	

	return(res);
}

bool macho_WrongMachoNode::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool macho_WrongMachoNode::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode macho_WrongMachoNode failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "macho.WrongMachoNode") {
		_log(NET__PACKET_ERROR, "Decode macho_WrongMachoNode failed: obj_0 is the wrong object type. Expected 'macho.WrongMachoNode', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode macho_WrongMachoNode failed: dict1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict1_nodeID = false;
	PyRepDict *dict1 = (PyRepDict *) obj_0->arguments;
	
	PyRepDict::iterator dict1_cur, dict1_end;
	dict1_cur = dict1->items.begin();
	dict1_end = dict1->items.end();
	for(; dict1_cur != dict1_end; dict1_cur++) {
		PyRep *key__ = dict1_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode macho_WrongMachoNode failed: a key in dict1 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "payload") {
			dict1_nodeID = true;
	if(!dict1_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode macho_WrongMachoNode failed: nodeID is not an int: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) dict1_cur->second;
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode macho_WrongMachoNode: truncating 64 bit into into 32 bit int for field nodeID");
	}
	nodeID = int_2->value;
		} else
		{
			_log(NET__PACKET_ERROR, "Decode macho_WrongMachoNode failed: Unknown key string '%s' in dict1", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict1_nodeID) {
		_log(NET__PACKET_ERROR, "Decode macho_WrongMachoNode failed: Missing dict entry for 'nodeID' in dict1");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

macho_WrongMachoNode *macho_WrongMachoNode::Clone() const {
	macho_WrongMachoNode *res = new macho_WrongMachoNode;
	res->CloneFrom(this);
	return(res);
}

void macho_WrongMachoNode::CloneFrom(const macho_WrongMachoNode *from) {
	/* object of type macho.WrongMachoNode */
	nodeID = from->nodeID;
	
}


macho_MachoException::macho_MachoException() {
	/*  MACHONETMSG_TYPE  */
	in_response_to = 0;
	/*  MACHONETERR_TYPE  */
	exception_type = 0;
	/*  substream  */
	payload = NULL;
}

macho_MachoException::~macho_MachoException() {
	/*  MACHONETMSG_TYPE  */
	/*  MACHONETERR_TYPE  */
	/*  substream  */
	delete payload;
}

void macho_MachoException::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%smacho_MachoException", pfx);
	/*  MACHONETMSG_TYPE  */
	_log(l_type, "%sin_response_to=%lu", pfx, in_response_to);
	/*  MACHONETERR_TYPE  */
	_log(l_type, "%sexception_type=%lu", pfx, exception_type);
	/*  substream  */
	_log(l_type, "%spayload:", pfx);
	std::string payload_n(pfx);
	payload_n += "    ";
	if(payload == NULL) {
		_log(l_type, "%sERROR: NULL REP!", payload_n.c_str());
	} else {
		payload->Dump(l_type, payload_n.c_str());
	}
}

PyRepTuple *macho_MachoException::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	/*  MACHONETMSG_TYPE  */
	tuple0->items[0] = new PyRepInteger(in_response_to);
	/*  MACHONETERR_TYPE  */
	tuple0->items[1] = new PyRepInteger(exception_type);
	PyRepTuple *tuple1 = new PyRepTuple(1);
	/*  substream  */
	if(payload == NULL) {
		_log(NET__PACKET_ERROR, "Encode macho_MachoException: payload is NULL! hacking in a PyRepNone");
		payload = new PyRepNone();
	}
	tuple1->items[0] = payload->Clone();
	tuple0->items[2] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *macho_MachoException::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	/*  MACHONETMSG_TYPE  */
	tuple0->items[0] = new PyRepInteger(in_response_to);
	/*  MACHONETERR_TYPE  */
	tuple0->items[1] = new PyRepInteger(exception_type);
	PyRepTuple *tuple1 = new PyRepTuple(1);
	/*  substream  */
	if(payload == NULL) {
		_log(NET__PACKET_ERROR, "Encode macho_MachoException: payload is NULL! hacking in a PyRepNone");
		payload = new PyRepNone();
	}
	tuple1->items[0] = payload;
	payload = NULL;
	tuple0->items[2] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool macho_MachoException::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool macho_MachoException::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode macho_MachoException failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode macho_MachoException failed: tuple0 is the wrong size: expected 3, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  MACHONETMSG_TYPE  */
	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode macho_MachoException failed: in_response_to is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode macho_MachoException: truncating 64 bit into into 32 bit int for field in_response_to");
	}
	in_response_to = int_1->value;
	/*  MACHONETERR_TYPE  */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode macho_MachoException failed: exception_type is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode macho_MachoException: truncating 64 bit into into 32 bit int for field exception_type");
	}
	exception_type = int_2->value;
	if(!tuple0->items[2]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode macho_MachoException failed: tuple3 is the wrong type: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple3 = (PyRepTuple *) tuple0->items[2];
	if(tuple3->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode macho_MachoException failed: tuple3 is the wrong size: expected 1, but got %d", tuple3->items.size());
		delete packet;
		return(false);
	}

	/*  substream  */
	delete payload;
	payload = tuple3->items[0];
	tuple3->items[0] = NULL;
	

	delete packet;
	return(true);
}

macho_MachoException *macho_MachoException::Clone() const {
	macho_MachoException *res = new macho_MachoException;
	res->CloneFrom(this);
	return(res);
}

void macho_MachoException::CloneFrom(const macho_MachoException *from) {
	/*  MACHONETMSG_TYPE  */
	in_response_to = from->in_response_to;
	/*  MACHONETERR_TYPE  */
	exception_type = from->exception_type;
	/*  substream  */
	delete payload;
	if(from->payload == NULL) {
		payload = NULL;
	} else {
		payload = from->payload->Clone();
	}
	
}


NotifyOnAggressionChange::NotifyOnAggressionChange() {
	/*  0  */
	integer0 = 0;
	/*  1  */
	/*  maps _something_ to a timestamp  */
}

NotifyOnAggressionChange::~NotifyOnAggressionChange() {
	/*  0  */
	/*  1  */
	/*  maps _something_ to a timestamp  */
	std::map<uint32, PyRep *>::iterator entries_cur, entries_end;
	//free any existing elements first
	entries_cur = entries.begin();
	entries_end = entries.end();
	for(; entries_cur != entries_end; entries_cur++) {
		delete entries_cur->second;
	}
	
}

void NotifyOnAggressionChange::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotifyOnAggressionChange", pfx);
	/*  0  */
	_log(l_type, "%sinteger0=%lu", pfx, integer0);
	/*  1  */
	/*  maps _something_ to a timestamp  */
	_log(l_type, "%sentries: Dictionaty with %d enetires", pfx, entries.size());
	std::map<uint32, PyRep *>::const_iterator entries_cur, entries_end;
	entries_cur = entries.begin();
	entries_end = entries.end();
	for(; entries_cur != entries_end; entries_cur++) {
		_log(l_type, "%s   Key: %lu", pfx, entries_cur->first);
		std::string n(pfx);
		n += "        ";
		entries_cur->second->Dump(stdout, n.c_str());
	}
	
}

PyRepTuple *NotifyOnAggressionChange::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepInteger(integer0);
	/*  1  */
	/*  maps _something_ to a timestamp  */
	
	PyRepDict *dict1 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator entries_cur, entries_end;
	entries_cur = entries.begin();
	entries_end = entries.end();
	for(; entries_cur != entries_end; entries_cur++) {
		dict1->items[
			new PyRepInteger(entries_cur->first)
		] = entries_cur->second->Clone();
	}
	tuple0->items[1] = dict1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *NotifyOnAggressionChange::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepInteger(integer0);
	/*  1  */
	/*  maps _something_ to a timestamp  */
	
	PyRepDict *dict1 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator entries_cur, entries_end;
	entries_cur = entries.begin();
	entries_end = entries.end();
	for(; entries_cur != entries_end; entries_cur++) {
		dict1->items[
			new PyRepInteger(entries_cur->first)
		] = entries_cur->second;
	}
	entries.clear();
	tuple0->items[1] = dict1;
	
	res = tuple0;
	

	return(res);
}

bool NotifyOnAggressionChange::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool NotifyOnAggressionChange::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnAggressionChange failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnAggressionChange failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnAggressionChange failed: integer0 is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode NotifyOnAggressionChange: truncating 64 bit into into 32 bit int for field integer0");
	}
	integer0 = int_1->value;
	/*  1  */
	/*  maps _something_ to a timestamp  */
	if(!tuple0->items[1]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnAggressionChange failed: entries is not a dict: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	entries.clear();
	PyRepDict *dict_2 = (PyRepDict *) tuple0->items[1];
	PyRepDict::iterator entries_cur, entries_end;
	entries_cur = dict_2->items.begin();
	entries_end = dict_2->items.end();
	int entries_index;
	for(entries_index = 0; entries_cur != entries_end; entries_cur++, entries_index++) {
		if(!entries_cur->first->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode NotifyOnAggressionChange failed: Key %d in dict entries is not an integer: %s", entries_index, entries_cur->first->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *k = (PyRepInteger *) entries_cur->first;
		if(k->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode NotifyOnAggressionChange: truncating 64 bit into into 32 bit int in key of entry %d in field entries", entries_index);
		}
		entries[k->value] = entries_cur->second->Clone();
	}
	

	delete packet;
	return(true);
}

NotifyOnAggressionChange *NotifyOnAggressionChange::Clone() const {
	NotifyOnAggressionChange *res = new NotifyOnAggressionChange;
	res->CloneFrom(this);
	return(res);
}

void NotifyOnAggressionChange::CloneFrom(const NotifyOnAggressionChange *from) {
	/*  0  */
	integer0 = from->integer0;
	/*  1  */
	/*  maps _something_ to a timestamp  */
	std::map<uint32, PyRep *>::const_iterator entries_cur, entries_end;
	//free any existing elements first
	entries_cur = entries.begin();
	entries_end = entries.end();
	for(; entries_cur != entries_end; entries_cur++) {
		delete entries_cur->second;
	}
	entries.clear();
	//now we can copy in the new ones...
	entries_cur = from->entries.begin();
	entries_end = from->entries.end();
	for(; entries_cur != entries_end; entries_cur++) {
		entries[entries_cur->first] = entries_cur->second->Clone();
	}
	
	
}


CallGetInventoryFromId::CallGetInventoryFromId() {
	/*  0  */
	entityID = 0;
	/*  1  */
	passive = 0;
}

CallGetInventoryFromId::~CallGetInventoryFromId() {
	/*  0  */
	/*  1  */
}

void CallGetInventoryFromId::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallGetInventoryFromId", pfx);
	/*  0  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	/*  1  */
	_log(l_type, "%spassive=%lu", pfx, passive);
}

PyRepTuple *CallGetInventoryFromId::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepInteger(entityID);
	/*  1  */
	tuple0->items[1] = new PyRepInteger(passive);
	res = tuple0;
	

	return(res);
}

PyRepTuple *CallGetInventoryFromId::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepInteger(entityID);
	/*  1  */
	tuple0->items[1] = new PyRepInteger(passive);
	res = tuple0;
	

	return(res);
}

bool CallGetInventoryFromId::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallGetInventoryFromId::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallGetInventoryFromId failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode CallGetInventoryFromId failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallGetInventoryFromId failed: entityID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallGetInventoryFromId: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallGetInventoryFromId failed: passive is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallGetInventoryFromId: truncating 64 bit into into 32 bit int for field passive");
	}
	passive = int_2->value;

	delete packet;
	return(true);
}

CallGetInventoryFromId *CallGetInventoryFromId::Clone() const {
	CallGetInventoryFromId *res = new CallGetInventoryFromId;
	res->CloneFrom(this);
	return(res);
}

void CallGetInventoryFromId::CloneFrom(const CallGetInventoryFromId *from) {
	/*  0  */
	entityID = from->entityID;
	/*  1  */
	passive = from->passive;
	
}


RspGetInventoryFromId::RspGetInventoryFromId() {
	/*  0  */
}

RspGetInventoryFromId::~RspGetInventoryFromId() {
	/*  0  */
}

void RspGetInventoryFromId::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspGetInventoryFromId", pfx);
	/*  0  */
	_log(l_type, "%sbind:", pfx);
	std::string bind_n(pfx);
	bind_n += "    ";
	bind.Dump(l_type, bind_n.c_str());
}

PyRepTuple *RspGetInventoryFromId::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
		ss_1 = bind.Encode();
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

PyRepTuple *RspGetInventoryFromId::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
		ss_1 = bind.FastEncode();
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspGetInventoryFromId::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspGetInventoryFromId::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetInventoryFromId failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspGetInventoryFromId failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspGetInventoryFromId failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspGetInventoryFromId failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	PyRep *rep_2 = ss_1->decoded;
	ss_1->decoded = NULL;
	if(!bind.Decode(&rep_2)) {
		_log(NET__PACKET_ERROR, "Decode RspGetInventoryFromId failed: unable to decode element bind");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

RspGetInventoryFromId *RspGetInventoryFromId::Clone() const {
	RspGetInventoryFromId *res = new RspGetInventoryFromId;
	res->CloneFrom(this);
	return(res);
}

void RspGetInventoryFromId::CloneFrom(const RspGetInventoryFromId *from) {
	/*  0  */
	bind.CloneFrom(&from->bind);
	
}


RspGetMyKillRights::RspGetMyKillRights() {
	/*  0  */
	/*  0  */
	/*  1  */
}

RspGetMyKillRights::~RspGetMyKillRights() {
	/*  0  */
	/*  0  */
	/*  1  */
}

void RspGetMyKillRights::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspGetMyKillRights", pfx);
	/*  0  */
	/*  0  */
	_log(l_type, "%sunknown0: ", pfx);
	std::string unknown0_n(pfx);
	unknown0_n += "    ";
	unknown0.Dump(l_type, unknown0_n.c_str());
	/*  1  */
	_log(l_type, "%sunknown1: ", pfx);
	std::string unknown1_n(pfx);
	unknown1_n += "    ";
	unknown1.Dump(l_type, unknown1_n.c_str());
}

PyRepTuple *RspGetMyKillRights::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	PyRepTuple *tuple2 = new PyRepTuple(2);
	/*  0  */
	tuple2->items[0] = unknown0.Clone();
	/*  1  */
	tuple2->items[1] = unknown1.Clone();
	ss_1 = tuple2;
	
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

PyRepTuple *RspGetMyKillRights::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	PyRepTuple *tuple2 = new PyRepTuple(2);
	/*  0  */
	
	PyRepDict *dict3 = new PyRepDict();
	dict3->items = unknown0.items;
	unknown0.items.clear();
	tuple2->items[0] = dict3;
	/*  1  */
	
	PyRepDict *dict4 = new PyRepDict();
	dict4->items = unknown1.items;
	unknown1.items.clear();
	tuple2->items[1] = dict4;
	ss_1 = tuple2;
	
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspGetMyKillRights::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspGetMyKillRights::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetMyKillRights failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspGetMyKillRights failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspGetMyKillRights failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspGetMyKillRights failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	if(!ss_1->decoded->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetMyKillRights failed: tuple2 is the wrong type: %s", ss_1->decoded->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) ss_1->decoded;
	if(tuple2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode RspGetMyKillRights failed: tuple2 is the wrong size: expected 2, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple2->items[0]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode RspGetMyKillRights failed: unknown0 is not a dict: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepDict *list_unknown0 = (PyRepDict *) tuple2->items[0];	unknown0.items = list_unknown0->items;
	list_unknown0->items.clear();
	
	/*  1  */
	if(!tuple2->items[1]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode RspGetMyKillRights failed: unknown1 is not a dict: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepDict *list_unknown1 = (PyRepDict *) tuple2->items[1];	unknown1.items = list_unknown1->items;
	list_unknown1->items.clear();
	

	delete packet;
	return(true);
}

RspGetMyKillRights *RspGetMyKillRights::Clone() const {
	RspGetMyKillRights *res = new RspGetMyKillRights;
	res->CloneFrom(this);
	return(res);
}

void RspGetMyKillRights::CloneFrom(const RspGetMyKillRights *from) {
	/*  0  */
	/*  0  */
	unknown0.CloneFrom(&from->unknown0);
	/*  1  */
	unknown1.CloneFrom(&from->unknown1);
	
}


RspGetInitialState::RspGetInitialState() {
	/*  0  */
}

RspGetInitialState::~RspGetInitialState() {
	/*  0  */
}

void RspGetInitialState::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspGetInitialState", pfx);
	/*  0  */
	_log(l_type, "%srowset:", pfx);
	std::string rowset_n(pfx);
	rowset_n += "    ";
	rowset.Dump(l_type, rowset_n.c_str());
}

PyRepTuple *RspGetInitialState::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
		ss_1 = rowset.Encode();
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

PyRepTuple *RspGetInitialState::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
		ss_1 = rowset.FastEncode();
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspGetInitialState::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspGetInitialState::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetInitialState failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspGetInitialState failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspGetInitialState failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspGetInitialState failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	PyRep *rep_2 = ss_1->decoded;
	ss_1->decoded = NULL;
	if(!rowset.Decode(&rep_2)) {
		_log(NET__PACKET_ERROR, "Decode RspGetInitialState failed: unable to decode element rowset");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

RspGetInitialState *RspGetInitialState::Clone() const {
	RspGetInitialState *res = new RspGetInitialState;
	res->CloneFrom(this);
	return(res);
}

void RspGetInitialState::CloneFrom(const RspGetInitialState *from) {
	/*  0  */
	rowset.CloneFrom(&from->rowset);
	
}


CallGetCashBalance::CallGetCashBalance() {
	/*  0  */
	isCorpWallet = 0;
}

CallGetCashBalance::~CallGetCashBalance() {
	/*  0  */
}

void CallGetCashBalance::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallGetCashBalance", pfx);
	/*  0  */
	_log(l_type, "%sisCorpWallet=%lu", pfx, isCorpWallet);
}

PyRepTuple *CallGetCashBalance::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	tuple0->items[0] = new PyRepInteger(isCorpWallet);
	res = tuple0;
	

	return(res);
}

PyRepTuple *CallGetCashBalance::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	tuple0->items[0] = new PyRepInteger(isCorpWallet);
	res = tuple0;
	

	return(res);
}

bool CallGetCashBalance::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallGetCashBalance::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallGetCashBalance failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode CallGetCashBalance failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallGetCashBalance failed: isCorpWallet is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallGetCashBalance: truncating 64 bit into into 32 bit int for field isCorpWallet");
	}
	isCorpWallet = int_1->value;

	delete packet;
	return(true);
}

CallGetCashBalance *CallGetCashBalance::Clone() const {
	CallGetCashBalance *res = new CallGetCashBalance;
	res->CloneFrom(this);
	return(res);
}

void CallGetCashBalance::CloneFrom(const CallGetCashBalance *from) {
	/*  0  */
	isCorpWallet = from->isCorpWallet;
	
}


RspGetCashBalance::RspGetCashBalance() {
	/*  0  */
	credits = 0.0;
}

RspGetCashBalance::~RspGetCashBalance() {
	/*  0  */
}

void RspGetCashBalance::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspGetCashBalance", pfx);
	/*  0  */
	_log(l_type, "%scredits=%.13f", pfx, credits);
}

PyRepTuple *RspGetCashBalance::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	ss_1 = new PyRepReal(credits);
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

PyRepTuple *RspGetCashBalance::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	ss_1 = new PyRepReal(credits);
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspGetCashBalance::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspGetCashBalance::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCashBalance failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspGetCashBalance failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCashBalance failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspGetCashBalance failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	if(!ss_1->decoded->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCashBalance failed: credits is not a real: %s", ss_1->decoded->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_2 = (PyRepReal *) ss_1->decoded;
	credits = real_2->value;

	delete packet;
	return(true);
}

RspGetCashBalance *RspGetCashBalance::Clone() const {
	RspGetCashBalance *res = new RspGetCashBalance;
	res->CloneFrom(this);
	return(res);
}

void RspGetCashBalance::CloneFrom(const RspGetCashBalance *from) {
	/*  0  */
	credits = from->credits;
	
}


RspGetOwnerNoteLabels::RspGetOwnerNoteLabels() {
	/*  0  */
}

RspGetOwnerNoteLabels::~RspGetOwnerNoteLabels() {
	/*  0  */
}

void RspGetOwnerNoteLabels::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspGetOwnerNoteLabels", pfx);
	/*  0  */
	_log(l_type, "%snotes:", pfx);
	std::string notes_n(pfx);
	notes_n += "    ";
	notes.Dump(l_type, notes_n.c_str());
}

PyRepTuple *RspGetOwnerNoteLabels::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
		ss_1 = notes.Encode();
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

PyRepTuple *RspGetOwnerNoteLabels::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
		ss_1 = notes.FastEncode();
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspGetOwnerNoteLabels::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspGetOwnerNoteLabels::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetOwnerNoteLabels failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspGetOwnerNoteLabels failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspGetOwnerNoteLabels failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspGetOwnerNoteLabels failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	PyRep *rep_2 = ss_1->decoded;
	ss_1->decoded = NULL;
	if(!notes.Decode(&rep_2)) {
		_log(NET__PACKET_ERROR, "Decode RspGetOwnerNoteLabels failed: unable to decode element notes");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

RspGetOwnerNoteLabels *RspGetOwnerNoteLabels::Clone() const {
	RspGetOwnerNoteLabels *res = new RspGetOwnerNoteLabels;
	res->CloneFrom(this);
	return(res);
}

void RspGetOwnerNoteLabels::CloneFrom(const RspGetOwnerNoteLabels *from) {
	/*  0  */
	notes.CloneFrom(&from->notes);
	
}


RspGetStationItemBits::RspGetStationItemBits() {
	/*  0  */
	/*  0  */
	integer0 = 0;
	/*  1  */
	integer1 = 0;
	/*  2  */
	integer2 = 0;
	/*  3  */
	integer3 = 0;
	/*  4  */
	integer4 = 0;
}

RspGetStationItemBits::~RspGetStationItemBits() {
	/*  0  */
	/*  0  */
	/*  1  */
	/*  2  */
	/*  3  */
	/*  4  */
}

void RspGetStationItemBits::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspGetStationItemBits", pfx);
	/*  0  */
	/*  0  */
	_log(l_type, "%sinteger0=%lu", pfx, integer0);
	/*  1  */
	_log(l_type, "%sinteger1=%lu", pfx, integer1);
	/*  2  */
	_log(l_type, "%sinteger2=%lu", pfx, integer2);
	/*  3  */
	_log(l_type, "%sinteger3=%lu", pfx, integer3);
	/*  4  */
	_log(l_type, "%sinteger4=%lu", pfx, integer4);
}

PyRepTuple *RspGetStationItemBits::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	PyRepTuple *tuple2 = new PyRepTuple(5);
	/*  0  */
	tuple2->items[0] = new PyRepInteger(integer0);
	/*  1  */
	tuple2->items[1] = new PyRepInteger(integer1);
	/*  2  */
	tuple2->items[2] = new PyRepInteger(integer2);
	/*  3  */
	tuple2->items[3] = new PyRepInteger(integer3);
	/*  4  */
	tuple2->items[4] = new PyRepInteger(integer4);
	ss_1 = tuple2;
	
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

PyRepTuple *RspGetStationItemBits::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	PyRepTuple *tuple2 = new PyRepTuple(5);
	/*  0  */
	tuple2->items[0] = new PyRepInteger(integer0);
	/*  1  */
	tuple2->items[1] = new PyRepInteger(integer1);
	/*  2  */
	tuple2->items[2] = new PyRepInteger(integer2);
	/*  3  */
	tuple2->items[3] = new PyRepInteger(integer3);
	/*  4  */
	tuple2->items[4] = new PyRepInteger(integer4);
	ss_1 = tuple2;
	
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspGetStationItemBits::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspGetStationItemBits::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetStationItemBits failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspGetStationItemBits failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspGetStationItemBits failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspGetStationItemBits failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	if(!ss_1->decoded->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetStationItemBits failed: tuple2 is the wrong type: %s", ss_1->decoded->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) ss_1->decoded;
	if(tuple2->items.size() != 5) {
		_log(NET__PACKET_ERROR, "Decode RspGetStationItemBits failed: tuple2 is the wrong size: expected 5, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode RspGetStationItemBits failed: integer0 is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode RspGetStationItemBits: truncating 64 bit into into 32 bit int for field integer0");
	}
	integer0 = int_3->value;
	/*  1  */
	if(!tuple2->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode RspGetStationItemBits failed: integer1 is not an int: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple2->items[1];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode RspGetStationItemBits: truncating 64 bit into into 32 bit int for field integer1");
	}
	integer1 = int_4->value;
	/*  2  */
	if(!tuple2->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode RspGetStationItemBits failed: integer2 is not an int: %s", tuple2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) tuple2->items[2];
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode RspGetStationItemBits: truncating 64 bit into into 32 bit int for field integer2");
	}
	integer2 = int_5->value;
	/*  3  */
	if(!tuple2->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode RspGetStationItemBits failed: integer3 is not an int: %s", tuple2->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_6 = (PyRepInteger *) tuple2->items[3];
	if(int_6->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode RspGetStationItemBits: truncating 64 bit into into 32 bit int for field integer3");
	}
	integer3 = int_6->value;
	/*  4  */
	if(!tuple2->items[4]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode RspGetStationItemBits failed: integer4 is not an int: %s", tuple2->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_7 = (PyRepInteger *) tuple2->items[4];
	if(int_7->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode RspGetStationItemBits: truncating 64 bit into into 32 bit int for field integer4");
	}
	integer4 = int_7->value;

	delete packet;
	return(true);
}

RspGetStationItemBits *RspGetStationItemBits::Clone() const {
	RspGetStationItemBits *res = new RspGetStationItemBits;
	res->CloneFrom(this);
	return(res);
}

void RspGetStationItemBits::CloneFrom(const RspGetStationItemBits *from) {
	/*  0  */
	/*  0  */
	integer0 = from->integer0;
	/*  1  */
	integer1 = from->integer1;
	/*  2  */
	integer2 = from->integer2;
	/*  3  */
	integer3 = from->integer3;
	/*  4  */
	integer4 = from->integer4;
	
}


RspGetGuests::RspGetGuests() {
	/*  0  */
}

RspGetGuests::~RspGetGuests() {
	/*  0  */
}

void RspGetGuests::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspGetGuests", pfx);
	/*  0  */
	_log(l_type, "%sguests: Integer list with %d enetires", pfx, guests.size());
	std::vector<uint32>::const_iterator guests_cur, guests_end;
	guests_cur = guests.begin();
	guests_end = guests.end();
	int guests_index;
	for(guests_index = 0; guests_cur != guests_end; guests_cur++, guests_index++) {
		_log(l_type, "%s   [%02d] %d", pfx, guests_index, *guests_cur);
	}
	
}

PyRepTuple *RspGetGuests::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	
	PyRepList *list2 = new PyRepList();
	std::vector<uint32>::iterator guests_cur, guests_end;
	guests_cur = guests.begin();
	guests_end = guests.end();
	for(; guests_cur != guests_end; guests_cur++) {
		list2->items.push_back(
			new PyRepInteger(*guests_cur)
		);
	}
	ss_1 = list2;
	
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

PyRepTuple *RspGetGuests::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	
	PyRepList *list2 = new PyRepList();
	std::vector<uint32>::iterator guests_cur, guests_end;
	guests_cur = guests.begin();
	guests_end = guests.end();
	for(; guests_cur != guests_end; guests_cur++) {
		list2->items.push_back(
			new PyRepInteger(*guests_cur)
		);
	}
	ss_1 = list2;
	
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspGetGuests::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspGetGuests::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetGuests failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspGetGuests failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspGetGuests failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspGetGuests failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	if(!ss_1->decoded->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode RspGetGuests failed: guests is not a list: %s", ss_1->decoded->TypeString());
		delete packet;
		return(false);
	}
	guests.clear();
	PyRepList *list_2 = (PyRepList *) ss_1->decoded;
	PyRepList::iterator guests_cur, guests_end;
	guests_cur = list_2->items.begin();
	guests_end = list_2->items.end();
	int guests_index;
	for(guests_index = 0; guests_cur != guests_end; guests_cur++, guests_index++) {
		if(!(*guests_cur)->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode RspGetGuests failed: Element %d in list guests is not an integer: %s", guests_index, (*guests_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *t = (PyRepInteger *) (*guests_cur);
		if(t->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode RspGetGuests: truncating 64 bit into into 32 bit int for item %d in field guests", guests_index);
		}
		guests.push_back(t->value);
	}


	delete packet;
	return(true);
}

RspGetGuests *RspGetGuests::Clone() const {
	RspGetGuests *res = new RspGetGuests;
	res->CloneFrom(this);
	return(res);
}

void RspGetGuests::CloneFrom(const RspGetGuests *from) {
	/*  0  */
	guests = from->guests;
	
}


CallGetMessageDetails::CallGetMessageDetails() {
	/*  0  */
	channelID = 0;
	/*  1  */
	messageID = 0;
}

CallGetMessageDetails::~CallGetMessageDetails() {
	/*  0  */
	/*  1  */
}

void CallGetMessageDetails::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallGetMessageDetails", pfx);
	/*  0  */
	_log(l_type, "%schannelID=%lu", pfx, channelID);
	/*  1  */
	_log(l_type, "%smessageID=%lu", pfx, messageID);
}

PyRepTuple *CallGetMessageDetails::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepInteger(channelID);
	/*  1  */
	tuple0->items[1] = new PyRepInteger(messageID);
	res = tuple0;
	

	return(res);
}

PyRepTuple *CallGetMessageDetails::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepInteger(channelID);
	/*  1  */
	tuple0->items[1] = new PyRepInteger(messageID);
	res = tuple0;
	

	return(res);
}

bool CallGetMessageDetails::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallGetMessageDetails::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallGetMessageDetails failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode CallGetMessageDetails failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallGetMessageDetails failed: channelID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallGetMessageDetails: truncating 64 bit into into 32 bit int for field channelID");
	}
	channelID = int_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallGetMessageDetails failed: messageID is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallGetMessageDetails: truncating 64 bit into into 32 bit int for field messageID");
	}
	messageID = int_2->value;

	delete packet;
	return(true);
}

CallGetMessageDetails *CallGetMessageDetails::Clone() const {
	CallGetMessageDetails *res = new CallGetMessageDetails;
	res->CloneFrom(this);
	return(res);
}

void CallGetMessageDetails::CloneFrom(const CallGetMessageDetails *from) {
	/*  0  */
	channelID = from->channelID;
	/*  1  */
	messageID = from->messageID;
	
}


CallMarkMessagesRead::CallMarkMessagesRead() {
	/*  0  */
	/*  0  */
	messageID = 0;
}

CallMarkMessagesRead::~CallMarkMessagesRead() {
	/*  0  */
	/*  0  */
}

void CallMarkMessagesRead::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallMarkMessagesRead", pfx);
	/*  0  */
	/*  0  */
	_log(l_type, "%smessageID=%lu", pfx, messageID);
}

PyRepTuple *CallMarkMessagesRead::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRepList *list1 = new PyRepList();
	list1->items.resize(1, NULL);
	/*  0  */
	list1->items[0] = new PyRepInteger(messageID);
	tuple0->items[0] = list1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *CallMarkMessagesRead::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRepList *list1 = new PyRepList();
	list1->items.resize(1, NULL);
	/*  0  */
	list1->items[0] = new PyRepInteger(messageID);
	tuple0->items[0] = list1;
	
	res = tuple0;
	

	return(res);
}

bool CallMarkMessagesRead::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallMarkMessagesRead::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallMarkMessagesRead failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode CallMarkMessagesRead failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode CallMarkMessagesRead failed: list1 is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list1 = (PyRepList *) tuple0->items[0];
	if(list1->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode CallMarkMessagesRead failed: list1 is the wrong size: expected 1, but got %d", list1->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!list1->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallMarkMessagesRead failed: messageID is not an int: %s", list1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) list1->items[0];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallMarkMessagesRead: truncating 64 bit into into 32 bit int for field messageID");
	}
	messageID = int_2->value;

	delete packet;
	return(true);
}

CallMarkMessagesRead *CallMarkMessagesRead::Clone() const {
	CallMarkMessagesRead *res = new CallMarkMessagesRead;
	res->CloneFrom(this);
	return(res);
}

void CallMarkMessagesRead::CloneFrom(const CallMarkMessagesRead *from) {
	/*  0  */
	/*  0  */
	messageID = from->messageID;
	
}


SessionChangeNotification::SessionChangeNotification() {
	/*  0  */
	/*  0  */
	clueless = 0;
	/*  1  */
	/*  1  */
	/*  this is actually optional...  */
}

SessionChangeNotification::~SessionChangeNotification() {
	/*  0  */
	/*  0  */
	/*  1  */
	/*  1  */
	/*  this is actually optional...  */
}

void SessionChangeNotification::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sSessionChangeNotification", pfx);
	/*  0  */
	/*  0  */
	_log(l_type, "%sclueless=%lu", pfx, clueless);
	/*  1  */
	_log(l_type, "%schanges: ", pfx);
	std::string changes_n(pfx);
	changes_n += "    ";
	changes.Dump(l_type, changes_n.c_str());
	/*  1  */
	/*  this is actually optional...  */
	_log(l_type, "%snodesOfInterest: Integer list with %d enetires", pfx, nodesOfInterest.size());
	std::vector<uint32>::const_iterator nodesOfInterest_cur, nodesOfInterest_end;
	nodesOfInterest_cur = nodesOfInterest.begin();
	nodesOfInterest_end = nodesOfInterest.end();
	int nodesOfInterest_index;
	for(nodesOfInterest_index = 0; nodesOfInterest_cur != nodesOfInterest_end; nodesOfInterest_cur++, nodesOfInterest_index++) {
		_log(l_type, "%s   [%02d] %d", pfx, nodesOfInterest_index, *nodesOfInterest_cur);
	}
	
}

PyRepTuple *SessionChangeNotification::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	/*  0  */
	tuple1->items[0] = new PyRepInteger(clueless);
	/*  1  */
	tuple1->items[1] = changes.Clone();
	tuple0->items[0] = tuple1;
	
	/*  1  */
	/*  this is actually optional...  */
	
	PyRepList *list2 = new PyRepList();
	std::vector<uint32>::iterator nodesOfInterest_cur, nodesOfInterest_end;
	nodesOfInterest_cur = nodesOfInterest.begin();
	nodesOfInterest_end = nodesOfInterest.end();
	for(; nodesOfInterest_cur != nodesOfInterest_end; nodesOfInterest_cur++) {
		list2->items.push_back(
			new PyRepInteger(*nodesOfInterest_cur)
		);
	}
	tuple0->items[1] = list2;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *SessionChangeNotification::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	/*  0  */
	tuple1->items[0] = new PyRepInteger(clueless);
	/*  1  */
	
	PyRepDict *dict2 = new PyRepDict();
	dict2->items = changes.items;
	changes.items.clear();
	tuple1->items[1] = dict2;
	tuple0->items[0] = tuple1;
	
	/*  1  */
	/*  this is actually optional...  */
	
	PyRepList *list3 = new PyRepList();
	std::vector<uint32>::iterator nodesOfInterest_cur, nodesOfInterest_end;
	nodesOfInterest_cur = nodesOfInterest.begin();
	nodesOfInterest_end = nodesOfInterest.end();
	for(; nodesOfInterest_cur != nodesOfInterest_end; nodesOfInterest_cur++) {
		list3->items.push_back(
			new PyRepInteger(*nodesOfInterest_cur)
		);
	}
	tuple0->items[1] = list3;
	
	res = tuple0;
	

	return(res);
}

bool SessionChangeNotification::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool SessionChangeNotification::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode SessionChangeNotification failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode SessionChangeNotification failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode SessionChangeNotification failed: tuple1 is the wrong type: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple1 = (PyRepTuple *) tuple0->items[0];
	if(tuple1->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode SessionChangeNotification failed: tuple1 is the wrong size: expected 2, but got %d", tuple1->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple1->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode SessionChangeNotification failed: clueless is not an int: %s", tuple1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple1->items[0];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode SessionChangeNotification: truncating 64 bit into into 32 bit int for field clueless");
	}
	clueless = int_2->value;
	/*  1  */
	if(!tuple1->items[1]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode SessionChangeNotification failed: changes is not a dict: %s", tuple1->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepDict *list_changes = (PyRepDict *) tuple1->items[1];	changes.items = list_changes->items;
	list_changes->items.clear();
	
	/*  1  */
	/*  this is actually optional...  */
	if(!tuple0->items[1]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode SessionChangeNotification failed: nodesOfInterest is not a list: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	nodesOfInterest.clear();
	PyRepList *list_3 = (PyRepList *) tuple0->items[1];
	PyRepList::iterator nodesOfInterest_cur, nodesOfInterest_end;
	nodesOfInterest_cur = list_3->items.begin();
	nodesOfInterest_end = list_3->items.end();
	int nodesOfInterest_index;
	for(nodesOfInterest_index = 0; nodesOfInterest_cur != nodesOfInterest_end; nodesOfInterest_cur++, nodesOfInterest_index++) {
		if(!(*nodesOfInterest_cur)->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode SessionChangeNotification failed: Element %d in list nodesOfInterest is not an integer: %s", nodesOfInterest_index, (*nodesOfInterest_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *t = (PyRepInteger *) (*nodesOfInterest_cur);
		if(t->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode SessionChangeNotification: truncating 64 bit into into 32 bit int for item %d in field nodesOfInterest", nodesOfInterest_index);
		}
		nodesOfInterest.push_back(t->value);
	}


	delete packet;
	return(true);
}

SessionChangeNotification *SessionChangeNotification::Clone() const {
	SessionChangeNotification *res = new SessionChangeNotification;
	res->CloneFrom(this);
	return(res);
}

void SessionChangeNotification::CloneFrom(const SessionChangeNotification *from) {
	/*  0  */
	/*  0  */
	clueless = from->clueless;
	/*  1  */
	changes.CloneFrom(&from->changes);
	/*  1  */
	/*  this is actually optional...  */
	nodesOfInterest = from->nodesOfInterest;
	
}


ServerNotification::ServerNotification() {
	/*  0  */
	/*  0  */
	unknown = 0;
	/*  1  */
	/*  0  */
	boundID = "";
	timestamp = 0;
	/*  1  */
	method = "";
	/*  2  */
	arguments = NULL;
	/*  3  */
	/*  1  */
}

ServerNotification::~ServerNotification() {
	/*  0  */
	/*  0  */
	/*  1  */
	/*  0  */
	/*  1  */
	/*  2  */
	delete arguments;
	/*  3  */
	std::map<std::string, PyRep *>::iterator keywords_cur, keywords_end;
	//free any existing elements first
	keywords_cur = keywords.begin();
	keywords_end = keywords.end();
	for(; keywords_cur != keywords_end; keywords_cur++) {
		delete keywords_cur->second;
	}
	
	/*  1  */
}

void ServerNotification::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sServerNotification", pfx);
	/*  0  */
	/*  0  */
	_log(l_type, "%sunknown=%lu", pfx, unknown);
	/*  1  */
	/*  0  */
	_log(l_type, "%sboundID='%s'", pfx, boundID.c_str());
	_log(l_type, "%stimestamp=" I64u, pfx, timestamp);
	/*  1  */
	_log(l_type, "%smethod='%s'", pfx, method.c_str());
	/*  2  */
	_log(l_type, "%sarguments:", pfx);
	std::string arguments_n(pfx);
	arguments_n += "    ";
	if(arguments == NULL) {
		_log(l_type, "%sERROR: NULL TUPLE!", arguments_n.c_str());
	} else {
		arguments->Dump(l_type, arguments_n.c_str());
	}
	/*  3  */
	_log(l_type, "%skeywords: Dictionaty with %d enetires", pfx, keywords.size());
	std::map<std::string, PyRep *>::const_iterator keywords_cur, keywords_end;
	keywords_cur = keywords.begin();
	keywords_end = keywords.end();
	for(; keywords_cur != keywords_end; keywords_cur++) {
		_log(l_type, "%s Key: %s", pfx, keywords_cur->first.c_str());
		std::string n(pfx);
		n += "      ";
		keywords_cur->second->Dump(stdout, n.c_str());
	}
	
	/*  1  */
}

PyRepTuple *ServerNotification::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	/*  0  */
	tuple1->items[0] = new PyRepInteger(unknown);
	/*  1  */
	PyRep *ss_2;
	PyRepTuple *tuple3 = new PyRepTuple(4);
	/*  0  */
	PyRepList *list4 = new PyRepList();
	list4->items.resize(1, NULL);
	PyRepTuple *tuple5 = new PyRepTuple(2);
	tuple5->items[0] = new PyRepString(boundID);
	tuple5->items[1] = new PyRepInteger(timestamp);
	list4->items[0] = tuple5;
	
	tuple3->items[0] = list4;
	
	/*  1  */
	tuple3->items[1] = new PyRepString(method);
	/*  2  */
	if(arguments == NULL) {
		_log(NET__PACKET_ERROR, "Encode ServerNotification: arguments is NULL! hacking in an empty tuple.");
		arguments = new PyRepTuple(0);
	}
	tuple3->items[2] = arguments->Clone();
	/*  3  */
	
	PyRepDict *dict6 = new PyRepDict();
	std::map<std::string, PyRep *>::iterator keywords_cur, keywords_end;
	keywords_cur = keywords.begin();
	keywords_end = keywords.end();
	for(; keywords_cur != keywords_end; keywords_cur++) {
		dict6->items[
			new PyRepString(keywords_cur->first)
		] = keywords_cur->second->Clone();
	}
	tuple3->items[3] = dict6;
	
	ss_2 = tuple3;
	
	tuple1->items[1] = new PyRepSubStream(ss_2);
	tuple0->items[0] = tuple1;
	
	/*  1  */
	tuple0->items[1] = new PyRepNone();
	res = tuple0;
	

	return(res);
}

PyRepTuple *ServerNotification::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	/*  0  */
	tuple1->items[0] = new PyRepInteger(unknown);
	/*  1  */
	PyRep *ss_2;
	PyRepTuple *tuple3 = new PyRepTuple(4);
	/*  0  */
	PyRepList *list4 = new PyRepList();
	list4->items.resize(1, NULL);
	PyRepTuple *tuple5 = new PyRepTuple(2);
	tuple5->items[0] = new PyRepString(boundID);
	tuple5->items[1] = new PyRepInteger(timestamp);
	list4->items[0] = tuple5;
	
	tuple3->items[0] = list4;
	
	/*  1  */
	tuple3->items[1] = new PyRepString(method);
	/*  2  */
	if(arguments == NULL) {
		_log(NET__PACKET_ERROR, "Encode ServerNotification: arguments is NULL! hacking in an empty tuple.");
		arguments = new PyRepTuple(0);
	}
	
	PyRepTuple *list6 = new PyRepTuple(0);
	list6->items = arguments->items;
	arguments->items.clear();
	tuple3->items[2] = list6;
	/*  3  */
	
	PyRepDict *dict7 = new PyRepDict();
	std::map<std::string, PyRep *>::iterator keywords_cur, keywords_end;
	keywords_cur = keywords.begin();
	keywords_end = keywords.end();
	for(; keywords_cur != keywords_end; keywords_cur++) {
		dict7->items[
			new PyRepString(keywords_cur->first)
		] = keywords_cur->second;
	}
	keywords.clear();
	tuple3->items[3] = dict7;
	
	ss_2 = tuple3;
	
	tuple1->items[1] = new PyRepSubStream(ss_2);
	tuple0->items[0] = tuple1;
	
	/*  1  */
	tuple0->items[1] = new PyRepNone();
	res = tuple0;
	

	return(res);
}

bool ServerNotification::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool ServerNotification::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode ServerNotification failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode ServerNotification failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode ServerNotification failed: tuple1 is the wrong type: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple1 = (PyRepTuple *) tuple0->items[0];
	if(tuple1->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode ServerNotification failed: tuple1 is the wrong size: expected 2, but got %d", tuple1->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple1->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode ServerNotification failed: unknown is not an int: %s", tuple1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple1->items[0];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode ServerNotification: truncating 64 bit into into 32 bit int for field unknown");
	}
	unknown = int_2->value;
	/*  1  */
	if(!tuple1->items[1]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode ServerNotification failed: ss_3 is not a substream: %s", tuple1->items[1]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_3 = (PyRepSubStream *) tuple1->items[1];
	//make sure its decoded
	ss_3->DecodeData();
	if(ss_3->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode ServerNotification failed: Unable to decode ss_3");
		delete packet;
		return(false);
	}
	
	if(!ss_3->decoded->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode ServerNotification failed: tuple4 is the wrong type: %s", ss_3->decoded->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple4 = (PyRepTuple *) ss_3->decoded;
	if(tuple4->items.size() != 4) {
		_log(NET__PACKET_ERROR, "Decode ServerNotification failed: tuple4 is the wrong size: expected 4, but got %d", tuple4->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple4->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode ServerNotification failed: list5 is not a list: %s", tuple4->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list5 = (PyRepList *) tuple4->items[0];
	if(list5->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode ServerNotification failed: list5 is the wrong size: expected 1, but got %d", list5->items.size());
		delete packet;
		return(false);
	}

	if(!list5->items[0]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode ServerNotification failed: tuple6 is the wrong type: %s", list5->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple6 = (PyRepTuple *) list5->items[0];
	if(tuple6->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode ServerNotification failed: tuple6 is the wrong size: expected 2, but got %d", tuple6->items.size());
		delete packet;
		return(false);
	}

	if(!tuple6->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ServerNotification failed: boundID is not a string: %s", tuple6->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_7 = (PyRepString *) tuple6->items[0];
	boundID = string_7->value;
	if(!tuple6->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode ServerNotification failed: timestamp is not an int: %s", tuple6->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_8 = (PyRepInteger *) tuple6->items[1];
	timestamp = int64_8->value;
	/*  1  */
	if(!tuple4->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ServerNotification failed: method is not a string: %s", tuple4->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_9 = (PyRepString *) tuple4->items[1];
	method = string_9->value;
	/*  2  */
	if(!tuple4->items[2]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode ServerNotification failed: arguments is not a tuple: %s", tuple4->items[2]->TypeString());
		delete packet;
		return(false);
	}
	arguments = (PyRepTuple *) tuple4->items[2];
	tuple4->items[2] = NULL;
	
	/*  3  */
	if(!tuple4->items[3]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode ServerNotification failed: keywords is not a dict: %s", tuple4->items[3]->TypeString());
		delete packet;
		return(false);
	}
	keywords.clear();
	PyRepDict *dict_10 = (PyRepDict *) tuple4->items[3];
	PyRepDict::iterator keywords_cur, keywords_end;
	keywords_cur = dict_10->items.begin();
	keywords_end = dict_10->items.end();
	int keywords_index;
	for(keywords_index = 0; keywords_cur != keywords_end; keywords_cur++, keywords_index++) {
		if(!keywords_cur->first->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode ServerNotification failed: Key %d in dict keywords is not a string: %s", keywords_index, keywords_cur->first->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *k = (PyRepString *) keywords_cur->first;
		keywords[k->value] = keywords_cur->second->Clone();
	}
	
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::None)) {
		_log(NET__PACKET_ERROR, "Decode ServerNotification failed: expecting a None but got a %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

ServerNotification *ServerNotification::Clone() const {
	ServerNotification *res = new ServerNotification;
	res->CloneFrom(this);
	return(res);
}

void ServerNotification::CloneFrom(const ServerNotification *from) {
	/*  0  */
	/*  0  */
	unknown = from->unknown;
	/*  1  */
	/*  0  */
	boundID = from->boundID;
	timestamp = from->timestamp;
	/*  1  */
	method = from->method;
	/*  2  */
	delete arguments;
	if(from->arguments == NULL) {
		arguments = NULL;
	} else {
		arguments = from->arguments->TypedClone();
	}
	/*  3  */
	std::map<std::string, PyRep *>::const_iterator keywords_cur, keywords_end;
	//free any existing elements first
	keywords_cur = keywords.begin();
	keywords_end = keywords.end();
	for(; keywords_cur != keywords_end; keywords_cur++) {
		delete keywords_cur->second;
	}
	keywords.clear();
	//now we can copy in the new ones...
	keywords_cur = from->keywords.begin();
	keywords_end = from->keywords.end();
	for(; keywords_cur != keywords_end; keywords_cur++) {
		keywords[keywords_cur->first] = keywords_cur->second->Clone();
	}
	
	/*  1  */
	
}


Call_SingleIntegerArg::Call_SingleIntegerArg() {
	arg = 0;
}

Call_SingleIntegerArg::~Call_SingleIntegerArg() {
}

void Call_SingleIntegerArg::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_SingleIntegerArg", pfx);
	_log(l_type, "%sarg=%lu", pfx, arg);
}

PyRepTuple *Call_SingleIntegerArg::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	tuple0->items[0] = new PyRepInteger(arg);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_SingleIntegerArg::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	tuple0->items[0] = new PyRepInteger(arg);
	res = tuple0;
	

	return(res);
}

bool Call_SingleIntegerArg::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_SingleIntegerArg::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_SingleIntegerArg failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode Call_SingleIntegerArg failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_SingleIntegerArg failed: arg is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_SingleIntegerArg: truncating 64 bit into into 32 bit int for field arg");
	}
	arg = int_1->value;

	delete packet;
	return(true);
}

Call_SingleIntegerArg *Call_SingleIntegerArg::Clone() const {
	Call_SingleIntegerArg *res = new Call_SingleIntegerArg;
	res->CloneFrom(this);
	return(res);
}

void Call_SingleIntegerArg::CloneFrom(const Call_SingleIntegerArg *from) {
	arg = from->arg;
	
}


Call_SingleRealArg::Call_SingleRealArg() {
	arg = 0.0;
}

Call_SingleRealArg::~Call_SingleRealArg() {
}

void Call_SingleRealArg::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_SingleRealArg", pfx);
	_log(l_type, "%sarg=%.13f", pfx, arg);
}

PyRepTuple *Call_SingleRealArg::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	tuple0->items[0] = new PyRepReal(arg);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_SingleRealArg::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	tuple0->items[0] = new PyRepReal(arg);
	res = tuple0;
	

	return(res);
}

bool Call_SingleRealArg::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_SingleRealArg::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_SingleRealArg failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode Call_SingleRealArg failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode Call_SingleRealArg failed: arg is not a real: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_1 = (PyRepReal *) tuple0->items[0];
	arg = real_1->value;

	delete packet;
	return(true);
}

Call_SingleRealArg *Call_SingleRealArg::Clone() const {
	Call_SingleRealArg *res = new Call_SingleRealArg;
	res->CloneFrom(this);
	return(res);
}

void Call_SingleRealArg::CloneFrom(const Call_SingleRealArg *from) {
	arg = from->arg;
	
}


Call_TwoIntegerArgs::Call_TwoIntegerArgs() {
	arg1 = 0;
	arg2 = 0;
}

Call_TwoIntegerArgs::~Call_TwoIntegerArgs() {
}

void Call_TwoIntegerArgs::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_TwoIntegerArgs", pfx);
	_log(l_type, "%sarg1=%lu", pfx, arg1);
	_log(l_type, "%sarg2=%lu", pfx, arg2);
}

PyRepTuple *Call_TwoIntegerArgs::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(arg1);
	tuple0->items[1] = new PyRepInteger(arg2);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_TwoIntegerArgs::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(arg1);
	tuple0->items[1] = new PyRepInteger(arg2);
	res = tuple0;
	

	return(res);
}

bool Call_TwoIntegerArgs::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_TwoIntegerArgs::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_TwoIntegerArgs failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Call_TwoIntegerArgs failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_TwoIntegerArgs failed: arg1 is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_TwoIntegerArgs: truncating 64 bit into into 32 bit int for field arg1");
	}
	arg1 = int_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_TwoIntegerArgs failed: arg2 is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_TwoIntegerArgs: truncating 64 bit into into 32 bit int for field arg2");
	}
	arg2 = int_2->value;

	delete packet;
	return(true);
}

Call_TwoIntegerArgs *Call_TwoIntegerArgs::Clone() const {
	Call_TwoIntegerArgs *res = new Call_TwoIntegerArgs;
	res->CloneFrom(this);
	return(res);
}

void Call_TwoIntegerArgs::CloneFrom(const Call_TwoIntegerArgs *from) {
	arg1 = from->arg1;
	arg2 = from->arg2;
	
}


Call_PointArg::Call_PointArg() {
	x = 0.0;
	y = 0.0;
	z = 0.0;
}

Call_PointArg::~Call_PointArg() {
}

void Call_PointArg::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_PointArg", pfx);
	_log(l_type, "%sx=%.13f", pfx, x);
	_log(l_type, "%sy=%.13f", pfx, y);
	_log(l_type, "%sz=%.13f", pfx, z);
}

PyRepTuple *Call_PointArg::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	tuple0->items[0] = new PyRepReal(x);
	tuple0->items[1] = new PyRepReal(y);
	tuple0->items[2] = new PyRepReal(z);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_PointArg::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	tuple0->items[0] = new PyRepReal(x);
	tuple0->items[1] = new PyRepReal(y);
	tuple0->items[2] = new PyRepReal(z);
	res = tuple0;
	

	return(res);
}

bool Call_PointArg::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_PointArg::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_PointArg failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode Call_PointArg failed: tuple0 is the wrong size: expected 3, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode Call_PointArg failed: x is not a real: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_1 = (PyRepReal *) tuple0->items[0];
	x = real_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode Call_PointArg failed: y is not a real: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_2 = (PyRepReal *) tuple0->items[1];
	y = real_2->value;
	if(!tuple0->items[2]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode Call_PointArg failed: z is not a real: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_3 = (PyRepReal *) tuple0->items[2];
	z = real_3->value;

	delete packet;
	return(true);
}

Call_PointArg *Call_PointArg::Clone() const {
	Call_PointArg *res = new Call_PointArg;
	res->CloneFrom(this);
	return(res);
}

void Call_PointArg::CloneFrom(const Call_PointArg *from) {
	x = from->x;
	y = from->y;
	z = from->z;
	
}


Call_SingleBoolArg::Call_SingleBoolArg() {
	arg = false;
}

Call_SingleBoolArg::~Call_SingleBoolArg() {
}

void Call_SingleBoolArg::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_SingleBoolArg", pfx);
	_log(l_type, "%sarg=%s", pfx, arg?"true":"false");
}

PyRepTuple *Call_SingleBoolArg::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	tuple0->items[0] = new PyRepBoolean(arg);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_SingleBoolArg::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	tuple0->items[0] = new PyRepBoolean(arg);
	res = tuple0;
	

	return(res);
}

bool Call_SingleBoolArg::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_SingleBoolArg::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_SingleBoolArg failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode Call_SingleBoolArg failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Boolean)) {
		_log(NET__PACKET_ERROR, "Decode Call_SingleBoolArg failed: arg is not a boolean: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepBoolean *bool_1 = (PyRepBoolean *) tuple0->items[0];
	arg = bool_1->value;

	delete packet;
	return(true);
}

Call_SingleBoolArg *Call_SingleBoolArg::Clone() const {
	Call_SingleBoolArg *res = new Call_SingleBoolArg;
	res->CloneFrom(this);
	return(res);
}

void Call_SingleBoolArg::CloneFrom(const Call_SingleBoolArg *from) {
	arg = from->arg;
	
}


Call_SingleStringArg::Call_SingleStringArg() {
	arg = "";
}

Call_SingleStringArg::~Call_SingleStringArg() {
}

void Call_SingleStringArg::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_SingleStringArg", pfx);
	_log(l_type, "%sarg='%s'", pfx, arg.c_str());
}

PyRepTuple *Call_SingleStringArg::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	tuple0->items[0] = new PyRepString(arg);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_SingleStringArg::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	tuple0->items[0] = new PyRepString(arg);
	res = tuple0;
	

	return(res);
}

bool Call_SingleStringArg::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_SingleStringArg::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_SingleStringArg failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode Call_SingleStringArg failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Call_SingleStringArg failed: arg is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	arg = string_1->value;

	delete packet;
	return(true);
}

Call_SingleStringArg *Call_SingleStringArg::Clone() const {
	Call_SingleStringArg *res = new Call_SingleStringArg;
	res->CloneFrom(this);
	return(res);
}

void Call_SingleStringArg::CloneFrom(const Call_SingleStringArg *from) {
	arg = from->arg;
	
}


Call_SingleArg::Call_SingleArg() {
	arg = NULL;
}

Call_SingleArg::~Call_SingleArg() {
	delete arg;
}

void Call_SingleArg::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_SingleArg", pfx);
	_log(l_type, "%sarg:", pfx);
	std::string arg_n(pfx);
	arg_n += "    ";
	if(arg == NULL) {
		_log(l_type, "%sERROR: NULL REP!", arg_n.c_str());
	} else {
		arg->Dump(l_type, arg_n.c_str());
	}
}

PyRepTuple *Call_SingleArg::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	if(arg == NULL) {
		_log(NET__PACKET_ERROR, "Encode Call_SingleArg: arg is NULL! hacking in a PyRepNone");
		arg = new PyRepNone();
	}
	tuple0->items[0] = arg->Clone();
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_SingleArg::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	if(arg == NULL) {
		_log(NET__PACKET_ERROR, "Encode Call_SingleArg: arg is NULL! hacking in a PyRepNone");
		arg = new PyRepNone();
	}
	tuple0->items[0] = arg;
	arg = NULL;
	res = tuple0;
	

	return(res);
}

bool Call_SingleArg::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_SingleArg::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_SingleArg failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode Call_SingleArg failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	delete arg;
	arg = tuple0->items[0];
	tuple0->items[0] = NULL;
	

	delete packet;
	return(true);
}

Call_SingleArg *Call_SingleArg::Clone() const {
	Call_SingleArg *res = new Call_SingleArg;
	res->CloneFrom(this);
	return(res);
}

void Call_SingleArg::CloneFrom(const Call_SingleArg *from) {
	delete arg;
	if(from->arg == NULL) {
		arg = NULL;
	} else {
		arg = from->arg->Clone();
	}
	
}


Call_SingleIntList::Call_SingleIntList() {
}

Call_SingleIntList::~Call_SingleIntList() {
}

void Call_SingleIntList::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_SingleIntList", pfx);
	_log(l_type, "%sints: Integer list with %d enetires", pfx, ints.size());
	std::vector<uint32>::const_iterator ints_cur, ints_end;
	ints_cur = ints.begin();
	ints_end = ints.end();
	int ints_index;
	for(ints_index = 0; ints_cur != ints_end; ints_cur++, ints_index++) {
		_log(l_type, "%s   [%02d] %d", pfx, ints_index, *ints_cur);
	}
	
}

PyRepTuple *Call_SingleIntList::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator ints_cur, ints_end;
	ints_cur = ints.begin();
	ints_end = ints.end();
	for(; ints_cur != ints_end; ints_cur++) {
		list1->items.push_back(
			new PyRepInteger(*ints_cur)
		);
	}
	tuple0->items[0] = list1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_SingleIntList::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator ints_cur, ints_end;
	ints_cur = ints.begin();
	ints_end = ints.end();
	for(; ints_cur != ints_end; ints_cur++) {
		list1->items.push_back(
			new PyRepInteger(*ints_cur)
		);
	}
	tuple0->items[0] = list1;
	
	res = tuple0;
	

	return(res);
}

bool Call_SingleIntList::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_SingleIntList::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_SingleIntList failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode Call_SingleIntList failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Call_SingleIntList failed: ints is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	ints.clear();
	PyRepList *list_1 = (PyRepList *) tuple0->items[0];
	PyRepList::iterator ints_cur, ints_end;
	ints_cur = list_1->items.begin();
	ints_end = list_1->items.end();
	int ints_index;
	for(ints_index = 0; ints_cur != ints_end; ints_cur++, ints_index++) {
		if(!(*ints_cur)->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode Call_SingleIntList failed: Element %d in list ints is not an integer: %s", ints_index, (*ints_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *t = (PyRepInteger *) (*ints_cur);
		if(t->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode Call_SingleIntList: truncating 64 bit into into 32 bit int for item %d in field ints", ints_index);
		}
		ints.push_back(t->value);
	}


	delete packet;
	return(true);
}

Call_SingleIntList *Call_SingleIntList::Clone() const {
	Call_SingleIntList *res = new Call_SingleIntList;
	res->CloneFrom(this);
	return(res);
}

void Call_SingleIntList::CloneFrom(const Call_SingleIntList *from) {
	ints = from->ints;
	
}


CallWarpToStuff::CallWarpToStuff() {
	/*  really this call uses keywords, and I think the item ID just happens to end up in the args as a fluke.  */
	itemStr = "item";
	item = 0;
}

CallWarpToStuff::~CallWarpToStuff() {
	/*  really this call uses keywords, and I think the item ID just happens to end up in the args as a fluke.  */
}

void CallWarpToStuff::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallWarpToStuff", pfx);
	/*  really this call uses keywords, and I think the item ID just happens to end up in the args as a fluke.  */
	_log(l_type, "%sitemStr='%s'", pfx, itemStr.c_str());
	_log(l_type, "%sitem=%lu", pfx, item);
}

PyRepTuple *CallWarpToStuff::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  really this call uses keywords, and I think the item ID just happens to end up in the args as a fluke.  */
	tuple0->items[0] = new PyRepString(itemStr);
	tuple0->items[1] = new PyRepInteger(item);
	res = tuple0;
	

	return(res);
}

PyRepTuple *CallWarpToStuff::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  really this call uses keywords, and I think the item ID just happens to end up in the args as a fluke.  */
	tuple0->items[0] = new PyRepString(itemStr);
	tuple0->items[1] = new PyRepInteger(item);
	res = tuple0;
	

	return(res);
}

bool CallWarpToStuff::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallWarpToStuff::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallWarpToStuff failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode CallWarpToStuff failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  really this call uses keywords, and I think the item ID just happens to end up in the args as a fluke.  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode CallWarpToStuff failed: itemStr is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	itemStr = string_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallWarpToStuff failed: item is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallWarpToStuff: truncating 64 bit into into 32 bit int for field item");
	}
	item = int_2->value;

	delete packet;
	return(true);
}

CallWarpToStuff *CallWarpToStuff::Clone() const {
	CallWarpToStuff *res = new CallWarpToStuff;
	res->CloneFrom(this);
	return(res);
}

void CallWarpToStuff::CloneFrom(const CallWarpToStuff *from) {
	/*  really this call uses keywords, and I think the item ID just happens to end up in the args as a fluke.  */
	itemStr = from->itemStr;
	item = from->item;
	
}


Notify_OnRemoteMessage::Notify_OnRemoteMessage() {
	msgType = "";
}

Notify_OnRemoteMessage::~Notify_OnRemoteMessage() {
	std::map<std::string, PyRep *>::iterator args_cur, args_end;
	//free any existing elements first
	args_cur = args.begin();
	args_end = args.end();
	for(; args_cur != args_end; args_cur++) {
		delete args_cur->second;
	}
	
}

void Notify_OnRemoteMessage::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotify_OnRemoteMessage", pfx);
	_log(l_type, "%smsgType='%s'", pfx, msgType.c_str());
	_log(l_type, "%sargs: Dictionaty with %d enetires", pfx, args.size());
	std::map<std::string, PyRep *>::const_iterator args_cur, args_end;
	args_cur = args.begin();
	args_end = args.end();
	for(; args_cur != args_end; args_cur++) {
		_log(l_type, "%s Key: %s", pfx, args_cur->first.c_str());
		std::string n(pfx);
		n += "      ";
		args_cur->second->Dump(stdout, n.c_str());
	}
	
}

PyRepTuple *Notify_OnRemoteMessage::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepString(msgType);
	
	PyRepDict *dict1 = new PyRepDict();
	std::map<std::string, PyRep *>::iterator args_cur, args_end;
	args_cur = args.begin();
	args_end = args.end();
	for(; args_cur != args_end; args_cur++) {
		dict1->items[
			new PyRepString(args_cur->first)
		] = args_cur->second->Clone();
	}
	tuple0->items[1] = dict1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *Notify_OnRemoteMessage::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepString(msgType);
	
	PyRepDict *dict1 = new PyRepDict();
	std::map<std::string, PyRep *>::iterator args_cur, args_end;
	args_cur = args.begin();
	args_end = args.end();
	for(; args_cur != args_end; args_cur++) {
		dict1->items[
			new PyRepString(args_cur->first)
		] = args_cur->second;
	}
	args.clear();
	tuple0->items[1] = dict1;
	
	res = tuple0;
	

	return(res);
}

bool Notify_OnRemoteMessage::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Notify_OnRemoteMessage::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnRemoteMessage failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnRemoteMessage failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnRemoteMessage failed: msgType is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	msgType = string_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnRemoteMessage failed: args is not a dict: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	args.clear();
	PyRepDict *dict_2 = (PyRepDict *) tuple0->items[1];
	PyRepDict::iterator args_cur, args_end;
	args_cur = dict_2->items.begin();
	args_end = dict_2->items.end();
	int args_index;
	for(args_index = 0; args_cur != args_end; args_cur++, args_index++) {
		if(!args_cur->first->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode Notify_OnRemoteMessage failed: Key %d in dict args is not a string: %s", args_index, args_cur->first->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *k = (PyRepString *) args_cur->first;
		args[k->value] = args_cur->second->Clone();
	}
	

	delete packet;
	return(true);
}

Notify_OnRemoteMessage *Notify_OnRemoteMessage::Clone() const {
	Notify_OnRemoteMessage *res = new Notify_OnRemoteMessage;
	res->CloneFrom(this);
	return(res);
}

void Notify_OnRemoteMessage::CloneFrom(const Notify_OnRemoteMessage *from) {
	msgType = from->msgType;
	std::map<std::string, PyRep *>::const_iterator args_cur, args_end;
	//free any existing elements first
	args_cur = args.begin();
	args_end = args.end();
	for(; args_cur != args_end; args_cur++) {
		delete args_cur->second;
	}
	args.clear();
	//now we can copy in the new ones...
	args_cur = from->args.begin();
	args_end = from->args.end();
	for(; args_cur != args_end; args_cur++) {
		args[args_cur->first] = args_cur->second->Clone();
	}
	
	
}



