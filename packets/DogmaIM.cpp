/*  EVEmu: EVE Online Server Emulator
  
  **************************************************************
  This file is automatically generated, DO NOT EDIT IT DIRECTLY.
  **************************************************************
  
  (If you need to customize an object, you must copy that object
  into another source file, and give up the ability to generate it)
  
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; version 2 of the License.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY except by those people which sell it, which
  are required to give you total support for your newly bought product;
  without even the implied warranty of MERCHANTABILITY or FITNESS FOR
  A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/


#include <string>
#include "../packets/DogmaIM.h"
#include "../common/PyRep.h"




Call_Dogma_Activate::Call_Dogma_Activate() {
	itemID = 0;
	effectName = "";
	/*  optional:  */
	target = 0;
	repeat = 0;
}

Call_Dogma_Activate::~Call_Dogma_Activate() {
	/*  optional:  */
}

void Call_Dogma_Activate::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_Dogma_Activate", pfx);
	_log(l_type, "%sitemID=%lu", pfx, itemID);
	_log(l_type, "%seffectName='%s'", pfx, effectName.c_str());
	/*  optional:  */
	_log(l_type, "%starget=%lu", pfx, target);
	_log(l_type, "%srepeat=%lu", pfx, repeat);
}

PyRepTuple *Call_Dogma_Activate::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(4);
	tuple0->items[0] = new PyRepInteger(itemID);
	tuple0->items[1] = new PyRepString(effectName);
	/*  optional:  */
	if(target == 0) {
		tuple0->items[2] = new PyRepNone();
	} else {
		tuple0->items[2] = new PyRepInteger(target);
	}
	tuple0->items[3] = new PyRepInteger(repeat);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_Dogma_Activate::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(4);
	tuple0->items[0] = new PyRepInteger(itemID);
	tuple0->items[1] = new PyRepString(effectName);
	/*  optional:  */
	if(target == 0) {
		tuple0->items[2] = new PyRepNone();
	} else {
		tuple0->items[2] = new PyRepInteger(target);
	}
	tuple0->items[3] = new PyRepInteger(repeat);
	res = tuple0;
	

	return(res);
}

bool Call_Dogma_Activate::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_Dogma_Activate::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_Dogma_Activate failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 4) {
		_log(NET__PACKET_ERROR, "Decode Call_Dogma_Activate failed: tuple0 is the wrong size: expected 4, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_Dogma_Activate failed: itemID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_Dogma_Activate: truncating 64 bit into into 32 bit int for field itemID");
	}
	itemID = int_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Call_Dogma_Activate failed: effectName is not a string: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple0->items[1];
	effectName = string_2->value;
	/*  optional:  */
	if(tuple0->items[2]->CheckType(PyRep::None)) {
		target = 0;
	} else {
	if(!tuple0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_Dogma_Activate failed: target is not an int: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple0->items[2];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_Dogma_Activate: truncating 64 bit into into 32 bit int for field target");
	}
	target = int_3->value;
	}
	if(!tuple0->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_Dogma_Activate failed: repeat is not an int: %s", tuple0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple0->items[3];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_Dogma_Activate: truncating 64 bit into into 32 bit int for field repeat");
	}
	repeat = int_4->value;

	delete packet;
	return(true);
}

Call_Dogma_Activate *Call_Dogma_Activate::Clone() const {
	Call_Dogma_Activate *res = new Call_Dogma_Activate;
	res->CloneFrom(this);
	return(res);
}

void Call_Dogma_Activate::CloneFrom(const Call_Dogma_Activate *from) {
	itemID = from->itemID;
	effectName = from->effectName;
	/*  optional:  */
	target = from->target;
	repeat = from->repeat;
	
}


Call_Dogma_Deactivate::Call_Dogma_Deactivate() {
	itemID = 0;
	effectName = "";
}

Call_Dogma_Deactivate::~Call_Dogma_Deactivate() {
}

void Call_Dogma_Deactivate::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_Dogma_Deactivate", pfx);
	_log(l_type, "%sitemID=%lu", pfx, itemID);
	_log(l_type, "%seffectName='%s'", pfx, effectName.c_str());
}

PyRepTuple *Call_Dogma_Deactivate::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(itemID);
	tuple0->items[1] = new PyRepString(effectName);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_Dogma_Deactivate::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(itemID);
	tuple0->items[1] = new PyRepString(effectName);
	res = tuple0;
	

	return(res);
}

bool Call_Dogma_Deactivate::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_Dogma_Deactivate::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_Dogma_Deactivate failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Call_Dogma_Deactivate failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_Dogma_Deactivate failed: itemID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_Dogma_Deactivate: truncating 64 bit into into 32 bit int for field itemID");
	}
	itemID = int_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Call_Dogma_Deactivate failed: effectName is not a string: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple0->items[1];
	effectName = string_2->value;

	delete packet;
	return(true);
}

Call_Dogma_Deactivate *Call_Dogma_Deactivate::Clone() const {
	Call_Dogma_Deactivate *res = new Call_Dogma_Deactivate;
	res->CloneFrom(this);
	return(res);
}

void Call_Dogma_Deactivate::CloneFrom(const Call_Dogma_Deactivate *from) {
	itemID = from->itemID;
	effectName = from->effectName;
	
}


Rsp_Dogma_AddTarget::Rsp_Dogma_AddTarget() {
	success = false;
}

Rsp_Dogma_AddTarget::~Rsp_Dogma_AddTarget() {
}

void Rsp_Dogma_AddTarget::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRsp_Dogma_AddTarget", pfx);
	_log(l_type, "%ssuccess=%s", pfx, success?"true":"false");
	_log(l_type, "%stargets: Integer list with %d enetires", pfx, targets.size());
	std::vector<uint32>::const_iterator targets_cur, targets_end;
	targets_cur = targets.begin();
	targets_end = targets.end();
	int targets_index;
	for(targets_index = 0; targets_cur != targets_end; targets_cur++, targets_index++) {
		_log(l_type, "%s   [%02d] %d", pfx, targets_index, *targets_cur);
	}
	
}

PyRepTuple *Rsp_Dogma_AddTarget::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepBoolean(success);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator targets_cur, targets_end;
	targets_cur = targets.begin();
	targets_end = targets.end();
	for(; targets_cur != targets_end; targets_cur++) {
		list1->items.push_back(
			new PyRepInteger(*targets_cur)
		);
	}
	tuple0->items[1] = list1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *Rsp_Dogma_AddTarget::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepBoolean(success);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator targets_cur, targets_end;
	targets_cur = targets.begin();
	targets_end = targets.end();
	for(; targets_cur != targets_end; targets_cur++) {
		list1->items.push_back(
			new PyRepInteger(*targets_cur)
		);
	}
	tuple0->items[1] = list1;
	
	res = tuple0;
	

	return(res);
}

bool Rsp_Dogma_AddTarget::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Rsp_Dogma_AddTarget::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_Dogma_AddTarget failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Rsp_Dogma_AddTarget failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Boolean)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_Dogma_AddTarget failed: success is not a boolean: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepBoolean *bool_1 = (PyRepBoolean *) tuple0->items[0];
	success = bool_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_Dogma_AddTarget failed: targets is not a list: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	targets.clear();
	PyRepList *list_2 = (PyRepList *) tuple0->items[1];
	PyRepList::iterator targets_cur, targets_end;
	targets_cur = list_2->items.begin();
	targets_end = list_2->items.end();
	int targets_index;
	for(targets_index = 0; targets_cur != targets_end; targets_cur++, targets_index++) {
		if(!(*targets_cur)->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode Rsp_Dogma_AddTarget failed: Element %d in list targets is not an integer: %s", targets_index, (*targets_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *t = (PyRepInteger *) (*targets_cur);
		if(t->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode Rsp_Dogma_AddTarget: truncating 64 bit into into 32 bit int for item %d in field targets", targets_index);
		}
		targets.push_back(t->value);
	}


	delete packet;
	return(true);
}

Rsp_Dogma_AddTarget *Rsp_Dogma_AddTarget::Clone() const {
	Rsp_Dogma_AddTarget *res = new Rsp_Dogma_AddTarget;
	res->CloneFrom(this);
	return(res);
}

void Rsp_Dogma_AddTarget::CloneFrom(const Rsp_Dogma_AddTarget *from) {
	success = from->success;
	targets = from->targets;
	
}


Notify_OnGodmaShipEffect::Notify_OnGodmaShipEffect() {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	notify_type = "OnGodmaShipEffect";
	itemID = 0;
	effectID = 0;
	when = 0;
	start = 0;
	active = 0;
	/*  Environment. see ENV_IDX_*  */
	env_itemID = 0;
	env_charID = 0;
	env_shipID = 0;
	env_target = 0;
	/*  optional  */
	env_other = NULL;
	/*  can be complex  */
	/*  not sure what data goes in here.  */
	env_effectID = 0;
	startTime = 0;
	duration = 0;
	/*  seen an 0x07! I think it means infinite.  */
	repeat = 0;
	randomSeed = NULL;
	error = NULL;
	/*  <raw name="stall" />  */
}

Notify_OnGodmaShipEffect::~Notify_OnGodmaShipEffect() {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	/*  Environment. see ENV_IDX_*  */
	/*  optional  */
	delete env_other;
	/*  can be complex  */
	/*  not sure what data goes in here.  */
	/*  seen an 0x07! I think it means infinite.  */
	delete randomSeed;
	delete error;
	/*  <raw name="stall" />  */
}

void Notify_OnGodmaShipEffect::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotify_OnGodmaShipEffect", pfx);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	_log(l_type, "%snotify_type='%s'", pfx, notify_type.c_str());
	_log(l_type, "%sitemID=%lu", pfx, itemID);
	_log(l_type, "%seffectID=%lu", pfx, effectID);
	_log(l_type, "%swhen=" I64u, pfx, when);
	_log(l_type, "%sstart=%lu", pfx, start);
	_log(l_type, "%sactive=%lu", pfx, active);
	/*  Environment. see ENV_IDX_*  */
	_log(l_type, "%senv_itemID=%lu", pfx, env_itemID);
	_log(l_type, "%senv_charID=%lu", pfx, env_charID);
	_log(l_type, "%senv_shipID=%lu", pfx, env_shipID);
	_log(l_type, "%senv_target=%lu", pfx, env_target);
	/*  optional  */
	_log(l_type, "%senv_other:", pfx);
	std::string env_other_n(pfx);
	env_other_n += "    ";
	if(env_other == NULL) {
		_log(l_type, "%sERROR: NULL REP!", env_other_n.c_str());
	} else {
		env_other->Dump(l_type, env_other_n.c_str());
	}
	/*  can be complex  */
	_log(l_type, "%senv_area: ", pfx);
	std::string env_area_n(pfx);
	env_area_n += "    ";
	env_area.Dump(l_type, env_area_n.c_str());
	/*  not sure what data goes in here.  */
	_log(l_type, "%senv_effectID=%lu", pfx, env_effectID);
	_log(l_type, "%sstartTime=" I64u, pfx, startTime);
	_log(l_type, "%sduration=" I64u, pfx, duration);
	/*  seen an 0x07! I think it means infinite.  */
	_log(l_type, "%srepeat=%lu", pfx, repeat);
	_log(l_type, "%srandomSeed:", pfx);
	std::string randomSeed_n(pfx);
	randomSeed_n += "    ";
	if(randomSeed == NULL) {
		_log(l_type, "%sERROR: NULL REP!", randomSeed_n.c_str());
	} else {
		randomSeed->Dump(l_type, randomSeed_n.c_str());
	}
	_log(l_type, "%serror:", pfx);
	std::string error_n(pfx);
	error_n += "    ";
	if(error == NULL) {
		_log(l_type, "%sERROR: NULL REP!", error_n.c_str());
	} else {
		error->Dump(l_type, error_n.c_str());
	}
	/*  <raw name="stall" />  */
}

PyRepTuple *Notify_OnGodmaShipEffect::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(12);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	tuple0->items[0] = new PyRepString(notify_type);
	tuple0->items[1] = new PyRepInteger(itemID);
	tuple0->items[2] = new PyRepInteger(effectID);
	tuple0->items[3] = new PyRepInteger(when);
	tuple0->items[4] = new PyRepInteger(start);
	tuple0->items[5] = new PyRepInteger(active);
	/*  Environment. see ENV_IDX_*  */
	PyRepList *list1 = new PyRepList();
	list1->items.resize(7, NULL);
	list1->items[0] = new PyRepInteger(env_itemID);
	list1->items[1] = new PyRepInteger(env_charID);
	list1->items[2] = new PyRepInteger(env_shipID);
	if(env_target == 0) {
		list1->items[3] = new PyRepNone();
	} else {
		list1->items[3] = new PyRepInteger(env_target);
	}
	/*  optional  */
	if(env_other == NULL) {
		_log(NET__PACKET_ERROR, "Encode Notify_OnGodmaShipEffect: env_other is NULL! hacking in a PyRepNone");
		env_other = new PyRepNone();
	}
	list1->items[4] = env_other->Clone();
	/*  can be complex  */
	list1->items[5] = env_area.Clone();
	/*  not sure what data goes in here.  */
	list1->items[6] = new PyRepInteger(env_effectID);
	tuple0->items[6] = list1;
	
	tuple0->items[7] = new PyRepInteger(startTime);
	tuple0->items[8] = new PyRepInteger(duration);
	/*  seen an 0x07! I think it means infinite.  */
	tuple0->items[9] = new PyRepInteger(repeat);
	if(randomSeed == NULL) {
		_log(NET__PACKET_ERROR, "Encode Notify_OnGodmaShipEffect: randomSeed is NULL! hacking in a PyRepNone");
		randomSeed = new PyRepNone();
	}
	tuple0->items[10] = randomSeed->Clone();
	if(error == NULL) {
		_log(NET__PACKET_ERROR, "Encode Notify_OnGodmaShipEffect: error is NULL! hacking in a PyRepNone");
		error = new PyRepNone();
	}
	tuple0->items[11] = error->Clone();
	/*  <raw name="stall" />  */
	res = tuple0;
	

	return(res);
}

PyRepTuple *Notify_OnGodmaShipEffect::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(12);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	tuple0->items[0] = new PyRepString(notify_type);
	tuple0->items[1] = new PyRepInteger(itemID);
	tuple0->items[2] = new PyRepInteger(effectID);
	tuple0->items[3] = new PyRepInteger(when);
	tuple0->items[4] = new PyRepInteger(start);
	tuple0->items[5] = new PyRepInteger(active);
	/*  Environment. see ENV_IDX_*  */
	PyRepList *list1 = new PyRepList();
	list1->items.resize(7, NULL);
	list1->items[0] = new PyRepInteger(env_itemID);
	list1->items[1] = new PyRepInteger(env_charID);
	list1->items[2] = new PyRepInteger(env_shipID);
	if(env_target == 0) {
		list1->items[3] = new PyRepNone();
	} else {
		list1->items[3] = new PyRepInteger(env_target);
	}
	/*  optional  */
	if(env_other == NULL) {
		_log(NET__PACKET_ERROR, "Encode Notify_OnGodmaShipEffect: env_other is NULL! hacking in a PyRepNone");
		env_other = new PyRepNone();
	}
	list1->items[4] = env_other;
	env_other = NULL;
	/*  can be complex  */
	
	PyRepList *list2 = new PyRepList();
	list2->items = env_area.items;
	env_area.items.clear();
	list1->items[5] = list2;
	/*  not sure what data goes in here.  */
	list1->items[6] = new PyRepInteger(env_effectID);
	tuple0->items[6] = list1;
	
	tuple0->items[7] = new PyRepInteger(startTime);
	tuple0->items[8] = new PyRepInteger(duration);
	/*  seen an 0x07! I think it means infinite.  */
	tuple0->items[9] = new PyRepInteger(repeat);
	if(randomSeed == NULL) {
		_log(NET__PACKET_ERROR, "Encode Notify_OnGodmaShipEffect: randomSeed is NULL! hacking in a PyRepNone");
		randomSeed = new PyRepNone();
	}
	tuple0->items[10] = randomSeed;
	randomSeed = NULL;
	if(error == NULL) {
		_log(NET__PACKET_ERROR, "Encode Notify_OnGodmaShipEffect: error is NULL! hacking in a PyRepNone");
		error = new PyRepNone();
	}
	tuple0->items[11] = error;
	error = NULL;
	/*  <raw name="stall" />  */
	res = tuple0;
	

	return(res);
}

bool Notify_OnGodmaShipEffect::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Notify_OnGodmaShipEffect::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnGodmaShipEffect failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 12) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnGodmaShipEffect failed: tuple0 is the wrong size: expected 12, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  setup to go into an OnMultiEvent (notify_type)  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnGodmaShipEffect failed: notify_type is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	notify_type = string_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnGodmaShipEffect failed: itemID is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Notify_OnGodmaShipEffect: truncating 64 bit into into 32 bit int for field itemID");
	}
	itemID = int_2->value;
	if(!tuple0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnGodmaShipEffect failed: effectID is not an int: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple0->items[2];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Notify_OnGodmaShipEffect: truncating 64 bit into into 32 bit int for field effectID");
	}
	effectID = int_3->value;
	if(!tuple0->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnGodmaShipEffect failed: when is not an int: %s", tuple0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_4 = (PyRepInteger *) tuple0->items[3];
	when = int64_4->value;
	if(!tuple0->items[4]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnGodmaShipEffect failed: start is not an int: %s", tuple0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) tuple0->items[4];
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Notify_OnGodmaShipEffect: truncating 64 bit into into 32 bit int for field start");
	}
	start = int_5->value;
	if(!tuple0->items[5]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnGodmaShipEffect failed: active is not an int: %s", tuple0->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_6 = (PyRepInteger *) tuple0->items[5];
	if(int_6->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Notify_OnGodmaShipEffect: truncating 64 bit into into 32 bit int for field active");
	}
	active = int_6->value;
	/*  Environment. see ENV_IDX_*  */
	if(!tuple0->items[6]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnGodmaShipEffect failed: list7 is not a list: %s", tuple0->items[6]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list7 = (PyRepList *) tuple0->items[6];
	if(list7->items.size() != 7) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnGodmaShipEffect failed: list7 is the wrong size: expected 7, but got %d", list7->items.size());
		delete packet;
		return(false);
	}

	if(!list7->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnGodmaShipEffect failed: env_itemID is not an int: %s", list7->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_8 = (PyRepInteger *) list7->items[0];
	if(int_8->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Notify_OnGodmaShipEffect: truncating 64 bit into into 32 bit int for field env_itemID");
	}
	env_itemID = int_8->value;
	if(!list7->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnGodmaShipEffect failed: env_charID is not an int: %s", list7->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_9 = (PyRepInteger *) list7->items[1];
	if(int_9->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Notify_OnGodmaShipEffect: truncating 64 bit into into 32 bit int for field env_charID");
	}
	env_charID = int_9->value;
	if(!list7->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnGodmaShipEffect failed: env_shipID is not an int: %s", list7->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_10 = (PyRepInteger *) list7->items[2];
	if(int_10->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Notify_OnGodmaShipEffect: truncating 64 bit into into 32 bit int for field env_shipID");
	}
	env_shipID = int_10->value;
	if(list7->items[3]->CheckType(PyRep::None)) {
		env_target = 0;
	} else {
	if(!list7->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnGodmaShipEffect failed: env_target is not an int: %s", list7->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_11 = (PyRepInteger *) list7->items[3];
	if(int_11->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Notify_OnGodmaShipEffect: truncating 64 bit into into 32 bit int for field env_target");
	}
	env_target = int_11->value;
	}
	/*  optional  */
	delete env_other;
	env_other = list7->items[4];
	list7->items[4] = NULL;
	
	/*  can be complex  */
	if(!list7->items[5]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnGodmaShipEffect failed: env_area is not a list: %s", list7->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_env_area = (PyRepList *) list7->items[5];	env_area.items = list_env_area->items;
	list_env_area->items.clear();
	
	/*  not sure what data goes in here.  */
	if(!list7->items[6]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnGodmaShipEffect failed: env_effectID is not an int: %s", list7->items[6]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_12 = (PyRepInteger *) list7->items[6];
	if(int_12->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Notify_OnGodmaShipEffect: truncating 64 bit into into 32 bit int for field env_effectID");
	}
	env_effectID = int_12->value;
	if(!tuple0->items[7]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnGodmaShipEffect failed: startTime is not an int: %s", tuple0->items[7]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_13 = (PyRepInteger *) tuple0->items[7];
	startTime = int64_13->value;
	if(!tuple0->items[8]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnGodmaShipEffect failed: duration is not an int: %s", tuple0->items[8]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_14 = (PyRepInteger *) tuple0->items[8];
	duration = int64_14->value;
	/*  seen an 0x07! I think it means infinite.  */
	if(!tuple0->items[9]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnGodmaShipEffect failed: repeat is not an int: %s", tuple0->items[9]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_15 = (PyRepInteger *) tuple0->items[9];
	if(int_15->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Notify_OnGodmaShipEffect: truncating 64 bit into into 32 bit int for field repeat");
	}
	repeat = int_15->value;
	delete randomSeed;
	randomSeed = tuple0->items[10];
	tuple0->items[10] = NULL;
	
	delete error;
	error = tuple0->items[11];
	tuple0->items[11] = NULL;
	
	/*  <raw name="stall" />  */

	delete packet;
	return(true);
}

Notify_OnGodmaShipEffect *Notify_OnGodmaShipEffect::Clone() const {
	Notify_OnGodmaShipEffect *res = new Notify_OnGodmaShipEffect;
	res->CloneFrom(this);
	return(res);
}

void Notify_OnGodmaShipEffect::CloneFrom(const Notify_OnGodmaShipEffect *from) {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	notify_type = from->notify_type;
	itemID = from->itemID;
	effectID = from->effectID;
	when = from->when;
	start = from->start;
	active = from->active;
	/*  Environment. see ENV_IDX_*  */
	env_itemID = from->env_itemID;
	env_charID = from->env_charID;
	env_shipID = from->env_shipID;
	env_target = from->env_target;
	/*  optional  */
	delete env_other;
	if(from->env_other == NULL) {
		env_other = NULL;
	} else {
		env_other = from->env_other->Clone();
	}
	/*  can be complex  */
	env_area.CloneFrom(&from->env_area);
	/*  not sure what data goes in here.  */
	env_effectID = from->env_effectID;
	startTime = from->startTime;
	duration = from->duration;
	/*  seen an 0x07! I think it means infinite.  */
	repeat = from->repeat;
	delete randomSeed;
	if(from->randomSeed == NULL) {
		randomSeed = NULL;
	} else {
		randomSeed = from->randomSeed->Clone();
	}
	delete error;
	if(from->error == NULL) {
		error = NULL;
	} else {
		error = from->error->Clone();
	}
	/*  <raw name="stall" />  */
	
}


Notify_OnModuleAttributeChange::Notify_OnModuleAttributeChange() {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	notify_type = "OnModuleAttributeChange";
	ownerID = 0;
	itemKey = 0;
	attributeID = 0;
	time = 0;
	newValue = NULL;
	oldValue = NULL;
	/*  <raw name="scatterAttr" />  */
}

Notify_OnModuleAttributeChange::~Notify_OnModuleAttributeChange() {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	delete newValue;
	delete oldValue;
	/*  <raw name="scatterAttr" />  */
}

void Notify_OnModuleAttributeChange::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotify_OnModuleAttributeChange", pfx);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	_log(l_type, "%snotify_type='%s'", pfx, notify_type.c_str());
	_log(l_type, "%sownerID=%lu", pfx, ownerID);
	_log(l_type, "%sitemKey=%lu", pfx, itemKey);
	_log(l_type, "%sattributeID=%lu", pfx, attributeID);
	_log(l_type, "%stime=" I64u, pfx, time);
	_log(l_type, "%snewValue:", pfx);
	std::string newValue_n(pfx);
	newValue_n += "    ";
	if(newValue == NULL) {
		_log(l_type, "%sERROR: NULL REP!", newValue_n.c_str());
	} else {
		newValue->Dump(l_type, newValue_n.c_str());
	}
	_log(l_type, "%soldValue:", pfx);
	std::string oldValue_n(pfx);
	oldValue_n += "    ";
	if(oldValue == NULL) {
		_log(l_type, "%sERROR: NULL REP!", oldValue_n.c_str());
	} else {
		oldValue->Dump(l_type, oldValue_n.c_str());
	}
	/*  <raw name="scatterAttr" />  */
}

PyRepTuple *Notify_OnModuleAttributeChange::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(7);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	tuple0->items[0] = new PyRepString(notify_type);
	tuple0->items[1] = new PyRepInteger(ownerID);
	tuple0->items[2] = new PyRepInteger(itemKey);
	tuple0->items[3] = new PyRepInteger(attributeID);
	tuple0->items[4] = new PyRepInteger(time);
	if(newValue == NULL) {
		_log(NET__PACKET_ERROR, "Encode Notify_OnModuleAttributeChange: newValue is NULL! hacking in a PyRepNone");
		newValue = new PyRepNone();
	}
	tuple0->items[5] = newValue->Clone();
	if(oldValue == NULL) {
		_log(NET__PACKET_ERROR, "Encode Notify_OnModuleAttributeChange: oldValue is NULL! hacking in a PyRepNone");
		oldValue = new PyRepNone();
	}
	tuple0->items[6] = oldValue->Clone();
	/*  <raw name="scatterAttr" />  */
	res = tuple0;
	

	return(res);
}

PyRepTuple *Notify_OnModuleAttributeChange::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(7);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	tuple0->items[0] = new PyRepString(notify_type);
	tuple0->items[1] = new PyRepInteger(ownerID);
	tuple0->items[2] = new PyRepInteger(itemKey);
	tuple0->items[3] = new PyRepInteger(attributeID);
	tuple0->items[4] = new PyRepInteger(time);
	if(newValue == NULL) {
		_log(NET__PACKET_ERROR, "Encode Notify_OnModuleAttributeChange: newValue is NULL! hacking in a PyRepNone");
		newValue = new PyRepNone();
	}
	tuple0->items[5] = newValue;
	newValue = NULL;
	if(oldValue == NULL) {
		_log(NET__PACKET_ERROR, "Encode Notify_OnModuleAttributeChange: oldValue is NULL! hacking in a PyRepNone");
		oldValue = new PyRepNone();
	}
	tuple0->items[6] = oldValue;
	oldValue = NULL;
	/*  <raw name="scatterAttr" />  */
	res = tuple0;
	

	return(res);
}

bool Notify_OnModuleAttributeChange::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Notify_OnModuleAttributeChange::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnModuleAttributeChange failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 7) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnModuleAttributeChange failed: tuple0 is the wrong size: expected 7, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  setup to go into an OnMultiEvent (notify_type)  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnModuleAttributeChange failed: notify_type is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	notify_type = string_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnModuleAttributeChange failed: ownerID is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Notify_OnModuleAttributeChange: truncating 64 bit into into 32 bit int for field ownerID");
	}
	ownerID = int_2->value;
	if(!tuple0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnModuleAttributeChange failed: itemKey is not an int: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple0->items[2];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Notify_OnModuleAttributeChange: truncating 64 bit into into 32 bit int for field itemKey");
	}
	itemKey = int_3->value;
	if(!tuple0->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnModuleAttributeChange failed: attributeID is not an int: %s", tuple0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple0->items[3];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Notify_OnModuleAttributeChange: truncating 64 bit into into 32 bit int for field attributeID");
	}
	attributeID = int_4->value;
	if(!tuple0->items[4]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnModuleAttributeChange failed: time is not an int: %s", tuple0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_5 = (PyRepInteger *) tuple0->items[4];
	time = int64_5->value;
	delete newValue;
	newValue = tuple0->items[5];
	tuple0->items[5] = NULL;
	
	delete oldValue;
	oldValue = tuple0->items[6];
	tuple0->items[6] = NULL;
	
	/*  <raw name="scatterAttr" />  */

	delete packet;
	return(true);
}

Notify_OnModuleAttributeChange *Notify_OnModuleAttributeChange::Clone() const {
	Notify_OnModuleAttributeChange *res = new Notify_OnModuleAttributeChange;
	res->CloneFrom(this);
	return(res);
}

void Notify_OnModuleAttributeChange::CloneFrom(const Notify_OnModuleAttributeChange *from) {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	notify_type = from->notify_type;
	ownerID = from->ownerID;
	itemKey = from->itemKey;
	attributeID = from->attributeID;
	time = from->time;
	delete newValue;
	if(from->newValue == NULL) {
		newValue = NULL;
	} else {
		newValue = from->newValue->Clone();
	}
	delete oldValue;
	if(from->oldValue == NULL) {
		oldValue = NULL;
	} else {
		oldValue = from->oldValue->Clone();
	}
	/*  <raw name="scatterAttr" />  */
	
}


Notify_OnEffectHit::Notify_OnEffectHit() {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	notify_type = "OnEffectHit";
	/*  what did the shooting  */
	itemID = 0;
	/*  what type of effect? projectileFired for example  */
	effectID = 0;
	/*  what got hit  */
	targetID = 0;
	/*  the damage which was done  */
	damage = 0.0;
}

Notify_OnEffectHit::~Notify_OnEffectHit() {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	/*  what did the shooting  */
	/*  what type of effect? projectileFired for example  */
	/*  what got hit  */
	/*  the damage which was done  */
}

void Notify_OnEffectHit::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotify_OnEffectHit", pfx);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	_log(l_type, "%snotify_type='%s'", pfx, notify_type.c_str());
	/*  what did the shooting  */
	_log(l_type, "%sitemID=%lu", pfx, itemID);
	/*  what type of effect? projectileFired for example  */
	_log(l_type, "%seffectID=%lu", pfx, effectID);
	/*  what got hit  */
	_log(l_type, "%stargetID=%lu", pfx, targetID);
	/*  the damage which was done  */
	_log(l_type, "%sdamage=%.13f", pfx, damage);
}

PyRepTuple *Notify_OnEffectHit::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	tuple0->items[0] = new PyRepString(notify_type);
	/*  what did the shooting  */
	tuple0->items[1] = new PyRepInteger(itemID);
	/*  what type of effect? projectileFired for example  */
	tuple0->items[2] = new PyRepInteger(effectID);
	/*  what got hit  */
	tuple0->items[3] = new PyRepInteger(targetID);
	/*  the damage which was done  */
	tuple0->items[4] = new PyRepReal(damage);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Notify_OnEffectHit::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	tuple0->items[0] = new PyRepString(notify_type);
	/*  what did the shooting  */
	tuple0->items[1] = new PyRepInteger(itemID);
	/*  what type of effect? projectileFired for example  */
	tuple0->items[2] = new PyRepInteger(effectID);
	/*  what got hit  */
	tuple0->items[3] = new PyRepInteger(targetID);
	/*  the damage which was done  */
	tuple0->items[4] = new PyRepReal(damage);
	res = tuple0;
	

	return(res);
}

bool Notify_OnEffectHit::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Notify_OnEffectHit::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnEffectHit failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 5) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnEffectHit failed: tuple0 is the wrong size: expected 5, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  setup to go into an OnMultiEvent (notify_type)  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnEffectHit failed: notify_type is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	notify_type = string_1->value;
	/*  what did the shooting  */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnEffectHit failed: itemID is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Notify_OnEffectHit: truncating 64 bit into into 32 bit int for field itemID");
	}
	itemID = int_2->value;
	/*  what type of effect? projectileFired for example  */
	if(!tuple0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnEffectHit failed: effectID is not an int: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple0->items[2];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Notify_OnEffectHit: truncating 64 bit into into 32 bit int for field effectID");
	}
	effectID = int_3->value;
	/*  what got hit  */
	if(!tuple0->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnEffectHit failed: targetID is not an int: %s", tuple0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple0->items[3];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Notify_OnEffectHit: truncating 64 bit into into 32 bit int for field targetID");
	}
	targetID = int_4->value;
	/*  the damage which was done  */
	if(!tuple0->items[4]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnEffectHit failed: damage is not a real: %s", tuple0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_5 = (PyRepReal *) tuple0->items[4];
	damage = real_5->value;

	delete packet;
	return(true);
}

Notify_OnEffectHit *Notify_OnEffectHit::Clone() const {
	Notify_OnEffectHit *res = new Notify_OnEffectHit;
	res->CloneFrom(this);
	return(res);
}

void Notify_OnEffectHit::CloneFrom(const Notify_OnEffectHit *from) {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	notify_type = from->notify_type;
	/*  what did the shooting  */
	itemID = from->itemID;
	/*  what type of effect? projectileFired for example  */
	effectID = from->effectID;
	/*  what got hit  */
	targetID = from->targetID;
	/*  the damage which was done  */
	damage = from->damage;
	
}

	/*  this notify represents damage done to us by something else  */

Notify_OnDamageMessage_Self::Notify_OnDamageMessage_Self() {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	notify_type = "OnDamageMessage";
	/*  messageID: from eveMessages   */
	messageID = "";
	/*  can also have target here...  */
	damage = 0.0;
	source = 0;
	splash = "";
}

Notify_OnDamageMessage_Self::~Notify_OnDamageMessage_Self() {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	/*  messageID: from eveMessages   */
	/*  can also have target here...  */
}

void Notify_OnDamageMessage_Self::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotify_OnDamageMessage_Self", pfx);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	_log(l_type, "%snotify_type='%s'", pfx, notify_type.c_str());
	/*  messageID: from eveMessages   */
	_log(l_type, "%smessageID='%s'", pfx, messageID.c_str());
	/*  can also have target here...  */
	_log(l_type, "%sdamage=%.13f", pfx, damage);
	_log(l_type, "%ssource=%lu", pfx, source);
	_log(l_type, "%ssplash='%s'", pfx, splash.c_str());
}

PyRepTuple *Notify_OnDamageMessage_Self::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	tuple0->items[0] = new PyRepString(notify_type);
	/*  messageID: from eveMessages   */
	tuple0->items[1] = new PyRepString(messageID);
	PyRepDict *dict1 = new PyRepDict();
	/*  can also have target here...  */
	PyRep *dict1_0;
	dict1_0 = new PyRepReal(damage);
	dict1->items[
		new PyRepString("damage")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepInteger(source);
	dict1->items[
		new PyRepString("source")
	] = dict1_1;
	PyRep *dict1_2;
	dict1_2 = new PyRepString(splash);
	dict1->items[
		new PyRepString("splash")
	] = dict1_2;
	tuple0->items[2] = dict1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *Notify_OnDamageMessage_Self::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	tuple0->items[0] = new PyRepString(notify_type);
	/*  messageID: from eveMessages   */
	tuple0->items[1] = new PyRepString(messageID);
	PyRepDict *dict1 = new PyRepDict();
	/*  can also have target here...  */
	PyRep *dict1_0;
	dict1_0 = new PyRepReal(damage);
	dict1->items[
		new PyRepString("damage")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepInteger(source);
	dict1->items[
		new PyRepString("source")
	] = dict1_1;
	PyRep *dict1_2;
	dict1_2 = new PyRepString(splash);
	dict1->items[
		new PyRepString("splash")
	] = dict1_2;
	tuple0->items[2] = dict1;
	
	res = tuple0;
	

	return(res);
}

bool Notify_OnDamageMessage_Self::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Notify_OnDamageMessage_Self::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Self failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Self failed: tuple0 is the wrong size: expected 3, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  setup to go into an OnMultiEvent (notify_type)  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Self failed: notify_type is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	notify_type = string_1->value;
	/*  messageID: from eveMessages   */
	if(!tuple0->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Self failed: messageID is not a string: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple0->items[1];
	messageID = string_2->value;
	if(!tuple0->items[2]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Self failed: dict3 is the wrong type: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	bool dict3_damage = false;
	bool dict3_source = false;
	bool dict3_splash = false;
	PyRepDict *dict3 = (PyRepDict *) tuple0->items[2];
	
	PyRepDict::iterator dict3_cur, dict3_end;
	dict3_cur = dict3->items.begin();
	dict3_end = dict3->items.end();
	for(; dict3_cur != dict3_end; dict3_cur++) {
		PyRep *key__ = dict3_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Self failed: a key in dict3 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
	/*  can also have target here...  */
		if(key_string__->value == "damage") {
			dict3_damage = true;
	if(!dict3_cur->second->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Self failed: damage is not a real: %s", dict3_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_4 = (PyRepReal *) dict3_cur->second;
	damage = real_4->value;
		} else
		if(key_string__->value == "source") {
			dict3_source = true;
	if(!dict3_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Self failed: source is not an int: %s", dict3_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) dict3_cur->second;
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Notify_OnDamageMessage_Self: truncating 64 bit into into 32 bit int for field source");
	}
	source = int_5->value;
		} else
		if(key_string__->value == "splash") {
			dict3_splash = true;
	if(!dict3_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Self failed: splash is not a string: %s", dict3_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_6 = (PyRepString *) dict3_cur->second;
	splash = string_6->value;
		} else
		{
			_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Self failed: Unknown key string '%s' in dict3", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict3_damage) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Self failed: Missing dict entry for 'damage' in dict3");
		delete packet;
		return(false);
	}
	
	if(!dict3_source) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Self failed: Missing dict entry for 'source' in dict3");
		delete packet;
		return(false);
	}
	
	if(!dict3_splash) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Self failed: Missing dict entry for 'splash' in dict3");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

Notify_OnDamageMessage_Self *Notify_OnDamageMessage_Self::Clone() const {
	Notify_OnDamageMessage_Self *res = new Notify_OnDamageMessage_Self;
	res->CloneFrom(this);
	return(res);
}

void Notify_OnDamageMessage_Self::CloneFrom(const Notify_OnDamageMessage_Self *from) {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	notify_type = from->notify_type;
	/*  messageID: from eveMessages   */
	messageID = from->messageID;
	/*  can also have target here...  */
	damage = from->damage;
	source = from->source;
	splash = from->splash;
	
}

	/*  this notify represents damage done to us by something else  */

Notify_OnDamageMessage_Other::Notify_OnDamageMessage_Other() {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	notify_type = "OnDamageMessage";
	/*  messageID: from eveMessages   */
	messageID = "";
	/*  can also have target here...  */
	damage = 0.0;
	target = 0;
	/*  this should be set to fmtMapping_itemTypeName  */
	format_type = 0;
	weaponType = 0;
	splash = "";
}

Notify_OnDamageMessage_Other::~Notify_OnDamageMessage_Other() {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	/*  messageID: from eveMessages   */
	/*  can also have target here...  */
	/*  this should be set to fmtMapping_itemTypeName  */
}

void Notify_OnDamageMessage_Other::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotify_OnDamageMessage_Other", pfx);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	_log(l_type, "%snotify_type='%s'", pfx, notify_type.c_str());
	/*  messageID: from eveMessages   */
	_log(l_type, "%smessageID='%s'", pfx, messageID.c_str());
	/*  can also have target here...  */
	_log(l_type, "%sdamage=%.13f", pfx, damage);
	_log(l_type, "%starget=%lu", pfx, target);
	/*  this should be set to fmtMapping_itemTypeName  */
	_log(l_type, "%sformat_type=%lu", pfx, format_type);
	_log(l_type, "%sweaponType=%lu", pfx, weaponType);
	_log(l_type, "%ssplash='%s'", pfx, splash.c_str());
}

PyRepTuple *Notify_OnDamageMessage_Other::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	tuple0->items[0] = new PyRepString(notify_type);
	/*  messageID: from eveMessages   */
	tuple0->items[1] = new PyRepString(messageID);
	PyRepDict *dict1 = new PyRepDict();
	/*  can also have target here...  */
	PyRep *dict1_0;
	dict1_0 = new PyRepReal(damage);
	dict1->items[
		new PyRepString("damage")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepInteger(target);
	dict1->items[
		new PyRepString("target")
	] = dict1_1;
	PyRep *dict1_2;
	PyRepTuple *tuple2 = new PyRepTuple(2);
	/*  this should be set to fmtMapping_itemTypeName  */
	tuple2->items[0] = new PyRepInteger(format_type);
	tuple2->items[1] = new PyRepInteger(weaponType);
	dict1_2 = tuple2;
	
	dict1->items[
		new PyRepString("weapon")
	] = dict1_2;
	PyRep *dict1_3;
	dict1_3 = new PyRepString(splash);
	dict1->items[
		new PyRepString("splash")
	] = dict1_3;
	tuple0->items[2] = dict1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *Notify_OnDamageMessage_Other::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	tuple0->items[0] = new PyRepString(notify_type);
	/*  messageID: from eveMessages   */
	tuple0->items[1] = new PyRepString(messageID);
	PyRepDict *dict1 = new PyRepDict();
	/*  can also have target here...  */
	PyRep *dict1_0;
	dict1_0 = new PyRepReal(damage);
	dict1->items[
		new PyRepString("damage")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepInteger(target);
	dict1->items[
		new PyRepString("target")
	] = dict1_1;
	PyRep *dict1_2;
	PyRepTuple *tuple2 = new PyRepTuple(2);
	/*  this should be set to fmtMapping_itemTypeName  */
	tuple2->items[0] = new PyRepInteger(format_type);
	tuple2->items[1] = new PyRepInteger(weaponType);
	dict1_2 = tuple2;
	
	dict1->items[
		new PyRepString("weapon")
	] = dict1_2;
	PyRep *dict1_3;
	dict1_3 = new PyRepString(splash);
	dict1->items[
		new PyRepString("splash")
	] = dict1_3;
	tuple0->items[2] = dict1;
	
	res = tuple0;
	

	return(res);
}

bool Notify_OnDamageMessage_Other::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Notify_OnDamageMessage_Other::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Other failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Other failed: tuple0 is the wrong size: expected 3, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  setup to go into an OnMultiEvent (notify_type)  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Other failed: notify_type is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	notify_type = string_1->value;
	/*  messageID: from eveMessages   */
	if(!tuple0->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Other failed: messageID is not a string: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple0->items[1];
	messageID = string_2->value;
	if(!tuple0->items[2]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Other failed: dict3 is the wrong type: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	bool dict3_damage = false;
	bool dict3_target = false;
	bool dict3__weapon = false;
	bool dict3_splash = false;
	PyRepDict *dict3 = (PyRepDict *) tuple0->items[2];
	
	PyRepDict::iterator dict3_cur, dict3_end;
	dict3_cur = dict3->items.begin();
	dict3_end = dict3->items.end();
	for(; dict3_cur != dict3_end; dict3_cur++) {
		PyRep *key__ = dict3_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Other failed: a key in dict3 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
	/*  can also have target here...  */
		if(key_string__->value == "damage") {
			dict3_damage = true;
	if(!dict3_cur->second->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Other failed: damage is not a real: %s", dict3_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_4 = (PyRepReal *) dict3_cur->second;
	damage = real_4->value;
		} else
		if(key_string__->value == "target") {
			dict3_target = true;
	if(!dict3_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Other failed: target is not an int: %s", dict3_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) dict3_cur->second;
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Notify_OnDamageMessage_Other: truncating 64 bit into into 32 bit int for field target");
	}
	target = int_5->value;
		} else
		if(key_string__->value == "weapon") {
			dict3__weapon = true;
	if(!dict3_cur->second->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Other failed: tuple6 is the wrong type: %s", dict3_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple6 = (PyRepTuple *) dict3_cur->second;
	if(tuple6->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Other failed: tuple6 is the wrong size: expected 2, but got %d", tuple6->items.size());
		delete packet;
		return(false);
	}

	/*  this should be set to fmtMapping_itemTypeName  */
	if(!tuple6->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Other failed: format_type is not an int: %s", tuple6->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_7 = (PyRepInteger *) tuple6->items[0];
	if(int_7->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Notify_OnDamageMessage_Other: truncating 64 bit into into 32 bit int for field format_type");
	}
	format_type = int_7->value;
	if(!tuple6->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Other failed: weaponType is not an int: %s", tuple6->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_8 = (PyRepInteger *) tuple6->items[1];
	if(int_8->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Notify_OnDamageMessage_Other: truncating 64 bit into into 32 bit int for field weaponType");
	}
	weaponType = int_8->value;
		} else
		if(key_string__->value == "splash") {
			dict3_splash = true;
	if(!dict3_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Other failed: splash is not a string: %s", dict3_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_9 = (PyRepString *) dict3_cur->second;
	splash = string_9->value;
		} else
		{
			_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Other failed: Unknown key string '%s' in dict3", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict3_damage) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Other failed: Missing dict entry for 'damage' in dict3");
		delete packet;
		return(false);
	}
	
	if(!dict3_target) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Other failed: Missing dict entry for 'target' in dict3");
		delete packet;
		return(false);
	}
	
	if(!dict3__weapon) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Other failed: Missing dict entry for '_weapon' in dict3");
		delete packet;
		return(false);
	}
	
	if(!dict3_splash) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessage_Other failed: Missing dict entry for 'splash' in dict3");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

Notify_OnDamageMessage_Other *Notify_OnDamageMessage_Other::Clone() const {
	Notify_OnDamageMessage_Other *res = new Notify_OnDamageMessage_Other;
	res->CloneFrom(this);
	return(res);
}

void Notify_OnDamageMessage_Other::CloneFrom(const Notify_OnDamageMessage_Other *from) {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	notify_type = from->notify_type;
	/*  messageID: from eveMessages   */
	messageID = from->messageID;
	/*  can also have target here...  */
	damage = from->damage;
	target = from->target;
	/*  this should be set to fmtMapping_itemTypeName  */
	format_type = from->format_type;
	weaponType = from->weaponType;
	splash = from->splash;
	
}


Notify_OnDamageMessages::Notify_OnDamageMessages() {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	notify_type = "OnDamageMessages";
	/*  this is a list of Notify_OnDamageMessage_*  */
}

Notify_OnDamageMessages::~Notify_OnDamageMessages() {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	/*  this is a list of Notify_OnDamageMessage_*  */
}

void Notify_OnDamageMessages::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotify_OnDamageMessages", pfx);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	_log(l_type, "%snotify_type='%s'", pfx, notify_type.c_str());
	/*  this is a list of Notify_OnDamageMessage_*  */
	_log(l_type, "%smessages: ", pfx);
	std::string messages_n(pfx);
	messages_n += "    ";
	messages.Dump(l_type, messages_n.c_str());
}

PyRepTuple *Notify_OnDamageMessages::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	tuple0->items[0] = new PyRepString(notify_type);
	/*  this is a list of Notify_OnDamageMessage_*  */
	tuple0->items[1] = messages.Clone();
	res = tuple0;
	

	return(res);
}

PyRepTuple *Notify_OnDamageMessages::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	tuple0->items[0] = new PyRepString(notify_type);
	/*  this is a list of Notify_OnDamageMessage_*  */
	
	PyRepList *list1 = new PyRepList();
	list1->items = messages.items;
	messages.items.clear();
	tuple0->items[1] = list1;
	res = tuple0;
	

	return(res);
}

bool Notify_OnDamageMessages::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Notify_OnDamageMessages::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessages failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessages failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  setup to go into an OnMultiEvent (notify_type)  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessages failed: notify_type is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	notify_type = string_1->value;
	/*  this is a list of Notify_OnDamageMessage_*  */
	if(!tuple0->items[1]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnDamageMessages failed: messages is not a list: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_messages = (PyRepList *) tuple0->items[1];	messages.items = list_messages->items;
	list_messages->items.clear();
	

	delete packet;
	return(true);
}

Notify_OnDamageMessages *Notify_OnDamageMessages::Clone() const {
	Notify_OnDamageMessages *res = new Notify_OnDamageMessages;
	res->CloneFrom(this);
	return(res);
}

void Notify_OnDamageMessages::CloneFrom(const Notify_OnDamageMessages *from) {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	notify_type = from->notify_type;
	/*  this is a list of Notify_OnDamageMessage_*  */
	messages.CloneFrom(&from->messages);
	
}


Notify_OnEffectMessage::Notify_OnEffectMessage() {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	notify_type = "OnEffectMessage";
	/*  messageID: from eveMessages   */
	messageID = "";
}

Notify_OnEffectMessage::~Notify_OnEffectMessage() {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	/*  messageID: from eveMessages   */
}

void Notify_OnEffectMessage::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotify_OnEffectMessage", pfx);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	_log(l_type, "%snotify_type='%s'", pfx, notify_type.c_str());
	/*  messageID: from eveMessages   */
	_log(l_type, "%smessageID='%s'", pfx, messageID.c_str());
	_log(l_type, "%sarguments: ", pfx);
	std::string arguments_n(pfx);
	arguments_n += "    ";
	arguments.Dump(l_type, arguments_n.c_str());
}

PyRepTuple *Notify_OnEffectMessage::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	tuple0->items[0] = new PyRepString(notify_type);
	/*  messageID: from eveMessages   */
	tuple0->items[1] = new PyRepString(messageID);
	tuple0->items[2] = arguments.Clone();
	res = tuple0;
	

	return(res);
}

PyRepTuple *Notify_OnEffectMessage::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	tuple0->items[0] = new PyRepString(notify_type);
	/*  messageID: from eveMessages   */
	tuple0->items[1] = new PyRepString(messageID);
	
	PyRepDict *dict1 = new PyRepDict();
	dict1->items = arguments.items;
	arguments.items.clear();
	tuple0->items[2] = dict1;
	res = tuple0;
	

	return(res);
}

bool Notify_OnEffectMessage::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Notify_OnEffectMessage::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnEffectMessage failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnEffectMessage failed: tuple0 is the wrong size: expected 3, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  setup to go into an OnMultiEvent (notify_type)  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnEffectMessage failed: notify_type is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	notify_type = string_1->value;
	/*  messageID: from eveMessages   */
	if(!tuple0->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnEffectMessage failed: messageID is not a string: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple0->items[1];
	messageID = string_2->value;
	if(!tuple0->items[2]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnEffectMessage failed: arguments is not a dict: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepDict *list_arguments = (PyRepDict *) tuple0->items[2];	arguments.items = list_arguments->items;
	list_arguments->items.clear();
	

	delete packet;
	return(true);
}

Notify_OnEffectMessage *Notify_OnEffectMessage::Clone() const {
	Notify_OnEffectMessage *res = new Notify_OnEffectMessage;
	res->CloneFrom(this);
	return(res);
}

void Notify_OnEffectMessage::CloneFrom(const Notify_OnEffectMessage *from) {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	notify_type = from->notify_type;
	/*  messageID: from eveMessages   */
	messageID = from->messageID;
	arguments.CloneFrom(&from->arguments);
	
}


Notify_OnTarget::Notify_OnTarget() {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	notify_type = "OnTarget";
	/*  One of:
        try - starting to target?
        add - targeting successful
        clear - clear all targets
        lost - target lost
        otheradd - somebody else has targeted you
        otherlost - somebody else has stopped targeting you
     */
	mode = "";
	targetID = 0;
	/*  only seen on `target lost` events, but dosent seem to do anything  */
	reason = "";
}

Notify_OnTarget::~Notify_OnTarget() {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	/*  One of:
        try - starting to target?
        add - targeting successful
        clear - clear all targets
        lost - target lost
        otheradd - somebody else has targeted you
        otherlost - somebody else has stopped targeting you
     */
	/*  only seen on `target lost` events, but dosent seem to do anything  */
}

void Notify_OnTarget::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotify_OnTarget", pfx);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	_log(l_type, "%snotify_type='%s'", pfx, notify_type.c_str());
	/*  One of:
        try - starting to target?
        add - targeting successful
        clear - clear all targets
        lost - target lost
        otheradd - somebody else has targeted you
        otherlost - somebody else has stopped targeting you
     */
	_log(l_type, "%smode='%s'", pfx, mode.c_str());
	_log(l_type, "%stargetID=%lu", pfx, targetID);
	/*  only seen on `target lost` events, but dosent seem to do anything  */
	_log(l_type, "%sreason='%s'", pfx, reason.c_str());
}

PyRepTuple *Notify_OnTarget::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(4);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	tuple0->items[0] = new PyRepString(notify_type);
	/*  One of:
        try - starting to target?
        add - targeting successful
        clear - clear all targets
        lost - target lost
        otheradd - somebody else has targeted you
        otherlost - somebody else has stopped targeting you
     */
	tuple0->items[1] = new PyRepString(mode);
	tuple0->items[2] = new PyRepInteger(targetID);
	/*  only seen on `target lost` events, but dosent seem to do anything  */
	tuple0->items[3] = new PyRepString(reason);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Notify_OnTarget::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(4);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	tuple0->items[0] = new PyRepString(notify_type);
	/*  One of:
        try - starting to target?
        add - targeting successful
        clear - clear all targets
        lost - target lost
        otheradd - somebody else has targeted you
        otherlost - somebody else has stopped targeting you
     */
	tuple0->items[1] = new PyRepString(mode);
	tuple0->items[2] = new PyRepInteger(targetID);
	/*  only seen on `target lost` events, but dosent seem to do anything  */
	tuple0->items[3] = new PyRepString(reason);
	res = tuple0;
	

	return(res);
}

bool Notify_OnTarget::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Notify_OnTarget::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnTarget failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 4) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnTarget failed: tuple0 is the wrong size: expected 4, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  setup to go into an OnMultiEvent (notify_type)  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnTarget failed: notify_type is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	notify_type = string_1->value;
	/*  One of:
        try - starting to target?
        add - targeting successful
        clear - clear all targets
        lost - target lost
        otheradd - somebody else has targeted you
        otherlost - somebody else has stopped targeting you
     */
	if(!tuple0->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnTarget failed: mode is not a string: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple0->items[1];
	mode = string_2->value;
	if(!tuple0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnTarget failed: targetID is not an int: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple0->items[2];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Notify_OnTarget: truncating 64 bit into into 32 bit int for field targetID");
	}
	targetID = int_3->value;
	/*  only seen on `target lost` events, but dosent seem to do anything  */
	if(!tuple0->items[3]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnTarget failed: reason is not a string: %s", tuple0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_4 = (PyRepString *) tuple0->items[3];
	reason = string_4->value;

	delete packet;
	return(true);
}

Notify_OnTarget *Notify_OnTarget::Clone() const {
	Notify_OnTarget *res = new Notify_OnTarget;
	res->CloneFrom(this);
	return(res);
}

void Notify_OnTarget::CloneFrom(const Notify_OnTarget *from) {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	notify_type = from->notify_type;
	/*  One of:
        try - starting to target?
        add - targeting successful
        clear - clear all targets
        lost - target lost
        otheradd - somebody else has targeted you
        otherlost - somebody else has stopped targeting you
     */
	mode = from->mode;
	targetID = from->targetID;
	/*  only seen on `target lost` events, but dosent seem to do anything  */
	reason = from->reason;
	
}


Notify_OnTargets::Notify_OnTargets() {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	notify_type = "OnTargets";
	/*  this is a list of Notify_OnTarget messages  */
}

Notify_OnTargets::~Notify_OnTargets() {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	/*  this is a list of Notify_OnTarget messages  */
}

void Notify_OnTargets::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotify_OnTargets", pfx);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	_log(l_type, "%snotify_type='%s'", pfx, notify_type.c_str());
	/*  this is a list of Notify_OnTarget messages  */
	_log(l_type, "%smessages: ", pfx);
	std::string messages_n(pfx);
	messages_n += "    ";
	messages.Dump(l_type, messages_n.c_str());
}

PyRepTuple *Notify_OnTargets::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	tuple0->items[0] = new PyRepString(notify_type);
	/*  this is a list of Notify_OnTarget messages  */
	tuple0->items[1] = messages.Clone();
	res = tuple0;
	

	return(res);
}

PyRepTuple *Notify_OnTargets::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	tuple0->items[0] = new PyRepString(notify_type);
	/*  this is a list of Notify_OnTarget messages  */
	
	PyRepList *list1 = new PyRepList();
	list1->items = messages.items;
	messages.items.clear();
	tuple0->items[1] = list1;
	res = tuple0;
	

	return(res);
}

bool Notify_OnTargets::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Notify_OnTargets::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnTargets failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnTargets failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  setup to go into an OnMultiEvent (notify_type)  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnTargets failed: notify_type is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	notify_type = string_1->value;
	/*  this is a list of Notify_OnTarget messages  */
	if(!tuple0->items[1]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnTargets failed: messages is not a list: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_messages = (PyRepList *) tuple0->items[1];	messages.items = list_messages->items;
	list_messages->items.clear();
	

	delete packet;
	return(true);
}

Notify_OnTargets *Notify_OnTargets::Clone() const {
	Notify_OnTargets *res = new Notify_OnTargets;
	res->CloneFrom(this);
	return(res);
}

void Notify_OnTargets::CloneFrom(const Notify_OnTargets *from) {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	notify_type = from->notify_type;
	/*  this is a list of Notify_OnTarget messages  */
	messages.CloneFrom(&from->messages);
	
}


Notify_OnGodmaFlushLocation::Notify_OnGodmaFlushLocation() {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	notify_type = "OnGodmaFlushLocation";
	/*  not sure yet  */
}

Notify_OnGodmaFlushLocation::~Notify_OnGodmaFlushLocation() {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	/*  not sure yet  */
}

void Notify_OnGodmaFlushLocation::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotify_OnGodmaFlushLocation", pfx);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	_log(l_type, "%snotify_type='%s'", pfx, notify_type.c_str());
	/*  not sure yet  */
}

PyRepTuple *Notify_OnGodmaFlushLocation::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	tuple0->items[0] = new PyRepString(notify_type);
	/*  not sure yet  */
	res = tuple0;
	

	return(res);
}

PyRepTuple *Notify_OnGodmaFlushLocation::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	tuple0->items[0] = new PyRepString(notify_type);
	/*  not sure yet  */
	res = tuple0;
	

	return(res);
}

bool Notify_OnGodmaFlushLocation::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Notify_OnGodmaFlushLocation::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnGodmaFlushLocation failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnGodmaFlushLocation failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  setup to go into an OnMultiEvent (notify_type)  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnGodmaFlushLocation failed: notify_type is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	notify_type = string_1->value;
	/*  not sure yet  */

	delete packet;
	return(true);
}

Notify_OnGodmaFlushLocation *Notify_OnGodmaFlushLocation::Clone() const {
	Notify_OnGodmaFlushLocation *res = new Notify_OnGodmaFlushLocation;
	res->CloneFrom(this);
	return(res);
}

void Notify_OnGodmaFlushLocation::CloneFrom(const Notify_OnGodmaFlushLocation *from) {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	notify_type = from->notify_type;
	/*  not sure yet  */
	
}


Notify_OnGodmaFlushLocationProfile::Notify_OnGodmaFlushLocationProfile() {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	notify_type = "OnGodmaFlushLocationProfile";
	/*  not sure yet  */
}

Notify_OnGodmaFlushLocationProfile::~Notify_OnGodmaFlushLocationProfile() {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	/*  not sure yet  */
}

void Notify_OnGodmaFlushLocationProfile::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotify_OnGodmaFlushLocationProfile", pfx);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	_log(l_type, "%snotify_type='%s'", pfx, notify_type.c_str());
	/*  not sure yet  */
}

PyRepTuple *Notify_OnGodmaFlushLocationProfile::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	tuple0->items[0] = new PyRepString(notify_type);
	/*  not sure yet  */
	res = tuple0;
	

	return(res);
}

PyRepTuple *Notify_OnGodmaFlushLocationProfile::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  setup to go into an OnMultiEvent (notify_type)  */
	tuple0->items[0] = new PyRepString(notify_type);
	/*  not sure yet  */
	res = tuple0;
	

	return(res);
}

bool Notify_OnGodmaFlushLocationProfile::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Notify_OnGodmaFlushLocationProfile::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnGodmaFlushLocationProfile failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnGodmaFlushLocationProfile failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  setup to go into an OnMultiEvent (notify_type)  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnGodmaFlushLocationProfile failed: notify_type is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	notify_type = string_1->value;
	/*  not sure yet  */

	delete packet;
	return(true);
}

Notify_OnGodmaFlushLocationProfile *Notify_OnGodmaFlushLocationProfile::Clone() const {
	Notify_OnGodmaFlushLocationProfile *res = new Notify_OnGodmaFlushLocationProfile;
	res->CloneFrom(this);
	return(res);
}

void Notify_OnGodmaFlushLocationProfile::CloneFrom(const Notify_OnGodmaFlushLocationProfile *from) {
	/*  setup to go into an OnMultiEvent (notify_type)  */
	notify_type = from->notify_type;
	/*  not sure yet  */
	
}


Notify_OnMultiEvent::Notify_OnMultiEvent() {
}

Notify_OnMultiEvent::~Notify_OnMultiEvent() {
}

void Notify_OnMultiEvent::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotify_OnMultiEvent", pfx);
	_log(l_type, "%sevents: ", pfx);
	std::string events_n(pfx);
	events_n += "    ";
	events.Dump(l_type, events_n.c_str());
}

PyRepTuple *Notify_OnMultiEvent::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	tuple0->items[0] = events.Clone();
	res = tuple0;
	

	return(res);
}

PyRepTuple *Notify_OnMultiEvent::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	
	PyRepList *list1 = new PyRepList();
	list1->items = events.items;
	events.items.clear();
	tuple0->items[0] = list1;
	res = tuple0;
	

	return(res);
}

bool Notify_OnMultiEvent::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Notify_OnMultiEvent::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnMultiEvent failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnMultiEvent failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnMultiEvent failed: events is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_events = (PyRepList *) tuple0->items[0];	events.items = list_events->items;
	list_events->items.clear();
	

	delete packet;
	return(true);
}

Notify_OnMultiEvent *Notify_OnMultiEvent::Clone() const {
	Notify_OnMultiEvent *res = new Notify_OnMultiEvent;
	res->CloneFrom(this);
	return(res);
}

void Notify_OnMultiEvent::CloneFrom(const Notify_OnMultiEvent *from) {
	events.CloneFrom(&from->events);
	
}



