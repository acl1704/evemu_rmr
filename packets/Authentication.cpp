/*  EVEmu: EVE Online Server Emulator
  
  **************************************************************
  This file is automatically generated, DO NOT EDIT IT DIRECTLY.
  **************************************************************
  
  (If you need to customize an object, you must copy that object
  into another source file, and give up the ability to generate it)
  
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; version 2 of the License.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY except by those people which sell it, which
  are required to give you total support for your newly bought product;
  without even the implied warranty of MERCHANTABILITY or FITNESS FOR
  A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/


#include <string>
#include "..\packets\Authentication.h"
#include "../common/PyRep.h"




objectCaching_CachedObject_data::objectCaching_CachedObject_data() {
	/* object of type objectCaching.CachedObject */
	/*  0  */
	/*  0  */
	timestamp = 0;
	/*  1  */
	version = 0;
	/*  1  */
	/*  2  */
	/*  2  */
	nodeID = 0;
	/*  3  */
	shared = 0;
	/*  4  */
	data = NULL;
	/*  5  */
	compressed = 0;
	/*  6  */
	/*  either a string or a tuple  */
	objectID = NULL;
}

objectCaching_CachedObject_data::~objectCaching_CachedObject_data() {
}

void objectCaching_CachedObject_data::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sobjectCaching_CachedObject_data", pfx);
	_log(l_type, "%sObject of type objectCaching.CachedObject:", pfx);
	/*  0  */
	/*  0  */
	_log(l_type, "%stimestamp=" I64u, pfx, timestamp);
	/*  1  */
	_log(l_type, "%sversion=%lu", pfx, version);
	/*  1  */
	/*  2  */
	/*  2  */
	_log(l_type, "%snodeID=%lu", pfx, nodeID);
	/*  3  */
	_log(l_type, "%sshared=%lu", pfx, shared);
	/*  4  */
	_log(l_type, "%sdata: ", pfx);
	std::string data_n(pfx);
	data_n += "    ";
	data->Dump(l_type, data_n.c_str());
	/*  5  */
	_log(l_type, "%scompressed=%lu", pfx, compressed);
	/*  6  */
	/*  either a string or a tuple  */
	_log(l_type, "%sobjectID: ", pfx);
	std::string objectID_n(pfx);
	objectID_n += "    ";
	objectID->Dump(l_type, objectID_n.c_str());
}

PyRepObject *objectCaching_CachedObject_data::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepTuple *tuple1 = new PyRepTuple(7);
	/*  0  */
	PyRepTuple *tuple2 = new PyRepTuple(2);
	/*  0  */
	tuple2->items[0] = new PyRepInteger(timestamp);
	/*  1  */
	tuple2->items[1] = new PyRepInteger(version);
	tuple1->items[0] = tuple2;
	
	/*  1  */
	tuple1->items[1] = new PyRepNone();
	/*  2  */
	/*  2  */
	tuple1->items[2] = new PyRepInteger(nodeID);
	/*  3  */
	tuple1->items[3] = new PyRepInteger(shared);
	/*  4  */
	tuple1->items[4] = data->Clone();
	/*  5  */
	tuple1->items[5] = new PyRepInteger(compressed);
	/*  6  */
	/*  either a string or a tuple  */
	tuple1->items[6] = objectID->Clone();
	args0 = tuple1;
	
	res = new PyRepObject(
			"objectCaching.CachedObject",
			args0
		);
	

	return(res);
}

bool objectCaching_CachedObject_data::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool objectCaching_CachedObject_data::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_data failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "objectCaching.CachedObject") {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_data failed: obj_0 is the wrong object type. Expected 'objectCaching.CachedObject', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_data failed: tuple1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple1 = (PyRepTuple *) obj_0->arguments;
	if(tuple1->items.size() != 7) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_data failed: tuple1 is the wrong size: expected 7, but got %d", tuple1->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple1->items[0]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_data failed: tuple2 is the wrong type: %s", tuple1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple1->items[0];
	if(tuple2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_data failed: tuple2 is the wrong size: expected 2, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_data failed: timestamp is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_3 = (PyRepInteger *) tuple2->items[0];
	timestamp = int64_3->value;
	/*  1  */
	if(!tuple2->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_data failed: version is not an int: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple2->items[1];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode objectCaching_CachedObject_data: truncating 64 bit into into 32 bit int for field version");
	}
	version = int_4->value;
	/*  1  */
	if(!tuple1->items[1]->CheckType(PyRep::None)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_data failed: expecting a None but got a %s", tuple1->items[1]->TypeString());
		delete packet;
		return(false);
	}
	
	/*  2  */
	/*  2  */
	if(!tuple1->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_data failed: nodeID is not an int: %s", tuple1->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) tuple1->items[2];
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode objectCaching_CachedObject_data: truncating 64 bit into into 32 bit int for field nodeID");
	}
	nodeID = int_5->value;
	/*  3  */
	if(!tuple1->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_data failed: shared is not an int: %s", tuple1->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_6 = (PyRepInteger *) tuple1->items[3];
	if(int_6->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode objectCaching_CachedObject_data: truncating 64 bit into into 32 bit int for field shared");
	}
	shared = int_6->value;
	/*  4  */
	if(tuple1->items[4]->CheckType(PyRep::Buffer)) {
		data = (PyRepBuffer *) tuple1->items[4];
		tuple1->items[4] = NULL;
	} else if(tuple1->items[4]->CheckType(PyRep::String)) {
		PyRepString *__sss = (PyRepString *) tuple1->items[4];
		tuple1->items[4] = NULL;
		data = new PyRepBuffer((const byte *) __sss->value.c_str(), __sss->value.length());
		delete __sss;
	} else {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_data failed: data is not a buffer: %s", tuple1->items[4]->TypeString());
		delete packet;
		return(false);
	}
	
	/*  5  */
	if(!tuple1->items[5]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_data failed: compressed is not an int: %s", tuple1->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_7 = (PyRepInteger *) tuple1->items[5];
	if(int_7->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode objectCaching_CachedObject_data: truncating 64 bit into into 32 bit int for field compressed");
	}
	compressed = int_7->value;
	/*  6  */
	/*  either a string or a tuple  */
	objectID = tuple1->items[6];
	tuple1->items[6] = NULL;
	

	delete packet;
	return(true);
}

objectCaching_CachedObject_data *objectCaching_CachedObject_data::Clone() const {
	objectCaching_CachedObject_data *res = new objectCaching_CachedObject_data;
	/* object of type objectCaching.CachedObject */
	/*  0  */
	/*  0  */
	res->timestamp = timestamp;
	/*  1  */
	res->version = version;
	/*  1  */
	/*  2  */
	/*  2  */
	res->nodeID = nodeID;
	/*  3  */
	res->shared = shared;
	/*  4  */
	res->data = (PyRepBuffer *) data->Clone();
	/*  5  */
	res->compressed = compressed;
	/*  6  */
	/*  either a string or a tuple  */
	res->objectID = objectID->Clone();

	return(res);
}

objectCaching_CachedObject_spec::objectCaching_CachedObject_spec() {
	/* object of type util.CachedObject */
	/*  0  */
	objectID = NULL;
	/*  1  */
	nodeID = 0;
	/*  2  */
	/*  0  */
	timestamp = 0;
	/*  1  */
	version = 0;
}

objectCaching_CachedObject_spec::~objectCaching_CachedObject_spec() {
}

void objectCaching_CachedObject_spec::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sobjectCaching_CachedObject_spec", pfx);
	_log(l_type, "%sObject of type util.CachedObject:", pfx);
	/*  0  */
	_log(l_type, "%sobjectID: ", pfx);
	std::string objectID_n(pfx);
	objectID_n += "    ";
	objectID->Dump(l_type, objectID_n.c_str());
	/*  1  */
	_log(l_type, "%snodeID=%lu", pfx, nodeID);
	/*  2  */
	/*  0  */
	_log(l_type, "%stimestamp=" I64u, pfx, timestamp);
	/*  1  */
	_log(l_type, "%sversion=%lu", pfx, version);
}

PyRepObject *objectCaching_CachedObject_spec::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepTuple *tuple1 = new PyRepTuple(3);
	/*  0  */
	tuple1->items[0] = objectID->Clone();
	/*  1  */
	tuple1->items[1] = new PyRepInteger(nodeID);
	/*  2  */
	PyRepTuple *tuple2 = new PyRepTuple(2);
	/*  0  */
	tuple2->items[0] = new PyRepInteger(timestamp);
	/*  1  */
	tuple2->items[1] = new PyRepInteger(version);
	tuple1->items[2] = tuple2;
	
	args0 = tuple1;
	
	res = new PyRepObject(
			"util.CachedObject",
			args0
		);
	

	return(res);
}

bool objectCaching_CachedObject_spec::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool objectCaching_CachedObject_spec::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_spec failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "util.CachedObject") {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_spec failed: obj_0 is the wrong object type. Expected 'util.CachedObject', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_spec failed: tuple1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple1 = (PyRepTuple *) obj_0->arguments;
	if(tuple1->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_spec failed: tuple1 is the wrong size: expected 3, but got %d", tuple1->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	objectID = tuple1->items[0];
	tuple1->items[0] = NULL;
	
	/*  1  */
	if(!tuple1->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_spec failed: nodeID is not an int: %s", tuple1->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple1->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode objectCaching_CachedObject_spec: truncating 64 bit into into 32 bit int for field nodeID");
	}
	nodeID = int_2->value;
	/*  2  */
	if(!tuple1->items[2]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_spec failed: tuple3 is the wrong type: %s", tuple1->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple3 = (PyRepTuple *) tuple1->items[2];
	if(tuple3->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_spec failed: tuple3 is the wrong size: expected 2, but got %d", tuple3->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple3->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_spec failed: timestamp is not an int: %s", tuple3->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_4 = (PyRepInteger *) tuple3->items[0];
	timestamp = int64_4->value;
	/*  1  */
	if(!tuple3->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_spec failed: version is not an int: %s", tuple3->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) tuple3->items[1];
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode objectCaching_CachedObject_spec: truncating 64 bit into into 32 bit int for field version");
	}
	version = int_5->value;

	delete packet;
	return(true);
}

objectCaching_CachedObject_spec *objectCaching_CachedObject_spec::Clone() const {
	objectCaching_CachedObject_spec *res = new objectCaching_CachedObject_spec;
	/* object of type util.CachedObject */
	/*  0  */
	res->objectID = objectID->Clone();
	/*  1  */
	res->nodeID = nodeID;
	/*  2  */
	/*  0  */
	res->timestamp = timestamp;
	/*  1  */
	res->version = version;

	return(res);
}

util_Rowset::util_Rowset() {
	/* object of type util.Rowset */
	rowclass = "";
}

util_Rowset::~util_Rowset() {
}

void util_Rowset::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sutil_Rowset", pfx);
	_log(l_type, "%sObject of type util.Rowset:", pfx);
	_log(l_type, "%sheader: String list with %d enetires", pfx, header.size());
	std::vector<std::string>::const_iterator header_cur, header_end;
	header_cur = header.begin();
	header_end = header.end();
	int header_index;
	for(header_index = 0; header_cur != header_end; header_cur++, header_index++) {
		_log(l_type, "%s   [%02d] %s", pfx, header_index, (*header_cur).c_str());
	}
	
	_log(l_type, "%srowclass='%s'", pfx, rowclass.c_str());
	_log(l_type, "%slines: ", pfx);
	std::string lines_n(pfx);
	lines_n += "    ";
	lines.Dump(l_type, lines_n.c_str());
}

PyRepObject *util_Rowset::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	
	PyRepList *list2 = new PyRepList();
	std::vector<std::string>::iterator header_cur, header_end;
	header_cur = header.begin();
	header_end = header.end();
	for(; header_cur != header_end; header_cur++) {
		list2->items.push_back(
			new PyRepString(*header_cur)
		);
	}
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepString(rowclass);
	dict1->items[
		new PyRepString("RowClass")
	] = dict1_1;
	PyRep *dict1_2;
	dict1_2 = lines.Clone();
	dict1->items[
		new PyRepString("lines")
	] = dict1_2;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.Rowset",
			args0
		);
	

	return(res);
}

bool util_Rowset::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool util_Rowset::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode util_Rowset failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "util.Rowset") {
		_log(NET__PACKET_ERROR, "Decode util_Rowset failed: obj_0 is the wrong object type. Expected 'util.Rowset', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode util_Rowset failed: dict1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict1_header = false;
	bool dict1_rowclass = false;
	bool dict1_lines = false;
	PyRepDict *dict1 = (PyRepDict *) obj_0->arguments;
	
	PyRepDict::iterator dict1_cur, dict1_end;
	dict1_cur = dict1->items.begin();
	dict1_end = dict1->items.end();
	for(; dict1_cur != dict1_end; dict1_cur++) {
		PyRep *key = dict1_cur->first;
		if(!key->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode util_Rowset failed: a key in dict1 is the wrong type: %s", key->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string = (PyRepString *) key;
		
		if(key_string->value == "header") {
			dict1_header = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode util_Rowset failed: header is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	header.clear();
	PyRepList *list_2 = (PyRepList *) dict1_cur->second;
	PyRepList::iterator header_cur, header_end;
	header_cur = list_2->items.begin();
	header_end = list_2->items.end();
	int header_index;
	for(header_index = 0; header_cur != header_end; header_cur++, header_index++) {
		if(!(*header_cur)->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode util_Rowset failed: Element %d in list header is not a string: %s", header_index, (*header_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *t = (PyRepString *) (*header_cur);
		header.push_back(t->value);
	}

		} else
		if(key_string->value == "RowClass") {
			dict1_rowclass = true;
	if(!dict1_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode util_Rowset failed: rowclass is not a string: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) dict1_cur->second;
	rowclass = string_3->value;
		} else
		if(key_string->value == "lines") {
			dict1_lines = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode util_Rowset failed: lines is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_lines = (PyRepList *) dict1_cur->second;	lines.items = list_lines->items;
	list_lines->items.clear();
	
		} else
		{
			_log(NET__PACKET_ERROR, "Decode util_Rowset failed: Unknown key string '%s' in dict1", key_string->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict1_header) {
		_log(NET__PACKET_ERROR, "Decode util_Rowset failed: Missing dict entry for 'header' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_rowclass) {
		_log(NET__PACKET_ERROR, "Decode util_Rowset failed: Missing dict entry for 'rowclass' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_lines) {
		_log(NET__PACKET_ERROR, "Decode util_Rowset failed: Missing dict entry for 'lines' in dict1");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

util_Rowset *util_Rowset::Clone() const {
	util_Rowset *res = new util_Rowset;
	/* object of type util.Rowset */
	res->header = header;
	res->rowclass = rowclass;
	res->lines.CloneFrom(&lines);

	return(res);
}

list_rowset::list_rowset() {
	/*  0  */
	/*  1  */
	/*  each element of this list is a list itself, with one element per element in header  */
}

list_rowset::~list_rowset() {
	/*  0  */
	/*  1  */
	/*  each element of this list is a list itself, with one element per element in header  */
}

void list_rowset::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%slist_rowset", pfx);
	/*  0  */
	_log(l_type, "%sheader: String list with %d enetires", pfx, header.size());
	std::vector<std::string>::const_iterator header_cur, header_end;
	header_cur = header.begin();
	header_end = header.end();
	int header_index;
	for(header_index = 0; header_cur != header_end; header_cur++, header_index++) {
		_log(l_type, "%s   [%02d] %s", pfx, header_index, (*header_cur).c_str());
	}
	
	/*  1  */
	/*  each element of this list is a list itself, with one element per element in header  */
	_log(l_type, "%slines: ", pfx);
	std::string lines_n(pfx);
	lines_n += "    ";
	lines.Dump(l_type, lines_n.c_str());
}

PyRepTuple *list_rowset::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	
	PyRepList *list1 = new PyRepList();
	std::vector<std::string>::iterator header_cur, header_end;
	header_cur = header.begin();
	header_end = header.end();
	for(; header_cur != header_end; header_cur++) {
		list1->items.push_back(
			new PyRepString(*header_cur)
		);
	}
	tuple0->items[0] = list1;
	
	/*  1  */
	/*  each element of this list is a list itself, with one element per element in header  */
	tuple0->items[1] = lines.Clone();
	res = tuple0;
	

	return(res);
}

bool list_rowset::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool list_rowset::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode list_rowset failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode list_rowset failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode list_rowset failed: header is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	header.clear();
	PyRepList *list_1 = (PyRepList *) tuple0->items[0];
	PyRepList::iterator header_cur, header_end;
	header_cur = list_1->items.begin();
	header_end = list_1->items.end();
	int header_index;
	for(header_index = 0; header_cur != header_end; header_cur++, header_index++) {
		if(!(*header_cur)->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode list_rowset failed: Element %d in list header is not a string: %s", header_index, (*header_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *t = (PyRepString *) (*header_cur);
		header.push_back(t->value);
	}

	/*  1  */
	/*  each element of this list is a list itself, with one element per element in header  */
	if(!tuple0->items[1]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode list_rowset failed: lines is not a list: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_lines = (PyRepList *) tuple0->items[1];	lines.items = list_lines->items;
	list_lines->items.clear();
	

	delete packet;
	return(true);
}

list_rowset *list_rowset::Clone() const {
	list_rowset *res = new list_rowset;
	/*  0  */
	res->header = header;
	/*  1  */
	/*  each element of this list is a list itself, with one element per element in header  */
	res->lines.CloneFrom(&lines);

	return(res);
}

objectCaching_CachedMethodCallResult::objectCaching_CachedMethodCallResult() {
	/* object of type objectCaching.CachedMethodCallResult */
	/*  0  */
	string0 = "";
	/*  0  */
	string1 = "";
	/*  1  */
	/*  2  */
	/*  1  */
	call_return = NULL;
	/*  2  */
	/*  0  */
	integer7 = 0;
	/*  1  */
	integer8 = 0;
}

objectCaching_CachedMethodCallResult::~objectCaching_CachedMethodCallResult() {
}

void objectCaching_CachedMethodCallResult::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sobjectCaching_CachedMethodCallResult", pfx);
	_log(l_type, "%sObject of type objectCaching.CachedMethodCallResult:", pfx);
	/*  0  */
	_log(l_type, "%sstring0='%s'", pfx, string0.c_str());
	/*  0  */
	_log(l_type, "%sstring1='%s'", pfx, string1.c_str());
	/*  1  */
	/*  2  */
	/*  1  */
	_log(l_type, "%scall_return: ", pfx);
	std::string call_return_n(pfx);
	call_return_n += "    ";
	call_return->Dump(l_type, call_return_n.c_str());
	/*  2  */
	/*  0  */
	_log(l_type, "%sinteger7=" I64u, pfx, integer7);
	/*  1  */
	_log(l_type, "%sinteger8=%lu", pfx, integer8);
}

PyRepObject *objectCaching_CachedMethodCallResult::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepTuple *tuple1 = new PyRepTuple(3);
	/*  0  */
	PyRepDict *dict2 = new PyRepDict();
	PyRep *dict2_0;
	dict2_0 = new PyRepString(string0);
	dict2->items[
		new PyRepString("sessionInfo")
	] = dict2_0;
	PyRep *dict2_1;
	PyRepTuple *tuple3 = new PyRepTuple(3);
	/*  0  */
	tuple3->items[0] = new PyRepString(string1);
	/*  1  */
	tuple3->items[1] = new PyRepNone();
	/*  2  */
	tuple3->items[2] = new PyRepNone();
	dict2_1 = tuple3;
	
	dict2->items[
		new PyRepString("versionCheck")
	] = dict2_1;
	tuple1->items[0] = dict2;
	
	/*  1  */
	PyRep *ss_4;
	ss_4 = call_return->Clone();
	tuple1->items[1] = new PyRepSubStream(ss_4);
	/*  2  */
	PyRepList *list5 = new PyRepList();
	list5->items.resize(2, NULL);
	/*  0  */
	list5->items[0] = new PyRepInteger(integer7);
	/*  1  */
	list5->items[1] = new PyRepInteger(integer8);
	tuple1->items[2] = list5;
	
	args0 = tuple1;
	
	res = new PyRepObject(
			"objectCaching.CachedMethodCallResult",
			args0
		);
	

	return(res);
}

bool objectCaching_CachedMethodCallResult::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool objectCaching_CachedMethodCallResult::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "objectCaching.CachedMethodCallResult") {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: obj_0 is the wrong object type. Expected 'objectCaching.CachedMethodCallResult', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: tuple1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple1 = (PyRepTuple *) obj_0->arguments;
	if(tuple1->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: tuple1 is the wrong size: expected 3, but got %d", tuple1->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple1->items[0]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: dict2 is the wrong type: %s", tuple1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	bool dict2_string0 = false;
	bool dict2_versionCheck = false;
	PyRepDict *dict2 = (PyRepDict *) tuple1->items[0];
	
	PyRepDict::iterator dict2_cur, dict2_end;
	dict2_cur = dict2->items.begin();
	dict2_end = dict2->items.end();
	for(; dict2_cur != dict2_end; dict2_cur++) {
		PyRep *key = dict2_cur->first;
		if(!key->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: a key in dict2 is the wrong type: %s", key->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string = (PyRepString *) key;
		
		if(key_string->value == "sessionInfo") {
			dict2_string0 = true;
	if(!dict2_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: string0 is not a string: %s", dict2_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) dict2_cur->second;
	string0 = string_3->value;
		} else
		if(key_string->value == "versionCheck") {
			dict2_versionCheck = true;
	if(!dict2_cur->second->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: tuple4 is the wrong type: %s", dict2_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple4 = (PyRepTuple *) dict2_cur->second;
	if(tuple4->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: tuple4 is the wrong size: expected 3, but got %d", tuple4->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple4->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: string1 is not a string: %s", tuple4->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_5 = (PyRepString *) tuple4->items[0];
	string1 = string_5->value;
	/*  1  */
	if(!tuple4->items[1]->CheckType(PyRep::None)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: expecting a None but got a %s", tuple4->items[1]->TypeString());
		delete packet;
		return(false);
	}
	
	/*  2  */
	if(!tuple4->items[2]->CheckType(PyRep::None)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: expecting a None but got a %s", tuple4->items[2]->TypeString());
		delete packet;
		return(false);
	}
	
		} else
		{
			_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: Unknown key string '%s' in dict2", key_string->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict2_string0) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: Missing dict entry for 'string0' in dict2");
		delete packet;
		return(false);
	}
	
	if(!dict2_versionCheck) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: Missing dict entry for 'versionCheck' in dict2");
		delete packet;
		return(false);
	}
	
	/*  1  */
	if(!tuple1->items[1]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: ss_6 is not a substream: %s", tuple1->items[1]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_6 = (PyRepSubStream *) tuple1->items[1];
	//make sure its decoded
	ss_6->DecodeData();
	if(ss_6->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: Unable to decode ss_6");
		delete packet;
		return(false);
	}
	
	call_return = ss_6->decoded;
	ss_6->decoded = NULL;
	
	/*  2  */
	if(!tuple1->items[2]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: list7 is not a list: %s", tuple1->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list7 = (PyRepList *) tuple1->items[2];
	if(list7->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: list7 is the wrong size: expected 2, but got %d", list7->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!list7->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: integer7 is not an int: %s", list7->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_8 = (PyRepInteger *) list7->items[0];
	integer7 = int64_8->value;
	/*  1  */
	if(!list7->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: integer8 is not an int: %s", list7->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_9 = (PyRepInteger *) list7->items[1];
	if(int_9->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode objectCaching_CachedMethodCallResult: truncating 64 bit into into 32 bit int for field integer8");
	}
	integer8 = int_9->value;

	delete packet;
	return(true);
}

objectCaching_CachedMethodCallResult *objectCaching_CachedMethodCallResult::Clone() const {
	objectCaching_CachedMethodCallResult *res = new objectCaching_CachedMethodCallResult;
	/* object of type objectCaching.CachedMethodCallResult */
	/*  0  */
	res->string0 = string0;
	/*  0  */
	res->string1 = string1;
	/*  1  */
	/*  2  */
	/*  1  */
	res->call_return = call_return->Clone();
	/*  2  */
	/*  0  */
	res->integer7 = integer7;
	/*  1  */
	res->integer8 = integer8;

	return(res);
}
	/*  
empty calls:
CallPing
CallGetPostAuthenticationMessage
CallGetCharactersToSelect
CallGetCharCreationInfo
CallGetAttributeTypes
CallShipGetInfo
CallCharGetInfo
CallGetMyKillRights
CallGetBookmarks
CallGetChannels
CallGetInitialState
CallGetMyMessages
CallGetFactionInfo
CallGetStuckSystems
CallGetOwnerNoteLabels
CallGetStationItemBits
CallGetStationExtraInfo
CallGetCorporateStationInfo
CallGetCorporation
CallList (inventory)
CallGetAgents
CallGetGuests
 */

CallGetCachableObject::CallGetCachableObject() {
	/*  0  */
	shared = 0;
	/*  1  */
	/*  either a string or a tuple  */
	objectID = NULL;
	/*  2  */
	/*  0  */
	timestamp = 0;
	/*  1  */
	version = 0;
	/*  3  */
	nodeID = 0;
}

CallGetCachableObject::~CallGetCachableObject() {
	/*  0  */
	/*  1  */
	/*  either a string or a tuple  */
	delete objectID;
	/*  2  */
	/*  0  */
	/*  1  */
	/*  3  */
}

void CallGetCachableObject::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallGetCachableObject", pfx);
	/*  0  */
	_log(l_type, "%sshared=%lu", pfx, shared);
	/*  1  */
	/*  either a string or a tuple  */
	_log(l_type, "%sobjectID: ", pfx);
	std::string objectID_n(pfx);
	objectID_n += "    ";
	objectID->Dump(l_type, objectID_n.c_str());
	/*  2  */
	/*  0  */
	_log(l_type, "%stimestamp=" I64u, pfx, timestamp);
	/*  1  */
	_log(l_type, "%sversion=%lu", pfx, version);
	/*  3  */
	_log(l_type, "%snodeID=%lu", pfx, nodeID);
}

PyRepTuple *CallGetCachableObject::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(4);
	/*  0  */
	tuple0->items[0] = new PyRepInteger(shared);
	/*  1  */
	/*  either a string or a tuple  */
	tuple0->items[1] = objectID->Clone();
	/*  2  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	/*  0  */
	tuple1->items[0] = new PyRepInteger(timestamp);
	/*  1  */
	tuple1->items[1] = new PyRepInteger(version);
	tuple0->items[2] = tuple1;
	
	/*  3  */
	tuple0->items[3] = new PyRepInteger(nodeID);
	res = tuple0;
	

	return(res);
}

bool CallGetCachableObject::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallGetCachableObject::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallGetCachableObject failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 4) {
		_log(NET__PACKET_ERROR, "Decode CallGetCachableObject failed: tuple0 is the wrong size: expected 4, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallGetCachableObject failed: shared is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallGetCachableObject: truncating 64 bit into into 32 bit int for field shared");
	}
	shared = int_1->value;
	/*  1  */
	/*  either a string or a tuple  */
	objectID = tuple0->items[1];
	tuple0->items[1] = NULL;
	
	/*  2  */
	if(!tuple0->items[2]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallGetCachableObject failed: tuple2 is the wrong type: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[2];
	if(tuple2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode CallGetCachableObject failed: tuple2 is the wrong size: expected 2, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallGetCachableObject failed: timestamp is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_3 = (PyRepInteger *) tuple2->items[0];
	timestamp = int64_3->value;
	/*  1  */
	if(!tuple2->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallGetCachableObject failed: version is not an int: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple2->items[1];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallGetCachableObject: truncating 64 bit into into 32 bit int for field version");
	}
	version = int_4->value;
	/*  3  */
	if(!tuple0->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallGetCachableObject failed: nodeID is not an int: %s", tuple0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) tuple0->items[3];
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallGetCachableObject: truncating 64 bit into into 32 bit int for field nodeID");
	}
	nodeID = int_5->value;

	delete packet;
	return(true);
}

CallGetCachableObject *CallGetCachableObject::Clone() const {
	CallGetCachableObject *res = new CallGetCachableObject;
	/*  0  */
	res->shared = shared;
	/*  1  */
	/*  either a string or a tuple  */
	res->objectID = objectID->Clone();
	/*  2  */
	/*  0  */
	res->timestamp = timestamp;
	/*  1  */
	res->version = version;
	/*  3  */
	res->nodeID = nodeID;

	return(res);
}

RspGetCachableObject::RspGetCachableObject() {
	/*  0  */
	object = NULL;
}

RspGetCachableObject::~RspGetCachableObject() {
	/*  0  */
	delete object;
}

void RspGetCachableObject::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspGetCachableObject", pfx);
	/*  0  */
	_log(l_type, "%sobject:", pfx);
	std::string object_n(pfx);
	object_n += "    ";
	object->Dump(l_type, object_n.c_str());
}

PyRepTuple *RspGetCachableObject::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	ss_1 = object->Encode();
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspGetCachableObject::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspGetCachableObject::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCachableObject failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspGetCachableObject failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCachableObject failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspGetCachableObject failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	PyRep *rep_2 = ss_1->decoded;
	ss_1->decoded = NULL;
	delete object;
	object = new objectCaching_CachedObject_spec;
	if(!object->Decode(&rep_2)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCachableObject failed: unable to decode element object");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

RspGetCachableObject *RspGetCachableObject::Clone() const {
	RspGetCachableObject *res = new RspGetCachableObject;
	/*  0  */
	res->object = object->Clone();

	return(res);
}

RspPing::RspPing() {
	/*  0  */
	timestamp = 0;
}

RspPing::~RspPing() {
	/*  0  */
}

void RspPing::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspPing", pfx);
	/*  0  */
	_log(l_type, "%stimestamp=" I64u, pfx, timestamp);
}

PyRepTuple *RspPing::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	ss_1 = new PyRepInteger(timestamp);
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspPing::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspPing::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspPing failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspPing failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspPing failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspPing failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	if(!ss_1->decoded->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode RspPing failed: timestamp is not an int: %s", ss_1->decoded->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_2 = (PyRepInteger *) ss_1->decoded;
	timestamp = int64_2->value;

	delete packet;
	return(true);
}

RspPing *RspPing::Clone() const {
	RspPing *res = new RspPing;
	/*  0  */
	res->timestamp = timestamp;

	return(res);
}

RspGetPostAuthenticationMessage::RspGetPostAuthenticationMessage() {
	/*  0  */
	/* object of type util.KeyVal */
	message = "";
	showStatusBar = 0;
	center = 0;
	showAddressBar = 0;
	url = "";
	showOptions = 0;
	showButtons = 0;
	showModal = 0;
}

RspGetPostAuthenticationMessage::~RspGetPostAuthenticationMessage() {
	/*  0  */
}

void RspGetPostAuthenticationMessage::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspGetPostAuthenticationMessage", pfx);
	/*  0  */
	_log(l_type, "%sObject of type util.KeyVal:", pfx);
	_log(l_type, "%smessage='%s'", pfx, message.c_str());
	_log(l_type, "%sshowStatusBar=%lu", pfx, showStatusBar);
	_log(l_type, "%scenter=%lu", pfx, center);
	_log(l_type, "%sshowAddressBar=%lu", pfx, showAddressBar);
	_log(l_type, "%surl='%s'", pfx, url.c_str());
	_log(l_type, "%sshowOptions=%lu", pfx, showOptions);
	_log(l_type, "%sshowButtons=%lu", pfx, showButtons);
	_log(l_type, "%sshowModal=%lu", pfx, showModal);
}

PyRepTuple *RspGetPostAuthenticationMessage::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	PyRep *args2;
	PyRepDict *dict3 = new PyRepDict();
	PyRep *dict3_0;
	dict3_0 = new PyRepString(message);
	dict3->items[
		new PyRepString("message")
	] = dict3_0;
	PyRep *dict3_1;
	PyRepDict *dict4 = new PyRepDict();
	PyRep *dict4_0;
	dict4_0 = new PyRepInteger(showStatusBar);
	dict4->items[
		new PyRepString("showStatusBar")
	] = dict4_0;
	PyRep *dict4_1;
	dict4_1 = new PyRepInteger(center);
	dict4->items[
		new PyRepString("center")
	] = dict4_1;
	PyRep *dict4_2;
	dict4_2 = new PyRepInteger(showAddressBar);
	dict4->items[
		new PyRepString("showAddressBar")
	] = dict4_2;
	PyRep *dict4_3;
	dict4_3 = new PyRepString(url);
	dict4->items[
		new PyRepString("url")
	] = dict4_3;
	PyRep *dict4_4;
	dict4_4 = new PyRepInteger(showOptions);
	dict4->items[
		new PyRepString("showOptions")
	] = dict4_4;
	PyRep *dict4_5;
	dict4_5 = new PyRepInteger(showButtons);
	dict4->items[
		new PyRepString("showButtons")
	] = dict4_5;
	PyRep *dict4_6;
	dict4_6 = new PyRepInteger(showModal);
	dict4->items[
		new PyRepString("showModal")
	] = dict4_6;
	dict3_1 = dict4;
	
	dict3->items[
		new PyRepString("args")
	] = dict3_1;
	args2 = dict3;
	
	ss_1 = new PyRepObject(
			"util.KeyVal",
			args2
		);
	
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspGetPostAuthenticationMessage::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspGetPostAuthenticationMessage::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	if(!ss_1->decoded->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: obj_2 is the wrong type: %s", ss_1->decoded->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_2 = (PyRepObject *) ss_1->decoded;
	
	if(obj_2->type != "util.KeyVal") {
		_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: obj_2 is the wrong object type. Expected 'util.KeyVal', got '%s'", obj_2->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_2->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: dict3 is the wrong type: %s", obj_2->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict3_message = false;
	bool dict3_args = false;
	PyRepDict *dict3 = (PyRepDict *) obj_2->arguments;
	
	PyRepDict::iterator dict3_cur, dict3_end;
	dict3_cur = dict3->items.begin();
	dict3_end = dict3->items.end();
	for(; dict3_cur != dict3_end; dict3_cur++) {
		PyRep *key = dict3_cur->first;
		if(!key->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: a key in dict3 is the wrong type: %s", key->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string = (PyRepString *) key;
		
		if(key_string->value == "message") {
			dict3_message = true;
	if(!dict3_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: message is not a string: %s", dict3_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_4 = (PyRepString *) dict3_cur->second;
	message = string_4->value;
		} else
		if(key_string->value == "args") {
			dict3_args = true;
	if(!dict3_cur->second->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: dict5 is the wrong type: %s", dict3_cur->second->TypeString());
		delete packet;
		return(false);
	}
	bool dict5_showStatusBar = false;
	bool dict5_center = false;
	bool dict5_showAddressBar = false;
	bool dict5_url = false;
	bool dict5_showOptions = false;
	bool dict5_showButtons = false;
	bool dict5_showModal = false;
	PyRepDict *dict5 = (PyRepDict *) dict3_cur->second;
	
	PyRepDict::iterator dict5_cur, dict5_end;
	dict5_cur = dict5->items.begin();
	dict5_end = dict5->items.end();
	for(; dict5_cur != dict5_end; dict5_cur++) {
		PyRep *key = dict5_cur->first;
		if(!key->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: a key in dict5 is the wrong type: %s", key->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string = (PyRepString *) key;
		
		if(key_string->value == "showStatusBar") {
			dict5_showStatusBar = true;
	if(!dict5_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: showStatusBar is not an int: %s", dict5_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_6 = (PyRepInteger *) dict5_cur->second;
	if(int_6->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode RspGetPostAuthenticationMessage: truncating 64 bit into into 32 bit int for field showStatusBar");
	}
	showStatusBar = int_6->value;
		} else
		if(key_string->value == "center") {
			dict5_center = true;
	if(!dict5_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: center is not an int: %s", dict5_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_7 = (PyRepInteger *) dict5_cur->second;
	if(int_7->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode RspGetPostAuthenticationMessage: truncating 64 bit into into 32 bit int for field center");
	}
	center = int_7->value;
		} else
		if(key_string->value == "showAddressBar") {
			dict5_showAddressBar = true;
	if(!dict5_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: showAddressBar is not an int: %s", dict5_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_8 = (PyRepInteger *) dict5_cur->second;
	if(int_8->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode RspGetPostAuthenticationMessage: truncating 64 bit into into 32 bit int for field showAddressBar");
	}
	showAddressBar = int_8->value;
		} else
		if(key_string->value == "url") {
			dict5_url = true;
	if(!dict5_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: url is not a string: %s", dict5_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_9 = (PyRepString *) dict5_cur->second;
	url = string_9->value;
		} else
		if(key_string->value == "showOptions") {
			dict5_showOptions = true;
	if(!dict5_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: showOptions is not an int: %s", dict5_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_10 = (PyRepInteger *) dict5_cur->second;
	if(int_10->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode RspGetPostAuthenticationMessage: truncating 64 bit into into 32 bit int for field showOptions");
	}
	showOptions = int_10->value;
		} else
		if(key_string->value == "showButtons") {
			dict5_showButtons = true;
	if(!dict5_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: showButtons is not an int: %s", dict5_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_11 = (PyRepInteger *) dict5_cur->second;
	if(int_11->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode RspGetPostAuthenticationMessage: truncating 64 bit into into 32 bit int for field showButtons");
	}
	showButtons = int_11->value;
		} else
		if(key_string->value == "showModal") {
			dict5_showModal = true;
	if(!dict5_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: showModal is not an int: %s", dict5_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_12 = (PyRepInteger *) dict5_cur->second;
	if(int_12->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode RspGetPostAuthenticationMessage: truncating 64 bit into into 32 bit int for field showModal");
	}
	showModal = int_12->value;
		} else
		{
			_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: Unknown key string '%s' in dict5", key_string->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict5_showStatusBar) {
		_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: Missing dict entry for 'showStatusBar' in dict5");
		delete packet;
		return(false);
	}
	
	if(!dict5_center) {
		_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: Missing dict entry for 'center' in dict5");
		delete packet;
		return(false);
	}
	
	if(!dict5_showAddressBar) {
		_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: Missing dict entry for 'showAddressBar' in dict5");
		delete packet;
		return(false);
	}
	
	if(!dict5_url) {
		_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: Missing dict entry for 'url' in dict5");
		delete packet;
		return(false);
	}
	
	if(!dict5_showOptions) {
		_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: Missing dict entry for 'showOptions' in dict5");
		delete packet;
		return(false);
	}
	
	if(!dict5_showButtons) {
		_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: Missing dict entry for 'showButtons' in dict5");
		delete packet;
		return(false);
	}
	
	if(!dict5_showModal) {
		_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: Missing dict entry for 'showModal' in dict5");
		delete packet;
		return(false);
	}
	
		} else
		{
			_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: Unknown key string '%s' in dict3", key_string->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict3_message) {
		_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: Missing dict entry for 'message' in dict3");
		delete packet;
		return(false);
	}
	
	if(!dict3_args) {
		_log(NET__PACKET_ERROR, "Decode RspGetPostAuthenticationMessage failed: Missing dict entry for 'args' in dict3");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

RspGetPostAuthenticationMessage *RspGetPostAuthenticationMessage::Clone() const {
	RspGetPostAuthenticationMessage *res = new RspGetPostAuthenticationMessage;
	/*  0  */
	/* object of type util.KeyVal */
	res->message = message;
	res->showStatusBar = showStatusBar;
	res->center = center;
	res->showAddressBar = showAddressBar;
	res->url = url;
	res->showOptions = showOptions;
	res->showButtons = showButtons;
	res->showModal = showModal;

	return(res);
}

RspGetCharactersToSelect::RspGetCharactersToSelect() {
	/*  0  */
	chars = NULL;
}

RspGetCharactersToSelect::~RspGetCharactersToSelect() {
	/*  0  */
	delete chars;
}

void RspGetCharactersToSelect::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspGetCharactersToSelect", pfx);
	/*  0  */
	_log(l_type, "%schars:", pfx);
	std::string chars_n(pfx);
	chars_n += "    ";
	chars->Dump(l_type, chars_n.c_str());
}

PyRepTuple *RspGetCharactersToSelect::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	ss_1 = chars->Encode();
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspGetCharactersToSelect::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspGetCharactersToSelect::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharactersToSelect failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharactersToSelect failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharactersToSelect failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharactersToSelect failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	PyRep *rep_2 = ss_1->decoded;
	ss_1->decoded = NULL;
	delete chars;
	chars = new util_Rowset;
	if(!chars->Decode(&rep_2)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharactersToSelect failed: unable to decode element chars");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

RspGetCharactersToSelect *RspGetCharactersToSelect::Clone() const {
	RspGetCharactersToSelect *res = new RspGetCharactersToSelect;
	/*  0  */
	res->chars = chars->Clone();

	return(res);
}

CallGetCharacterToSelect::CallGetCharacterToSelect() {
	/*  0  */
	charID = 0;
}

CallGetCharacterToSelect::~CallGetCharacterToSelect() {
	/*  0  */
}

void CallGetCharacterToSelect::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallGetCharacterToSelect", pfx);
	/*  0  */
	_log(l_type, "%scharID=%lu", pfx, charID);
}

PyRepTuple *CallGetCharacterToSelect::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	tuple0->items[0] = new PyRepInteger(charID);
	res = tuple0;
	

	return(res);
}

bool CallGetCharacterToSelect::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallGetCharacterToSelect::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallGetCharacterToSelect failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode CallGetCharacterToSelect failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallGetCharacterToSelect failed: charID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallGetCharacterToSelect: truncating 64 bit into into 32 bit int for field charID");
	}
	charID = int_1->value;

	delete packet;
	return(true);
}

CallGetCharacterToSelect *CallGetCharacterToSelect::Clone() const {
	CallGetCharacterToSelect *res = new CallGetCharacterToSelect;
	/*  0  */
	res->charID = charID;

	return(res);
}

RspGetCharacterToSelect::RspGetCharacterToSelect() {
	/*  0  */
	character = NULL;
}

RspGetCharacterToSelect::~RspGetCharacterToSelect() {
	/*  0  */
	delete character;
}

void RspGetCharacterToSelect::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspGetCharacterToSelect", pfx);
	/*  0  */
	_log(l_type, "%scharacter:", pfx);
	std::string character_n(pfx);
	character_n += "    ";
	character->Dump(l_type, character_n.c_str());
}

PyRepTuple *RspGetCharacterToSelect::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	ss_1 = character->Encode();
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspGetCharacterToSelect::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspGetCharacterToSelect::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharacterToSelect failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharacterToSelect failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharacterToSelect failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharacterToSelect failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	PyRep *rep_2 = ss_1->decoded;
	ss_1->decoded = NULL;
	delete character;
	character = new util_Rowset;
	if(!character->Decode(&rep_2)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharacterToSelect failed: unable to decode element character");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

RspGetCharacterToSelect *RspGetCharacterToSelect::Clone() const {
	RspGetCharacterToSelect *res = new RspGetCharacterToSelect;
	/*  0  */
	res->character = character->Clone();

	return(res);
}

RspGetCharCreationInfo::RspGetCharCreationInfo() {
	/*  0  */
}

RspGetCharCreationInfo::~RspGetCharCreationInfo() {
	/*  0  */
	std::map<std::string, PyRep *>::iterator caches_cur, caches_end;
	//free any existing elements first
	caches_cur = caches.begin();
	caches_end = caches.end();
	for(; caches_cur != caches_end; caches_cur++) {
		delete caches_cur->second;
	}
	
}

void RspGetCharCreationInfo::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspGetCharCreationInfo", pfx);
	/*  0  */
	_log(l_type, "%scaches: Dictionaty with %d enetires", pfx, caches.size());
	std::map<std::string, PyRep *>::const_iterator caches_cur, caches_end;
	caches_cur = caches.begin();
	caches_end = caches.end();
	for(; caches_cur != caches_end; caches_cur++) {
		_log(l_type, "%s Key: %s", pfx, caches_cur->first.c_str());
		std::string n(pfx);
		n += "      ";
		caches_cur->second->Dump(stdout, n.c_str());
	}
	
}

PyRepTuple *RspGetCharCreationInfo::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	
	PyRepDict *dict2 = new PyRepDict();
	std::map<std::string, PyRep *>::iterator caches_cur, caches_end;
	caches_cur = caches.begin();
	caches_end = caches.end();
	for(; caches_cur != caches_end; caches_cur++) {
		dict2->items[
			new PyRepString(caches_cur->first)
		] = caches_cur->second->Clone();
	}
	ss_1 = dict2;
	
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspGetCharCreationInfo::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspGetCharCreationInfo::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharCreationInfo failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharCreationInfo failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharCreationInfo failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharCreationInfo failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	if(!ss_1->decoded->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharCreationInfo failed: caches is not a dict: %s", ss_1->decoded->TypeString());
		delete packet;
		return(false);
	}
	caches.clear();
	PyRepDict *dict_2 = (PyRepDict *) ss_1->decoded;
	PyRepDict::iterator caches_cur, caches_end;
	caches_cur = dict_2->items.begin();
	caches_end = dict_2->items.end();
	int caches_index;
	for(caches_index = 0; caches_cur != caches_end; caches_cur++, caches_index++) {
		if(!caches_cur->first->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode RspGetCharCreationInfo failed: Key %d in dict caches is not a string: %s", caches_index, caches_cur->first->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *k = (PyRepString *) caches_cur->first;
		caches[k->value] = caches_cur->second->Clone();
	}
	

	delete packet;
	return(true);
}

RspGetCharCreationInfo *RspGetCharCreationInfo::Clone() const {
	RspGetCharCreationInfo *res = new RspGetCharCreationInfo;
	/*  0  */
	std::map<std::string, PyRep *>::const_iterator caches_cur, caches_end;
	//free any existing elements first
	caches_cur = res->caches.begin();
	caches_end = res->caches.end();
	for(; caches_cur != caches_end; caches_cur++) {
		delete caches_cur->second;
	}
	res->caches.clear();
	//now we can copy in the new ones...
	caches_cur = caches.begin();
	caches_end = caches.end();
	for(; caches_cur != caches_end; caches_cur++) {
		res->caches[caches_cur->first] = caches_cur->second->Clone();
	}
	

	return(res);
}

CallGetMultiOwnersEx::CallGetMultiOwnersEx() {
	/*  0  */
}

CallGetMultiOwnersEx::~CallGetMultiOwnersEx() {
	/*  0  */
}

void CallGetMultiOwnersEx::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallGetMultiOwnersEx", pfx);
	/*  0  */
	_log(l_type, "%sentities: Integer list with %d enetires", pfx, entities.size());
	std::vector<uint32>::const_iterator entities_cur, entities_end;
	entities_cur = entities.begin();
	entities_end = entities.end();
	int entities_index;
	for(entities_index = 0; entities_cur != entities_end; entities_cur++, entities_index++) {
		_log(l_type, "%s   [%02d] %d", pfx, entities_index, *entities_cur);
	}
	
}

PyRepTuple *CallGetMultiOwnersEx::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator entities_cur, entities_end;
	entities_cur = entities.begin();
	entities_end = entities.end();
	for(; entities_cur != entities_end; entities_cur++) {
		list1->items.push_back(
			new PyRepInteger(*entities_cur)
		);
	}
	tuple0->items[0] = list1;
	
	res = tuple0;
	

	return(res);
}

bool CallGetMultiOwnersEx::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallGetMultiOwnersEx::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallGetMultiOwnersEx failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode CallGetMultiOwnersEx failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode CallGetMultiOwnersEx failed: entities is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	entities.clear();
	PyRepList *list_1 = (PyRepList *) tuple0->items[0];
	PyRepList::iterator entities_cur, entities_end;
	entities_cur = list_1->items.begin();
	entities_end = list_1->items.end();
	int entities_index;
	for(entities_index = 0; entities_cur != entities_end; entities_cur++, entities_index++) {
		if(!(*entities_cur)->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode CallGetMultiOwnersEx failed: Element %d in list entities is not an integer: %s", entities_index, (*entities_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *t = (PyRepInteger *) (*entities_cur);
		if(t->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode CallGetMultiOwnersEx: truncating 64 bit into into 32 bit int for item %d in field entities", entities_index);
		}
		entities.push_back(t->value);
	}


	delete packet;
	return(true);
}

CallGetMultiOwnersEx *CallGetMultiOwnersEx::Clone() const {
	CallGetMultiOwnersEx *res = new CallGetMultiOwnersEx;
	/*  0  */
	res->entities = entities;

	return(res);
}

RspGetMultiOwnersEx::RspGetMultiOwnersEx() {
	/*  0  */
	rowset = NULL;
}

RspGetMultiOwnersEx::~RspGetMultiOwnersEx() {
	/*  0  */
	delete rowset;
}

void RspGetMultiOwnersEx::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspGetMultiOwnersEx", pfx);
	/*  0  */
	_log(l_type, "%srowset:", pfx);
	std::string rowset_n(pfx);
	rowset_n += "    ";
	rowset->Dump(l_type, rowset_n.c_str());
}

PyRepTuple *RspGetMultiOwnersEx::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	ss_1 = rowset->Encode();
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspGetMultiOwnersEx::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspGetMultiOwnersEx::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetMultiOwnersEx failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspGetMultiOwnersEx failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspGetMultiOwnersEx failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspGetMultiOwnersEx failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	PyRep *rep_2 = ss_1->decoded;
	ss_1->decoded = NULL;
	delete rowset;
	rowset = new list_rowset;
	if(!rowset->Decode(&rep_2)) {
		_log(NET__PACKET_ERROR, "Decode RspGetMultiOwnersEx failed: unable to decode element rowset");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

RspGetMultiOwnersEx *RspGetMultiOwnersEx::Clone() const {
	RspGetMultiOwnersEx *res = new RspGetMultiOwnersEx;
	/*  0  */
	res->rowset = rowset->Clone();

	return(res);
}

CallSelectCharacterID::CallSelectCharacterID() {
	/*  0  */
	charID = 0;
}

CallSelectCharacterID::~CallSelectCharacterID() {
	/*  0  */
}

void CallSelectCharacterID::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallSelectCharacterID", pfx);
	/*  0  */
	_log(l_type, "%scharID=%lu", pfx, charID);
}

PyRepTuple *CallSelectCharacterID::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	tuple0->items[0] = new PyRepInteger(charID);
	res = tuple0;
	

	return(res);
}

bool CallSelectCharacterID::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallSelectCharacterID::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallSelectCharacterID failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode CallSelectCharacterID failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallSelectCharacterID failed: charID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallSelectCharacterID: truncating 64 bit into into 32 bit int for field charID");
	}
	charID = int_1->value;

	delete packet;
	return(true);
}

CallSelectCharacterID *CallSelectCharacterID::Clone() const {
	CallSelectCharacterID *res = new CallSelectCharacterID;
	/*  0  */
	res->charID = charID;

	return(res);
}

NotifyOnAggressionChange::NotifyOnAggressionChange() {
	/*  0  */
	integer0 = 0;
	/*  1  */
	/*  maps _something_ to a timestamp  */
}

NotifyOnAggressionChange::~NotifyOnAggressionChange() {
	/*  0  */
	/*  1  */
	/*  maps _something_ to a timestamp  */
	std::map<uint32, PyRep *>::iterator entries_cur, entries_end;
	//free any existing elements first
	entries_cur = entries.begin();
	entries_end = entries.end();
	for(; entries_cur != entries_end; entries_cur++) {
		delete entries_cur->second;
	}
	
}

void NotifyOnAggressionChange::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotifyOnAggressionChange", pfx);
	/*  0  */
	_log(l_type, "%sinteger0=%lu", pfx, integer0);
	/*  1  */
	/*  maps _something_ to a timestamp  */
	_log(l_type, "%sentries: Dictionaty with %d enetires", pfx, entries.size());
	std::map<uint32, PyRep *>::const_iterator entries_cur, entries_end;
	entries_cur = entries.begin();
	entries_end = entries.end();
	for(; entries_cur != entries_end; entries_cur++) {
		_log(l_type, "%s   Key: %lu", pfx, entries_cur->first);
		std::string n(pfx);
		n += "        ";
		entries_cur->second->Dump(stdout, n.c_str());
	}
	
}

PyRepTuple *NotifyOnAggressionChange::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepInteger(integer0);
	/*  1  */
	/*  maps _something_ to a timestamp  */
	
	PyRepDict *dict1 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator entries_cur, entries_end;
	entries_cur = entries.begin();
	entries_end = entries.end();
	for(; entries_cur != entries_end; entries_cur++) {
		dict1->items[
			new PyRepInteger(entries_cur->first)
		] = entries_cur->second->Clone();
	}
	tuple0->items[1] = dict1;
	
	res = tuple0;
	

	return(res);
}

bool NotifyOnAggressionChange::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool NotifyOnAggressionChange::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnAggressionChange failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnAggressionChange failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnAggressionChange failed: integer0 is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode NotifyOnAggressionChange: truncating 64 bit into into 32 bit int for field integer0");
	}
	integer0 = int_1->value;
	/*  1  */
	/*  maps _something_ to a timestamp  */
	if(!tuple0->items[1]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnAggressionChange failed: entries is not a dict: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	entries.clear();
	PyRepDict *dict_2 = (PyRepDict *) tuple0->items[1];
	PyRepDict::iterator entries_cur, entries_end;
	entries_cur = dict_2->items.begin();
	entries_end = dict_2->items.end();
	int entries_index;
	for(entries_index = 0; entries_cur != entries_end; entries_cur++, entries_index++) {
		if(!entries_cur->first->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode NotifyOnAggressionChange failed: Key %d in dict entries is not an integer: %s", entries_index, entries_cur->first->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *k = (PyRepInteger *) entries_cur->first;
		if(k->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode NotifyOnAggressionChange: truncating 64 bit into into 32 bit int in key of entry %d in field entries", entries_index);
		}
		entries[k->value] = entries_cur->second->Clone();
	}
	

	delete packet;
	return(true);
}

NotifyOnAggressionChange *NotifyOnAggressionChange::Clone() const {
	NotifyOnAggressionChange *res = new NotifyOnAggressionChange;
	/*  0  */
	res->integer0 = integer0;
	/*  1  */
	/*  maps _something_ to a timestamp  */
	std::map<uint32, PyRep *>::const_iterator entries_cur, entries_end;
	//free any existing elements first
	entries_cur = res->entries.begin();
	entries_end = res->entries.end();
	for(; entries_cur != entries_end; entries_cur++) {
		delete entries_cur->second;
	}
	res->entries.clear();
	//now we can copy in the new ones...
	entries_cur = entries.begin();
	entries_end = entries.end();
	for(; entries_cur != entries_end; entries_cur++) {
		res->entries[entries_cur->first] = entries_cur->second->Clone();
	}
	

	return(res);
}

CallMachoResolveObject::CallMachoResolveObject() {
	/*  0  */
	/*  0  */
	entityID = 0;
	/*  1  */
	integer1 = 0;
	/*  1  */
	justQuery = 0;
}

CallMachoResolveObject::~CallMachoResolveObject() {
	/*  0  */
	/*  0  */
	/*  1  */
	/*  1  */
}

void CallMachoResolveObject::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallMachoResolveObject", pfx);
	/*  0  */
	/*  0  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	/*  1  */
	_log(l_type, "%sinteger1=%lu", pfx, integer1);
	/*  1  */
	_log(l_type, "%sjustQuery=%lu", pfx, justQuery);
}

PyRepTuple *CallMachoResolveObject::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	/*  0  */
	tuple1->items[0] = new PyRepInteger(entityID);
	/*  1  */
	tuple1->items[1] = new PyRepInteger(integer1);
	tuple0->items[0] = tuple1;
	
	/*  1  */
	tuple0->items[1] = new PyRepInteger(justQuery);
	res = tuple0;
	

	return(res);
}

bool CallMachoResolveObject::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallMachoResolveObject::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallMachoResolveObject failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode CallMachoResolveObject failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallMachoResolveObject failed: tuple1 is the wrong type: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple1 = (PyRepTuple *) tuple0->items[0];
	if(tuple1->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode CallMachoResolveObject failed: tuple1 is the wrong size: expected 2, but got %d", tuple1->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple1->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallMachoResolveObject failed: entityID is not an int: %s", tuple1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple1->items[0];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallMachoResolveObject: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_2->value;
	/*  1  */
	if(!tuple1->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallMachoResolveObject failed: integer1 is not an int: %s", tuple1->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple1->items[1];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallMachoResolveObject: truncating 64 bit into into 32 bit int for field integer1");
	}
	integer1 = int_3->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallMachoResolveObject failed: justQuery is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple0->items[1];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallMachoResolveObject: truncating 64 bit into into 32 bit int for field justQuery");
	}
	justQuery = int_4->value;

	delete packet;
	return(true);
}

CallMachoResolveObject *CallMachoResolveObject::Clone() const {
	CallMachoResolveObject *res = new CallMachoResolveObject;
	/*  0  */
	/*  0  */
	res->entityID = entityID;
	/*  1  */
	res->integer1 = integer1;
	/*  1  */
	res->justQuery = justQuery;

	return(res);
}

RspMachoResolveObject::RspMachoResolveObject() {
	/*  0  */
	nodeID = 0;
}

RspMachoResolveObject::~RspMachoResolveObject() {
	/*  0  */
}

void RspMachoResolveObject::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspMachoResolveObject", pfx);
	/*  0  */
	_log(l_type, "%snodeID=%lu", pfx, nodeID);
}

PyRepTuple *RspMachoResolveObject::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	ss_1 = new PyRepInteger(nodeID);
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspMachoResolveObject::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspMachoResolveObject::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspMachoResolveObject failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspMachoResolveObject failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspMachoResolveObject failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspMachoResolveObject failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	if(!ss_1->decoded->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode RspMachoResolveObject failed: nodeID is not an int: %s", ss_1->decoded->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) ss_1->decoded;
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode RspMachoResolveObject: truncating 64 bit into into 32 bit int for field nodeID");
	}
	nodeID = int_2->value;

	delete packet;
	return(true);
}

RspMachoResolveObject *RspMachoResolveObject::Clone() const {
	RspMachoResolveObject *res = new RspMachoResolveObject;
	/*  0  */
	res->nodeID = nodeID;

	return(res);
}

CallMachoBindObject_call::CallMachoBindObject_call() {
	/*  0  */
	method_name = "";
	/*  1  */
	arguments = NULL;
	/*  2  */
}

CallMachoBindObject_call::~CallMachoBindObject_call() {
	/*  0  */
	/*  1  */
	delete arguments;
	/*  2  */
}

void CallMachoBindObject_call::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallMachoBindObject_call", pfx);
	/*  0  */
	_log(l_type, "%smethod_name='%s'", pfx, method_name.c_str());
	/*  1  */
	_log(l_type, "%sarguments: ", pfx);
	std::string arguments_n(pfx);
	arguments_n += "    ";
	arguments->Dump(l_type, arguments_n.c_str());
	/*  2  */
	_log(l_type, "%sdict_arguments: ", pfx);
	std::string dict_arguments_n(pfx);
	dict_arguments_n += "    ";
	dict_arguments.Dump(l_type, dict_arguments_n.c_str());
}

PyRepTuple *CallMachoBindObject_call::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	/*  0  */
	tuple0->items[0] = new PyRepString(method_name);
	/*  1  */
	tuple0->items[1] = arguments->Clone();
	/*  2  */
	tuple0->items[2] = dict_arguments.Clone(); //could avoid, see notes in PyPacket
	res = tuple0;
	

	return(res);
}

bool CallMachoBindObject_call::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallMachoBindObject_call::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallMachoBindObject_call failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode CallMachoBindObject_call failed: tuple0 is the wrong size: expected 3, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode CallMachoBindObject_call failed: method_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	method_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallMachoBindObject_call failed: arguments is not a tuple: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	arguments = (PyRepTuple *) tuple0->items[1];
	tuple0->items[1] = NULL;
	
	/*  2  */
	if(!tuple0->items[2]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode CallMachoBindObject_call failed: dict_arguments is not a dict: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepDict *list_dict_arguments = (PyRepDict *) tuple0->items[2];	dict_arguments.items = list_dict_arguments->items;
	list_dict_arguments->items.clear();
	

	delete packet;
	return(true);
}

CallMachoBindObject_call *CallMachoBindObject_call::Clone() const {
	CallMachoBindObject_call *res = new CallMachoBindObject_call;
	/*  0  */
	res->method_name = method_name;
	/*  1  */
	res->arguments = (PyRepTuple *) arguments->Clone();
	/*  2  */
	res->dict_arguments.CloneFrom(&dict_arguments);

	return(res);
}

CallMachoBindObject::CallMachoBindObject() {
	/*  0  */
	/*  0  */
	entityID = 0;
	/*  1  */
	integer1 = 0;
	/*  1  */
	/*  either 'None', or a CallMachoBindObject_call  */
	call = NULL;
}

CallMachoBindObject::~CallMachoBindObject() {
	/*  0  */
	/*  0  */
	/*  1  */
	/*  1  */
	/*  either 'None', or a CallMachoBindObject_call  */
	delete call;
}

void CallMachoBindObject::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallMachoBindObject", pfx);
	/*  0  */
	/*  0  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	/*  1  */
	_log(l_type, "%sinteger1=%lu", pfx, integer1);
	/*  1  */
	/*  either 'None', or a CallMachoBindObject_call  */
	_log(l_type, "%scall: ", pfx);
	std::string call_n(pfx);
	call_n += "    ";
	call->Dump(l_type, call_n.c_str());
}

PyRepTuple *CallMachoBindObject::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	/*  0  */
	tuple1->items[0] = new PyRepInteger(entityID);
	/*  1  */
	tuple1->items[1] = new PyRepInteger(integer1);
	tuple0->items[0] = tuple1;
	
	/*  1  */
	/*  either 'None', or a CallMachoBindObject_call  */
	tuple0->items[1] = call->Clone();
	res = tuple0;
	

	return(res);
}

bool CallMachoBindObject::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallMachoBindObject::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallMachoBindObject failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode CallMachoBindObject failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallMachoBindObject failed: tuple1 is the wrong type: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple1 = (PyRepTuple *) tuple0->items[0];
	if(tuple1->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode CallMachoBindObject failed: tuple1 is the wrong size: expected 2, but got %d", tuple1->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple1->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallMachoBindObject failed: entityID is not an int: %s", tuple1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple1->items[0];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallMachoBindObject: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_2->value;
	/*  1  */
	if(!tuple1->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallMachoBindObject failed: integer1 is not an int: %s", tuple1->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple1->items[1];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallMachoBindObject: truncating 64 bit into into 32 bit int for field integer1");
	}
	integer1 = int_3->value;
	/*  1  */
	/*  either 'None', or a CallMachoBindObject_call  */
	call = tuple0->items[1];
	tuple0->items[1] = NULL;
	

	delete packet;
	return(true);
}

CallMachoBindObject *CallMachoBindObject::Clone() const {
	CallMachoBindObject *res = new CallMachoBindObject;
	/*  0  */
	/*  0  */
	res->entityID = entityID;
	/*  1  */
	res->integer1 = integer1;
	/*  1  */
	/*  either 'None', or a CallMachoBindObject_call  */
	res->call = call->Clone();

	return(res);
}

BoundObject::BoundObject() {
	/*  0  */
	bindspec = "";
	/*  1  */
	timestamp = 0;
}

BoundObject::~BoundObject() {
	/*  0  */
	/*  1  */
}

void BoundObject::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sBoundObject", pfx);
	/*  0  */
	_log(l_type, "%sbindspec='%s'", pfx, bindspec.c_str());
	/*  1  */
	_log(l_type, "%stimestamp=" I64u, pfx, timestamp);
}

PyRepSubStruct *BoundObject::Encode() {
	PyRepSubStruct *res = NULL;
	PyRep *ss_0;
	PyRep *ss_1;
	PyRepTuple *tuple2 = new PyRepTuple(2);
	/*  0  */
	tuple2->items[0] = new PyRepString(bindspec);
	/*  1  */
	tuple2->items[1] = new PyRepInteger(timestamp);
	ss_1 = tuple2;
	
	ss_0 = new PyRepSubStream(ss_1);
	res = new PyRepSubStruct(ss_0);

	return(res);
}

bool BoundObject::Decode(PyRepSubStruct **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool BoundObject::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::SubStruct)) {
		_log(NET__PACKET_ERROR, "Decode BoundObject failed: ss_0 is not a substruct: %s", packet->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStruct *ss_0 = (PyRepSubStruct *) packet;
	
	if(!ss_0->sub->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode BoundObject failed: ss_1 is not a substream: %s", ss_0->sub->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) ss_0->sub;
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode BoundObject failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	if(!ss_1->decoded->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode BoundObject failed: tuple2 is the wrong type: %s", ss_1->decoded->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) ss_1->decoded;
	if(tuple2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode BoundObject failed: tuple2 is the wrong size: expected 2, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple2->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode BoundObject failed: bindspec is not a string: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) tuple2->items[0];
	bindspec = string_3->value;
	/*  1  */
	if(!tuple2->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode BoundObject failed: timestamp is not an int: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_4 = (PyRepInteger *) tuple2->items[1];
	timestamp = int64_4->value;

	delete packet;
	return(true);
}

BoundObject *BoundObject::Clone() const {
	BoundObject *res = new BoundObject;
	/*  0  */
	res->bindspec = bindspec;
	/*  1  */
	res->timestamp = timestamp;

	return(res);
}

RspMachoBindObject::RspMachoBindObject() {
	/*  0  */
	/*  0  */
	bind = NULL;
	/*  1  */
	call_return = NULL;
}

RspMachoBindObject::~RspMachoBindObject() {
	/*  0  */
	/*  0  */
	delete bind;
	/*  1  */
	delete call_return;
}

void RspMachoBindObject::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspMachoBindObject", pfx);
	/*  0  */
	/*  0  */
	_log(l_type, "%sbind:", pfx);
	std::string bind_n(pfx);
	bind_n += "    ";
	bind->Dump(l_type, bind_n.c_str());
	/*  1  */
	_log(l_type, "%scall_return: ", pfx);
	std::string call_return_n(pfx);
	call_return_n += "    ";
	call_return->Dump(l_type, call_return_n.c_str());
}

PyRepTuple *RspMachoBindObject::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	PyRepTuple *tuple2 = new PyRepTuple(2);
	/*  0  */
	tuple2->items[0] = bind->Encode();
	/*  1  */
	tuple2->items[1] = call_return->Clone();
	ss_1 = tuple2;
	
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspMachoBindObject::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspMachoBindObject::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspMachoBindObject failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspMachoBindObject failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspMachoBindObject failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspMachoBindObject failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	if(!ss_1->decoded->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspMachoBindObject failed: tuple2 is the wrong type: %s", ss_1->decoded->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) ss_1->decoded;
	if(tuple2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode RspMachoBindObject failed: tuple2 is the wrong size: expected 2, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	PyRep *rep_3 = tuple2->items[0];
	tuple2->items[0] = NULL;
	delete bind;
	bind = new BoundObject;
	if(!bind->Decode(&rep_3)) {
		_log(NET__PACKET_ERROR, "Decode RspMachoBindObject failed: unable to decode element bind");
		delete packet;
		return(false);
	}
	
	/*  1  */
	call_return = tuple2->items[1];
	tuple2->items[1] = NULL;
	

	delete packet;
	return(true);
}

RspMachoBindObject *RspMachoBindObject::Clone() const {
	RspMachoBindObject *res = new RspMachoBindObject;
	/*  0  */
	/*  0  */
	res->bind = bind->Clone();
	/*  1  */
	res->call_return = call_return->Clone();

	return(res);
}
	/*  returns a tuple of two BoundObject specs  */

CallGetInventoryFromId::CallGetInventoryFromId() {
	/*  0  */
	entityID = 0;
	/*  1  */
	passive = 0;
}

CallGetInventoryFromId::~CallGetInventoryFromId() {
	/*  0  */
	/*  1  */
}

void CallGetInventoryFromId::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallGetInventoryFromId", pfx);
	/*  0  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	/*  1  */
	_log(l_type, "%spassive=%lu", pfx, passive);
}

PyRepTuple *CallGetInventoryFromId::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepInteger(entityID);
	/*  1  */
	tuple0->items[1] = new PyRepInteger(passive);
	res = tuple0;
	

	return(res);
}

bool CallGetInventoryFromId::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallGetInventoryFromId::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallGetInventoryFromId failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode CallGetInventoryFromId failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallGetInventoryFromId failed: entityID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallGetInventoryFromId: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallGetInventoryFromId failed: passive is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallGetInventoryFromId: truncating 64 bit into into 32 bit int for field passive");
	}
	passive = int_2->value;

	delete packet;
	return(true);
}

CallGetInventoryFromId *CallGetInventoryFromId::Clone() const {
	CallGetInventoryFromId *res = new CallGetInventoryFromId;
	/*  0  */
	res->entityID = entityID;
	/*  1  */
	res->passive = passive;

	return(res);
}

RspGetMyKillRights::RspGetMyKillRights() {
	/*  0  */
	/*  0  */
	/*  1  */
}

RspGetMyKillRights::~RspGetMyKillRights() {
	/*  0  */
	/*  0  */
	/*  1  */
}

void RspGetMyKillRights::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspGetMyKillRights", pfx);
	/*  0  */
	/*  0  */
	_log(l_type, "%sunknown0: ", pfx);
	std::string unknown0_n(pfx);
	unknown0_n += "    ";
	unknown0.Dump(l_type, unknown0_n.c_str());
	/*  1  */
	_log(l_type, "%sunknown1: ", pfx);
	std::string unknown1_n(pfx);
	unknown1_n += "    ";
	unknown1.Dump(l_type, unknown1_n.c_str());
}

PyRepTuple *RspGetMyKillRights::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	PyRepTuple *tuple2 = new PyRepTuple(2);
	/*  0  */
	tuple2->items[0] = unknown0.Clone(); //could avoid, see notes in PyPacket
	/*  1  */
	tuple2->items[1] = unknown1.Clone(); //could avoid, see notes in PyPacket
	ss_1 = tuple2;
	
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspGetMyKillRights::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspGetMyKillRights::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetMyKillRights failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspGetMyKillRights failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspGetMyKillRights failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspGetMyKillRights failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	if(!ss_1->decoded->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetMyKillRights failed: tuple2 is the wrong type: %s", ss_1->decoded->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) ss_1->decoded;
	if(tuple2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode RspGetMyKillRights failed: tuple2 is the wrong size: expected 2, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple2->items[0]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode RspGetMyKillRights failed: unknown0 is not a dict: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepDict *list_unknown0 = (PyRepDict *) tuple2->items[0];	unknown0.items = list_unknown0->items;
	list_unknown0->items.clear();
	
	/*  1  */
	if(!tuple2->items[1]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode RspGetMyKillRights failed: unknown1 is not a dict: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepDict *list_unknown1 = (PyRepDict *) tuple2->items[1];	unknown1.items = list_unknown1->items;
	list_unknown1->items.clear();
	

	delete packet;
	return(true);
}

RspGetMyKillRights *RspGetMyKillRights::Clone() const {
	RspGetMyKillRights *res = new RspGetMyKillRights;
	/*  0  */
	/*  0  */
	res->unknown0.CloneFrom(&unknown0);
	/*  1  */
	res->unknown1.CloneFrom(&unknown1);

	return(res);
}

RspGetInitialState::RspGetInitialState() {
	/*  0  */
	rowset = NULL;
}

RspGetInitialState::~RspGetInitialState() {
	/*  0  */
	delete rowset;
}

void RspGetInitialState::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspGetInitialState", pfx);
	/*  0  */
	_log(l_type, "%srowset:", pfx);
	std::string rowset_n(pfx);
	rowset_n += "    ";
	rowset->Dump(l_type, rowset_n.c_str());
}

PyRepTuple *RspGetInitialState::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	ss_1 = rowset->Encode();
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspGetInitialState::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspGetInitialState::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetInitialState failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspGetInitialState failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspGetInitialState failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspGetInitialState failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	PyRep *rep_2 = ss_1->decoded;
	ss_1->decoded = NULL;
	delete rowset;
	rowset = new util_Rowset;
	if(!rowset->Decode(&rep_2)) {
		_log(NET__PACKET_ERROR, "Decode RspGetInitialState failed: unable to decode element rowset");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

RspGetInitialState *RspGetInitialState::Clone() const {
	RspGetInitialState *res = new RspGetInitialState;
	/*  0  */
	res->rowset = rowset->Clone();

	return(res);
}

RspGetChannels::RspGetChannels() {
	/*  0  */
	cachedcall = NULL;
}

RspGetChannels::~RspGetChannels() {
	/*  0  */
	delete cachedcall;
}

void RspGetChannels::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspGetChannels", pfx);
	/*  0  */
	_log(l_type, "%scachedcall:", pfx);
	std::string cachedcall_n(pfx);
	cachedcall_n += "    ";
	cachedcall->Dump(l_type, cachedcall_n.c_str());
}

PyRepTuple *RspGetChannels::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	ss_1 = cachedcall->Encode();
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspGetChannels::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspGetChannels::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetChannels failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspGetChannels failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspGetChannels failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspGetChannels failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	PyRep *rep_2 = ss_1->decoded;
	ss_1->decoded = NULL;
	delete cachedcall;
	cachedcall = new objectCaching_CachedMethodCallResult;
	if(!cachedcall->Decode(&rep_2)) {
		_log(NET__PACKET_ERROR, "Decode RspGetChannels failed: unable to decode element cachedcall");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

RspGetChannels *RspGetChannels::Clone() const {
	RspGetChannels *res = new RspGetChannels;
	/*  0  */
	res->cachedcall = cachedcall->Clone();

	return(res);
}

CallJoinChannels::CallJoinChannels() {
	/*  0  */
}

CallJoinChannels::~CallJoinChannels() {
	/*  0  */
}

void CallJoinChannels::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallJoinChannels", pfx);
	/*  0  */
	_log(l_type, "%schannels: Integer list with %d enetires", pfx, channels.size());
	std::vector<uint32>::const_iterator channels_cur, channels_end;
	channels_cur = channels.begin();
	channels_end = channels.end();
	int channels_index;
	for(channels_index = 0; channels_cur != channels_end; channels_cur++, channels_index++) {
		_log(l_type, "%s   [%02d] %d", pfx, channels_index, *channels_cur);
	}
	
}

PyRepTuple *CallJoinChannels::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator channels_cur, channels_end;
	channels_cur = channels.begin();
	channels_end = channels.end();
	for(; channels_cur != channels_end; channels_cur++) {
		list1->items.push_back(
			new PyRepInteger(*channels_cur)
		);
	}
	tuple0->items[0] = list1;
	
	res = tuple0;
	

	return(res);
}

bool CallJoinChannels::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallJoinChannels::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallJoinChannels failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode CallJoinChannels failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode CallJoinChannels failed: channels is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	channels.clear();
	PyRepList *list_1 = (PyRepList *) tuple0->items[0];
	PyRepList::iterator channels_cur, channels_end;
	channels_cur = list_1->items.begin();
	channels_end = list_1->items.end();
	int channels_index;
	for(channels_index = 0; channels_cur != channels_end; channels_cur++, channels_index++) {
		if(!(*channels_cur)->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode CallJoinChannels failed: Element %d in list channels is not an integer: %s", channels_index, (*channels_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *t = (PyRepInteger *) (*channels_cur);
		if(t->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode CallJoinChannels: truncating 64 bit into into 32 bit int for item %d in field channels", channels_index);
		}
		channels.push_back(t->value);
	}


	delete packet;
	return(true);
}

CallJoinChannels *CallJoinChannels::Clone() const {
	CallJoinChannels *res = new CallJoinChannels;
	/*  0  */
	res->channels = channels;

	return(res);
}

RspJoinChannels::RspJoinChannels() {
	/*  0  */
	/*  list of complex elements, one for each requested channel
	    with details about the channel  */
}

RspJoinChannels::~RspJoinChannels() {
	/*  0  */
	/*  list of complex elements, one for each requested channel
	    with details about the channel  */
}

void RspJoinChannels::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspJoinChannels", pfx);
	/*  0  */
	/*  list of complex elements, one for each requested channel
	    with details about the channel  */
	_log(l_type, "%schannels: ", pfx);
	std::string channels_n(pfx);
	channels_n += "    ";
	channels.Dump(l_type, channels_n.c_str());
}

PyRepTuple *RspJoinChannels::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	/*  list of complex elements, one for each requested channel
	    with details about the channel  */
	ss_1 = channels.Clone();
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspJoinChannels::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspJoinChannels::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspJoinChannels failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspJoinChannels failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspJoinChannels failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspJoinChannels failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	/*  list of complex elements, one for each requested channel
	    with details about the channel  */
	if(!ss_1->decoded->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode RspJoinChannels failed: channels is not a list: %s", ss_1->decoded->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_channels = (PyRepList *) ss_1->decoded;	channels.items = list_channels->items;
	list_channels->items.clear();
	

	delete packet;
	return(true);
}

RspJoinChannels *RspJoinChannels::Clone() const {
	RspJoinChannels *res = new RspJoinChannels;
	/*  0  */
	/*  list of complex elements, one for each requested channel
	    with details about the channel  */
	res->channels.CloneFrom(&channels);

	return(res);
}

NotifyOnLSC::NotifyOnLSC() {
	/*  0  */
	/*  0  */
	/*  0  */
	channeltype = "";
	/*  1  */
	entityID = 0;
	/*  1  */
	integer2 = 0;
	/*  2  */
	function = "";
	/*  3  */
	arguments = NULL;
	/*  4  */
}

NotifyOnLSC::~NotifyOnLSC() {
	/*  0  */
	/*  0  */
	/*  0  */
	/*  1  */
	/*  1  */
	/*  2  */
	/*  3  */
	delete arguments;
	/*  4  */
}

void NotifyOnLSC::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotifyOnLSC", pfx);
	/*  0  */
	/*  0  */
	/*  0  */
	_log(l_type, "%schanneltype='%s'", pfx, channeltype.c_str());
	/*  1  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	/*  1  */
	_log(l_type, "%sinteger2=%lu", pfx, integer2);
	/*  2  */
	_log(l_type, "%sfunction='%s'", pfx, function.c_str());
	/*  3  */
	_log(l_type, "%sarguments: ", pfx);
	std::string arguments_n(pfx);
	arguments_n += "    ";
	arguments->Dump(l_type, arguments_n.c_str());
	/*  4  */
}

PyRepTuple *NotifyOnLSC::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	/*  0  */
	PyRepTuple *tuple1 = new PyRepTuple(1);
	/*  0  */
	PyRepTuple *tuple2 = new PyRepTuple(2);
	/*  0  */
	tuple2->items[0] = new PyRepString(channeltype);
	/*  1  */
	tuple2->items[1] = new PyRepInteger(entityID);
	tuple1->items[0] = tuple2;
	
	tuple0->items[0] = tuple1;
	
	/*  1  */
	tuple0->items[1] = new PyRepInteger(integer2);
	/*  2  */
	tuple0->items[2] = new PyRepString(function);
	/*  3  */
	tuple0->items[3] = arguments->Clone();
	/*  4  */
	PyRepTuple *tuple3 = new PyRepTuple(0);
	tuple0->items[4] = tuple3;
	
	res = tuple0;
	

	return(res);
}

bool NotifyOnLSC::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool NotifyOnLSC::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnLSC failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 5) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnLSC failed: tuple0 is the wrong size: expected 5, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnLSC failed: tuple1 is the wrong type: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple1 = (PyRepTuple *) tuple0->items[0];
	if(tuple1->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnLSC failed: tuple1 is the wrong size: expected 1, but got %d", tuple1->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple1->items[0]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnLSC failed: tuple2 is the wrong type: %s", tuple1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple1->items[0];
	if(tuple2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnLSC failed: tuple2 is the wrong size: expected 2, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple2->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnLSC failed: channeltype is not a string: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) tuple2->items[0];
	channeltype = string_3->value;
	/*  1  */
	if(!tuple2->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnLSC failed: entityID is not an int: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple2->items[1];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode NotifyOnLSC: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_4->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnLSC failed: integer2 is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) tuple0->items[1];
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode NotifyOnLSC: truncating 64 bit into into 32 bit int for field integer2");
	}
	integer2 = int_5->value;
	/*  2  */
	if(!tuple0->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnLSC failed: function is not a string: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_6 = (PyRepString *) tuple0->items[2];
	function = string_6->value;
	/*  3  */
	if(!tuple0->items[3]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnLSC failed: arguments is not a tuple: %s", tuple0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	arguments = (PyRepTuple *) tuple0->items[3];
	tuple0->items[3] = NULL;
	
	/*  4  */
	if(!tuple0->items[4]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnLSC failed: tuple7 is the wrong type: %s", tuple0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple7 = (PyRepTuple *) tuple0->items[4];
	if(tuple7->items.size() != 0) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnLSC failed: tuple7 is the wrong size: expected 0, but got %d", tuple7->items.size());
		delete packet;
		return(false);
	}


	delete packet;
	return(true);
}

NotifyOnLSC *NotifyOnLSC::Clone() const {
	NotifyOnLSC *res = new NotifyOnLSC;
	/*  0  */
	/*  0  */
	/*  0  */
	res->channeltype = channeltype;
	/*  1  */
	res->entityID = entityID;
	/*  1  */
	res->integer2 = integer2;
	/*  2  */
	res->function = function;
	/*  3  */
	res->arguments = (PyRepTuple *) arguments->Clone();
	/*  4  */

	return(res);
}

CallGetCashBalance::CallGetCashBalance() {
	/*  0  */
	isCorpWallet = 0;
}

CallGetCashBalance::~CallGetCashBalance() {
	/*  0  */
}

void CallGetCashBalance::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallGetCashBalance", pfx);
	/*  0  */
	_log(l_type, "%sisCorpWallet=%lu", pfx, isCorpWallet);
}

PyRepTuple *CallGetCashBalance::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	tuple0->items[0] = new PyRepInteger(isCorpWallet);
	res = tuple0;
	

	return(res);
}

bool CallGetCashBalance::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallGetCashBalance::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallGetCashBalance failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode CallGetCashBalance failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallGetCashBalance failed: isCorpWallet is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallGetCashBalance: truncating 64 bit into into 32 bit int for field isCorpWallet");
	}
	isCorpWallet = int_1->value;

	delete packet;
	return(true);
}

CallGetCashBalance *CallGetCashBalance::Clone() const {
	CallGetCashBalance *res = new CallGetCashBalance;
	/*  0  */
	res->isCorpWallet = isCorpWallet;

	return(res);
}

RspGetCashBalance::RspGetCashBalance() {
	/*  0  */
	credits = 0.0;
}

RspGetCashBalance::~RspGetCashBalance() {
	/*  0  */
}

void RspGetCashBalance::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspGetCashBalance", pfx);
	/*  0  */
	_log(l_type, "%scredits=%.13f", pfx, credits);
}

PyRepTuple *RspGetCashBalance::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	ss_1 = new PyRepReal(credits);
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspGetCashBalance::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspGetCashBalance::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCashBalance failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspGetCashBalance failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCashBalance failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspGetCashBalance failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	if(!ss_1->decoded->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCashBalance failed: credits is not a real: %s", ss_1->decoded->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_2 = (PyRepReal *) ss_1->decoded;
	credits = real_2->value;

	delete packet;
	return(true);
}

RspGetCashBalance *RspGetCashBalance::Clone() const {
	RspGetCashBalance *res = new RspGetCashBalance;
	/*  0  */
	res->credits = credits;

	return(res);
}

RspGetOwnerNoteLabels::RspGetOwnerNoteLabels() {
	/*  0  */
	notes = NULL;
}

RspGetOwnerNoteLabels::~RspGetOwnerNoteLabels() {
	/*  0  */
	delete notes;
}

void RspGetOwnerNoteLabels::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspGetOwnerNoteLabels", pfx);
	/*  0  */
	_log(l_type, "%snotes:", pfx);
	std::string notes_n(pfx);
	notes_n += "    ";
	notes->Dump(l_type, notes_n.c_str());
}

PyRepTuple *RspGetOwnerNoteLabels::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	ss_1 = notes->Encode();
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspGetOwnerNoteLabels::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspGetOwnerNoteLabels::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetOwnerNoteLabels failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspGetOwnerNoteLabels failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspGetOwnerNoteLabels failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspGetOwnerNoteLabels failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	PyRep *rep_2 = ss_1->decoded;
	ss_1->decoded = NULL;
	delete notes;
	notes = new util_Rowset;
	if(!notes->Decode(&rep_2)) {
		_log(NET__PACKET_ERROR, "Decode RspGetOwnerNoteLabels failed: unable to decode element notes");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

RspGetOwnerNoteLabels *RspGetOwnerNoteLabels::Clone() const {
	RspGetOwnerNoteLabels *res = new RspGetOwnerNoteLabels;
	/*  0  */
	res->notes = notes->Clone();

	return(res);
}

RspGetStationItemBits::RspGetStationItemBits() {
	/*  0  */
	/*  0  */
	integer0 = 0;
	/*  1  */
	integer1 = 0;
	/*  2  */
	integer2 = 0;
	/*  3  */
	integer3 = 0;
	/*  4  */
	integer4 = 0;
}

RspGetStationItemBits::~RspGetStationItemBits() {
	/*  0  */
	/*  0  */
	/*  1  */
	/*  2  */
	/*  3  */
	/*  4  */
}

void RspGetStationItemBits::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspGetStationItemBits", pfx);
	/*  0  */
	/*  0  */
	_log(l_type, "%sinteger0=%lu", pfx, integer0);
	/*  1  */
	_log(l_type, "%sinteger1=%lu", pfx, integer1);
	/*  2  */
	_log(l_type, "%sinteger2=%lu", pfx, integer2);
	/*  3  */
	_log(l_type, "%sinteger3=%lu", pfx, integer3);
	/*  4  */
	_log(l_type, "%sinteger4=%lu", pfx, integer4);
}

PyRepTuple *RspGetStationItemBits::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	PyRepTuple *tuple2 = new PyRepTuple(5);
	/*  0  */
	tuple2->items[0] = new PyRepInteger(integer0);
	/*  1  */
	tuple2->items[1] = new PyRepInteger(integer1);
	/*  2  */
	tuple2->items[2] = new PyRepInteger(integer2);
	/*  3  */
	tuple2->items[3] = new PyRepInteger(integer3);
	/*  4  */
	tuple2->items[4] = new PyRepInteger(integer4);
	ss_1 = tuple2;
	
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspGetStationItemBits::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspGetStationItemBits::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetStationItemBits failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspGetStationItemBits failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspGetStationItemBits failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspGetStationItemBits failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	if(!ss_1->decoded->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetStationItemBits failed: tuple2 is the wrong type: %s", ss_1->decoded->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) ss_1->decoded;
	if(tuple2->items.size() != 5) {
		_log(NET__PACKET_ERROR, "Decode RspGetStationItemBits failed: tuple2 is the wrong size: expected 5, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode RspGetStationItemBits failed: integer0 is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode RspGetStationItemBits: truncating 64 bit into into 32 bit int for field integer0");
	}
	integer0 = int_3->value;
	/*  1  */
	if(!tuple2->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode RspGetStationItemBits failed: integer1 is not an int: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple2->items[1];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode RspGetStationItemBits: truncating 64 bit into into 32 bit int for field integer1");
	}
	integer1 = int_4->value;
	/*  2  */
	if(!tuple2->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode RspGetStationItemBits failed: integer2 is not an int: %s", tuple2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) tuple2->items[2];
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode RspGetStationItemBits: truncating 64 bit into into 32 bit int for field integer2");
	}
	integer2 = int_5->value;
	/*  3  */
	if(!tuple2->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode RspGetStationItemBits failed: integer3 is not an int: %s", tuple2->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_6 = (PyRepInteger *) tuple2->items[3];
	if(int_6->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode RspGetStationItemBits: truncating 64 bit into into 32 bit int for field integer3");
	}
	integer3 = int_6->value;
	/*  4  */
	if(!tuple2->items[4]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode RspGetStationItemBits failed: integer4 is not an int: %s", tuple2->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_7 = (PyRepInteger *) tuple2->items[4];
	if(int_7->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode RspGetStationItemBits: truncating 64 bit into into 32 bit int for field integer4");
	}
	integer4 = int_7->value;

	delete packet;
	return(true);
}

RspGetStationItemBits *RspGetStationItemBits::Clone() const {
	RspGetStationItemBits *res = new RspGetStationItemBits;
	/*  0  */
	/*  0  */
	res->integer0 = integer0;
	/*  1  */
	res->integer1 = integer1;
	/*  2  */
	res->integer2 = integer2;
	/*  3  */
	res->integer3 = integer3;
	/*  4  */
	res->integer4 = integer4;

	return(res);
}

RspGetGuests::RspGetGuests() {
	/*  0  */
}

RspGetGuests::~RspGetGuests() {
	/*  0  */
}

void RspGetGuests::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspGetGuests", pfx);
	/*  0  */
	_log(l_type, "%sguests: Integer list with %d enetires", pfx, guests.size());
	std::vector<uint32>::const_iterator guests_cur, guests_end;
	guests_cur = guests.begin();
	guests_end = guests.end();
	int guests_index;
	for(guests_index = 0; guests_cur != guests_end; guests_cur++, guests_index++) {
		_log(l_type, "%s   [%02d] %d", pfx, guests_index, *guests_cur);
	}
	
}

PyRepTuple *RspGetGuests::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	
	PyRepList *list2 = new PyRepList();
	std::vector<uint32>::iterator guests_cur, guests_end;
	guests_cur = guests.begin();
	guests_end = guests.end();
	for(; guests_cur != guests_end; guests_cur++) {
		list2->items.push_back(
			new PyRepInteger(*guests_cur)
		);
	}
	ss_1 = list2;
	
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspGetGuests::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspGetGuests::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetGuests failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspGetGuests failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspGetGuests failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspGetGuests failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	if(!ss_1->decoded->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode RspGetGuests failed: guests is not a list: %s", ss_1->decoded->TypeString());
		delete packet;
		return(false);
	}
	guests.clear();
	PyRepList *list_2 = (PyRepList *) ss_1->decoded;
	PyRepList::iterator guests_cur, guests_end;
	guests_cur = list_2->items.begin();
	guests_end = list_2->items.end();
	int guests_index;
	for(guests_index = 0; guests_cur != guests_end; guests_cur++, guests_index++) {
		if(!(*guests_cur)->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode RspGetGuests failed: Element %d in list guests is not an integer: %s", guests_index, (*guests_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *t = (PyRepInteger *) (*guests_cur);
		if(t->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode RspGetGuests: truncating 64 bit into into 32 bit int for item %d in field guests", guests_index);
		}
		guests.push_back(t->value);
	}


	delete packet;
	return(true);
}

RspGetGuests *RspGetGuests::Clone() const {
	RspGetGuests *res = new RspGetGuests;
	/*  0  */
	res->guests = guests;

	return(res);
}

CallGetMessageDetails::CallGetMessageDetails() {
	/*  0  */
	channelID = 0;
	/*  1  */
	messageID = 0;
}

CallGetMessageDetails::~CallGetMessageDetails() {
	/*  0  */
	/*  1  */
}

void CallGetMessageDetails::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallGetMessageDetails", pfx);
	/*  0  */
	_log(l_type, "%schannelID=%lu", pfx, channelID);
	/*  1  */
	_log(l_type, "%smessageID=%lu", pfx, messageID);
}

PyRepTuple *CallGetMessageDetails::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepInteger(channelID);
	/*  1  */
	tuple0->items[1] = new PyRepInteger(messageID);
	res = tuple0;
	

	return(res);
}

bool CallGetMessageDetails::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallGetMessageDetails::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallGetMessageDetails failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode CallGetMessageDetails failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallGetMessageDetails failed: channelID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallGetMessageDetails: truncating 64 bit into into 32 bit int for field channelID");
	}
	channelID = int_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallGetMessageDetails failed: messageID is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallGetMessageDetails: truncating 64 bit into into 32 bit int for field messageID");
	}
	messageID = int_2->value;

	delete packet;
	return(true);
}

CallGetMessageDetails *CallGetMessageDetails::Clone() const {
	CallGetMessageDetails *res = new CallGetMessageDetails;
	/*  0  */
	res->channelID = channelID;
	/*  1  */
	res->messageID = messageID;

	return(res);
}

CallMarkMessagesRead::CallMarkMessagesRead() {
	/*  0  */
	/*  0  */
	messageID = 0;
}

CallMarkMessagesRead::~CallMarkMessagesRead() {
	/*  0  */
	/*  0  */
}

void CallMarkMessagesRead::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallMarkMessagesRead", pfx);
	/*  0  */
	/*  0  */
	_log(l_type, "%smessageID=%lu", pfx, messageID);
}

PyRepTuple *CallMarkMessagesRead::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRepList *list1 = new PyRepList();
	list1->items.resize(1, NULL);
	/*  0  */
	list1->items[0] = new PyRepInteger(messageID);
	tuple0->items[0] = list1;
	
	res = tuple0;
	

	return(res);
}

bool CallMarkMessagesRead::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallMarkMessagesRead::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallMarkMessagesRead failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode CallMarkMessagesRead failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode CallMarkMessagesRead failed: list1 is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list1 = (PyRepList *) tuple0->items[0];
	if(list1->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode CallMarkMessagesRead failed: list1 is the wrong size: expected 1, but got %d", list1->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!list1->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallMarkMessagesRead failed: messageID is not an int: %s", list1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) list1->items[0];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallMarkMessagesRead: truncating 64 bit into into 32 bit int for field messageID");
	}
	messageID = int_2->value;

	delete packet;
	return(true);
}

CallMarkMessagesRead *CallMarkMessagesRead::Clone() const {
	CallMarkMessagesRead *res = new CallMarkMessagesRead;
	/*  0  */
	/*  0  */
	res->messageID = messageID;

	return(res);
}

NotifyOnSkillStartTraining::NotifyOnSkillStartTraining() {
	/*  0  */
	itemID = 0;
	/*  1  */
	training_end = 0;
}

NotifyOnSkillStartTraining::~NotifyOnSkillStartTraining() {
	/*  0  */
	/*  1  */
}

void NotifyOnSkillStartTraining::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotifyOnSkillStartTraining", pfx);
	/*  0  */
	_log(l_type, "%sitemID=%lu", pfx, itemID);
	/*  1  */
	_log(l_type, "%straining_end=" I64u, pfx, training_end);
}

PyRepTuple *NotifyOnSkillStartTraining::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepInteger(itemID);
	/*  1  */
	tuple0->items[1] = new PyRepInteger(training_end);
	res = tuple0;
	

	return(res);
}

bool NotifyOnSkillStartTraining::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool NotifyOnSkillStartTraining::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnSkillStartTraining failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnSkillStartTraining failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnSkillStartTraining failed: itemID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode NotifyOnSkillStartTraining: truncating 64 bit into into 32 bit int for field itemID");
	}
	itemID = int_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnSkillStartTraining failed: training_end is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_2 = (PyRepInteger *) tuple0->items[1];
	training_end = int64_2->value;

	delete packet;
	return(true);
}

NotifyOnSkillStartTraining *NotifyOnSkillStartTraining::Clone() const {
	NotifyOnSkillStartTraining *res = new NotifyOnSkillStartTraining;
	/*  0  */
	res->itemID = itemID;
	/*  1  */
	res->training_end = training_end;

	return(res);
}
	/*  called on a bound object  */

CharStartTrainingSkill::CharStartTrainingSkill() {
	/*  0  */
	itemID = 0;
}

CharStartTrainingSkill::~CharStartTrainingSkill() {
	/*  0  */
}

void CharStartTrainingSkill::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCharStartTrainingSkill", pfx);
	/*  0  */
	_log(l_type, "%sitemID=%lu", pfx, itemID);
}

PyRepTuple *CharStartTrainingSkill::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	tuple0->items[0] = new PyRepInteger(itemID);
	res = tuple0;
	

	return(res);
}

bool CharStartTrainingSkill::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CharStartTrainingSkill::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CharStartTrainingSkill failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode CharStartTrainingSkill failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CharStartTrainingSkill failed: itemID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CharStartTrainingSkill: truncating 64 bit into into 32 bit int for field itemID");
	}
	itemID = int_1->value;

	delete packet;
	return(true);
}

CharStartTrainingSkill *CharStartTrainingSkill::Clone() const {
	CharStartTrainingSkill *res = new CharStartTrainingSkill;
	/*  0  */
	res->itemID = itemID;

	return(res);
}

CallGetEndOfTraining::CallGetEndOfTraining() {
	/*  0  */
	itemID = 0;
}

CallGetEndOfTraining::~CallGetEndOfTraining() {
	/*  0  */
}

void CallGetEndOfTraining::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallGetEndOfTraining", pfx);
	/*  0  */
	_log(l_type, "%sitemID=%lu", pfx, itemID);
}

PyRepTuple *CallGetEndOfTraining::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	tuple0->items[0] = new PyRepInteger(itemID);
	res = tuple0;
	

	return(res);
}

bool CallGetEndOfTraining::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallGetEndOfTraining::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallGetEndOfTraining failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode CallGetEndOfTraining failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallGetEndOfTraining failed: itemID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallGetEndOfTraining: truncating 64 bit into into 32 bit int for field itemID");
	}
	itemID = int_1->value;

	delete packet;
	return(true);
}

CallGetEndOfTraining *CallGetEndOfTraining::Clone() const {
	CallGetEndOfTraining *res = new CallGetEndOfTraining;
	/*  0  */
	res->itemID = itemID;

	return(res);
}

RspGetEndOfTraining::RspGetEndOfTraining() {
	/*  0  */
	timestamp = 0;
}

RspGetEndOfTraining::~RspGetEndOfTraining() {
	/*  0  */
}

void RspGetEndOfTraining::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspGetEndOfTraining", pfx);
	/*  0  */
	_log(l_type, "%stimestamp=" I64u, pfx, timestamp);
}

PyRepTuple *RspGetEndOfTraining::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	ss_1 = new PyRepInteger(timestamp);
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspGetEndOfTraining::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspGetEndOfTraining::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetEndOfTraining failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspGetEndOfTraining failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspGetEndOfTraining failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspGetEndOfTraining failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	if(!ss_1->decoded->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode RspGetEndOfTraining failed: timestamp is not an int: %s", ss_1->decoded->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_2 = (PyRepInteger *) ss_1->decoded;
	timestamp = int64_2->value;

	delete packet;
	return(true);
}

RspGetEndOfTraining *RspGetEndOfTraining::Clone() const {
	RspGetEndOfTraining *res = new RspGetEndOfTraining;
	/*  0  */
	res->timestamp = timestamp;

	return(res);
}


