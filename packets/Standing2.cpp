/*  EVEmu: EVE Online Server Emulator
  
  **************************************************************
  This file is automatically generated, DO NOT EDIT IT DIRECTLY.
  **************************************************************
  
  (If you need to customize an object, you must copy that object
  into another source file, and give up the ability to generate it)
  
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; version 2 of the License.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY except by those people which sell it, which
  are required to give you total support for your newly bought product;
  without even the implied warranty of MERCHANTABILITY or FITNESS FOR
  A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/


#include <string>
#include "../packets/Standing2.h"
#include "../common/PyRep.h"




Call_GetStandingTransactions::Call_GetStandingTransactions() {
	fromID = 0;
	toID = 0;
	direction = 0;
	/*  3: eventID  */
	/*  4: eventType  */
	/*  5: eventDateTime  */
}

Call_GetStandingTransactions::~Call_GetStandingTransactions() {
	/*  3: eventID  */
	/*  4: eventType  */
	/*  5: eventDateTime  */
}

void Call_GetStandingTransactions::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_GetStandingTransactions", pfx);
	_log(l_type, "%sfromID=%lu", pfx, fromID);
	_log(l_type, "%stoID=%lu", pfx, toID);
	_log(l_type, "%sdirection=%lu", pfx, direction);
	/*  3: eventID  */
	/*  4: eventType  */
	/*  5: eventDateTime  */
}

PyRepTuple *Call_GetStandingTransactions::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(6);
	tuple0->items[0] = new PyRepInteger(fromID);
	tuple0->items[1] = new PyRepInteger(toID);
	tuple0->items[2] = new PyRepInteger(direction);
	/*  3: eventID  */
	tuple0->items[3] = new PyRepNone();
	/*  4: eventType  */
	tuple0->items[4] = new PyRepNone();
	/*  5: eventDateTime  */
	tuple0->items[5] = new PyRepNone();
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_GetStandingTransactions::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(6);
	tuple0->items[0] = new PyRepInteger(fromID);
	tuple0->items[1] = new PyRepInteger(toID);
	tuple0->items[2] = new PyRepInteger(direction);
	/*  3: eventID  */
	tuple0->items[3] = new PyRepNone();
	/*  4: eventType  */
	tuple0->items[4] = new PyRepNone();
	/*  5: eventDateTime  */
	tuple0->items[5] = new PyRepNone();
	res = tuple0;
	

	return(res);
}

bool Call_GetStandingTransactions::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_GetStandingTransactions::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetStandingTransactions failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 6) {
		_log(NET__PACKET_ERROR, "Decode Call_GetStandingTransactions failed: tuple0 is the wrong size: expected 6, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetStandingTransactions failed: fromID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_GetStandingTransactions: truncating 64 bit into into 32 bit int for field fromID");
	}
	fromID = int_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetStandingTransactions failed: toID is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_GetStandingTransactions: truncating 64 bit into into 32 bit int for field toID");
	}
	toID = int_2->value;
	if(!tuple0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetStandingTransactions failed: direction is not an int: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple0->items[2];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_GetStandingTransactions: truncating 64 bit into into 32 bit int for field direction");
	}
	direction = int_3->value;
	/*  3: eventID  */
	if(!tuple0->items[3]->CheckType(PyRep::None)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetStandingTransactions failed: expecting a None but got a %s", tuple0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	
	/*  4: eventType  */
	if(!tuple0->items[4]->CheckType(PyRep::None)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetStandingTransactions failed: expecting a None but got a %s", tuple0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	
	/*  5: eventDateTime  */
	if(!tuple0->items[5]->CheckType(PyRep::None)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetStandingTransactions failed: expecting a None but got a %s", tuple0->items[5]->TypeString());
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

Call_GetStandingTransactions *Call_GetStandingTransactions::Clone() const {
	Call_GetStandingTransactions *res = new Call_GetStandingTransactions;
	res->CloneFrom(this);
	return(res);
}

void Call_GetStandingTransactions::CloneFrom(const Call_GetStandingTransactions *from) {
	fromID = from->fromID;
	toID = from->toID;
	direction = from->direction;
	/*  3: eventID  */
	/*  4: eventType  */
	/*  5: eventDateTime  */
	
}



