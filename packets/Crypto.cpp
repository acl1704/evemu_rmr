/*  EVEmu: EVE Online Server Emulator
  
  **************************************************************
  This file is automatically generated, DO NOT EDIT IT DIRECTLY.
  **************************************************************
  
  (If you need to customize an object, you must copy that object
  into another source file, and give up the ability to generate it)
  
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; version 2 of the License.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY except by those people which sell it, which
  are required to give you total support for your newly bought product;
  without even the implied warranty of MERCHANTABILITY or FITNESS FOR
  A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/


#include <string>
#include "../packets/Crypto.h"
#include "../common/PyRep.h"



	/*  this is not being used at the moment, more hrer for completeness  */

VersionExchange::VersionExchange() {
	birthday = 0;
	macho_version = 0;
	user_count = 0;
	version_number = 0.0;
	build_version = 0;
	project_version = "";
}

VersionExchange::~VersionExchange() {
}

void VersionExchange::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sVersionExchange", pfx);
	_log(l_type, "%sbirthday=%lu", pfx, birthday);
	_log(l_type, "%smacho_version=%lu", pfx, macho_version);
	_log(l_type, "%suser_count=%lu", pfx, user_count);
	_log(l_type, "%sversion_number=%.13f", pfx, version_number);
	_log(l_type, "%sbuild_version=%lu", pfx, build_version);
	_log(l_type, "%sproject_version='%s'", pfx, project_version.c_str());
}

PyRepTuple *VersionExchange::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(6);
	tuple0->items[0] = new PyRepInteger(birthday);
	tuple0->items[1] = new PyRepInteger(macho_version);
	tuple0->items[2] = new PyRepInteger(user_count);
	tuple0->items[3] = new PyRepReal(version_number);
	tuple0->items[4] = new PyRepInteger(build_version);
	tuple0->items[5] = new PyRepString(project_version);
	res = tuple0;
	

	return(res);
}

PyRepTuple *VersionExchange::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(6);
	tuple0->items[0] = new PyRepInteger(birthday);
	tuple0->items[1] = new PyRepInteger(macho_version);
	tuple0->items[2] = new PyRepInteger(user_count);
	tuple0->items[3] = new PyRepReal(version_number);
	tuple0->items[4] = new PyRepInteger(build_version);
	tuple0->items[5] = new PyRepString(project_version);
	res = tuple0;
	

	return(res);
}

bool VersionExchange::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool VersionExchange::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode VersionExchange failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 6) {
		_log(NET__PACKET_ERROR, "Decode VersionExchange failed: tuple0 is the wrong size: expected 6, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode VersionExchange failed: birthday is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode VersionExchange: truncating 64 bit into into 32 bit int for field birthday");
	}
	birthday = int_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode VersionExchange failed: macho_version is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode VersionExchange: truncating 64 bit into into 32 bit int for field macho_version");
	}
	macho_version = int_2->value;
	if(!tuple0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode VersionExchange failed: user_count is not an int: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple0->items[2];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode VersionExchange: truncating 64 bit into into 32 bit int for field user_count");
	}
	user_count = int_3->value;
	if(!tuple0->items[3]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode VersionExchange failed: version_number is not a real: %s", tuple0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_4 = (PyRepReal *) tuple0->items[3];
	version_number = real_4->value;
	if(!tuple0->items[4]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode VersionExchange failed: build_version is not an int: %s", tuple0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) tuple0->items[4];
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode VersionExchange: truncating 64 bit into into 32 bit int for field build_version");
	}
	build_version = int_5->value;
	if(!tuple0->items[5]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode VersionExchange failed: project_version is not a string: %s", tuple0->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_6 = (PyRepString *) tuple0->items[5];
	project_version = string_6->value;

	delete packet;
	return(true);
}

VersionExchange *VersionExchange::Clone() const {
	VersionExchange *res = new VersionExchange;
	res->CloneFrom(this);
	return(res);
}

void VersionExchange::CloneFrom(const VersionExchange *from) {
	birthday = from->birthday;
	macho_version = from->macho_version;
	user_count = from->user_count;
	version_number = from->version_number;
	build_version = from->build_version;
	project_version = from->project_version;
	
}


CryptoRequestPacket::CryptoRequestPacket() {
	/*  0  */
	keyVersion = "";
	/*  1  */
}

CryptoRequestPacket::~CryptoRequestPacket() {
	/*  0  */
	/*  1  */
}

void CryptoRequestPacket::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCryptoRequestPacket", pfx);
	/*  0  */
	_log(l_type, "%skeyVersion='%s'", pfx, keyVersion.c_str());
	/*  1  */
	_log(l_type, "%skeyParams: ", pfx);
	std::string keyParams_n(pfx);
	keyParams_n += "    ";
	keyParams.Dump(l_type, keyParams_n.c_str());
}

PyRepTuple *CryptoRequestPacket::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(keyVersion);
	/*  1  */
	tuple0->items[1] = keyParams.Clone();
	res = tuple0;
	

	return(res);
}

PyRepTuple *CryptoRequestPacket::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(keyVersion);
	/*  1  */
	
	PyRepDict *dict1 = new PyRepDict();
	dict1->items = keyParams.items;
	keyParams.items.clear();
	tuple0->items[1] = dict1;
	res = tuple0;
	

	return(res);
}

bool CryptoRequestPacket::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CryptoRequestPacket::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CryptoRequestPacket failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode CryptoRequestPacket failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode CryptoRequestPacket failed: keyVersion is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	keyVersion = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode CryptoRequestPacket failed: keyParams is not a dict: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepDict *list_keyParams = (PyRepDict *) tuple0->items[1];	keyParams.items = list_keyParams->items;
	list_keyParams->items.clear();
	

	delete packet;
	return(true);
}

CryptoRequestPacket *CryptoRequestPacket::Clone() const {
	CryptoRequestPacket *res = new CryptoRequestPacket;
	res->CloneFrom(this);
	return(res);
}

void CryptoRequestPacket::CloneFrom(const CryptoRequestPacket *from) {
	/*  0  */
	keyVersion = from->keyVersion;
	/*  1  */
	keyParams.CloneFrom(&from->keyParams);
	
}


CryptoAPIRequestPacket::CryptoAPIRequestPacket() {
	/*  0  */
	keyVersion = "";
	/*  1  */
	sessionkey = "";
	hashmethod = "";
	sessionkeylength = 0;
	provider = "";
	sessionkeymethod = "";
}

CryptoAPIRequestPacket::~CryptoAPIRequestPacket() {
	/*  0  */
	/*  1  */
}

void CryptoAPIRequestPacket::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCryptoAPIRequestPacket", pfx);
	/*  0  */
	_log(l_type, "%skeyVersion='%s'", pfx, keyVersion.c_str());
	/*  1  */
	_log(l_type, "%ssessionkey='%s'", pfx, sessionkey.c_str());
	_log(l_type, "%shashmethod='%s'", pfx, hashmethod.c_str());
	_log(l_type, "%ssessionkeylength=%lu", pfx, sessionkeylength);
	_log(l_type, "%sprovider='%s'", pfx, provider.c_str());
	_log(l_type, "%ssessionkeymethod='%s'", pfx, sessionkeymethod.c_str());
}

PyRepTuple *CryptoAPIRequestPacket::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(keyVersion);
	/*  1  */
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	dict1_0 = new PyRepString(sessionkey);
	dict1->items[
		new PyRepString("crypting_sessionkey")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepString(hashmethod);
	dict1->items[
		new PyRepString("signing_hashmethod")
	] = dict1_1;
	PyRep *dict1_2;
	dict1_2 = new PyRepInteger(sessionkeylength);
	dict1->items[
		new PyRepString("crypting_sessionkeylength")
	] = dict1_2;
	PyRep *dict1_3;
	dict1_3 = new PyRepString(provider);
	dict1->items[
		new PyRepString("crypting_securityprovidertype")
	] = dict1_3;
	PyRep *dict1_4;
	dict1_4 = new PyRepString(sessionkeymethod);
	dict1->items[
		new PyRepString("crypting_sessionkeymethod")
	] = dict1_4;
	tuple0->items[1] = dict1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *CryptoAPIRequestPacket::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(keyVersion);
	/*  1  */
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	dict1_0 = new PyRepString(sessionkey);
	dict1->items[
		new PyRepString("crypting_sessionkey")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepString(hashmethod);
	dict1->items[
		new PyRepString("signing_hashmethod")
	] = dict1_1;
	PyRep *dict1_2;
	dict1_2 = new PyRepInteger(sessionkeylength);
	dict1->items[
		new PyRepString("crypting_sessionkeylength")
	] = dict1_2;
	PyRep *dict1_3;
	dict1_3 = new PyRepString(provider);
	dict1->items[
		new PyRepString("crypting_securityprovidertype")
	] = dict1_3;
	PyRep *dict1_4;
	dict1_4 = new PyRepString(sessionkeymethod);
	dict1->items[
		new PyRepString("crypting_sessionkeymethod")
	] = dict1_4;
	tuple0->items[1] = dict1;
	
	res = tuple0;
	

	return(res);
}

bool CryptoAPIRequestPacket::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CryptoAPIRequestPacket::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CryptoAPIRequestPacket failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode CryptoAPIRequestPacket failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode CryptoAPIRequestPacket failed: keyVersion is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	keyVersion = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode CryptoAPIRequestPacket failed: dict2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	bool dict2_sessionkey = false;
	bool dict2_hashmethod = false;
	bool dict2_sessionkeylength = false;
	bool dict2_provider = false;
	bool dict2_sessionkeymethod = false;
	PyRepDict *dict2 = (PyRepDict *) tuple0->items[1];
	
	PyRepDict::iterator dict2_cur, dict2_end;
	dict2_cur = dict2->items.begin();
	dict2_end = dict2->items.end();
	for(; dict2_cur != dict2_end; dict2_cur++) {
		PyRep *key__ = dict2_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode CryptoAPIRequestPacket failed: a key in dict2 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "crypting_sessionkey") {
			dict2_sessionkey = true;
	if(!dict2_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode CryptoAPIRequestPacket failed: sessionkey is not a string: %s", dict2_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) dict2_cur->second;
	sessionkey = string_3->value;
		} else
		if(key_string__->value == "signing_hashmethod") {
			dict2_hashmethod = true;
	if(!dict2_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode CryptoAPIRequestPacket failed: hashmethod is not a string: %s", dict2_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_4 = (PyRepString *) dict2_cur->second;
	hashmethod = string_4->value;
		} else
		if(key_string__->value == "crypting_sessionkeylength") {
			dict2_sessionkeylength = true;
	if(!dict2_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CryptoAPIRequestPacket failed: sessionkeylength is not an int: %s", dict2_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) dict2_cur->second;
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CryptoAPIRequestPacket: truncating 64 bit into into 32 bit int for field sessionkeylength");
	}
	sessionkeylength = int_5->value;
		} else
		if(key_string__->value == "crypting_securityprovidertype") {
			dict2_provider = true;
	if(!dict2_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode CryptoAPIRequestPacket failed: provider is not a string: %s", dict2_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_6 = (PyRepString *) dict2_cur->second;
	provider = string_6->value;
		} else
		if(key_string__->value == "crypting_sessionkeymethod") {
			dict2_sessionkeymethod = true;
	if(!dict2_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode CryptoAPIRequestPacket failed: sessionkeymethod is not a string: %s", dict2_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_7 = (PyRepString *) dict2_cur->second;
	sessionkeymethod = string_7->value;
		} else
		{
			_log(NET__PACKET_ERROR, "Decode CryptoAPIRequestPacket failed: Unknown key string '%s' in dict2", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict2_sessionkey) {
		_log(NET__PACKET_ERROR, "Decode CryptoAPIRequestPacket failed: Missing dict entry for 'sessionkey' in dict2");
		delete packet;
		return(false);
	}
	
	if(!dict2_hashmethod) {
		_log(NET__PACKET_ERROR, "Decode CryptoAPIRequestPacket failed: Missing dict entry for 'hashmethod' in dict2");
		delete packet;
		return(false);
	}
	
	if(!dict2_sessionkeylength) {
		_log(NET__PACKET_ERROR, "Decode CryptoAPIRequestPacket failed: Missing dict entry for 'sessionkeylength' in dict2");
		delete packet;
		return(false);
	}
	
	if(!dict2_provider) {
		_log(NET__PACKET_ERROR, "Decode CryptoAPIRequestPacket failed: Missing dict entry for 'provider' in dict2");
		delete packet;
		return(false);
	}
	
	if(!dict2_sessionkeymethod) {
		_log(NET__PACKET_ERROR, "Decode CryptoAPIRequestPacket failed: Missing dict entry for 'sessionkeymethod' in dict2");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

CryptoAPIRequestPacket *CryptoAPIRequestPacket::Clone() const {
	CryptoAPIRequestPacket *res = new CryptoAPIRequestPacket;
	res->CloneFrom(this);
	return(res);
}

void CryptoAPIRequestPacket::CloneFrom(const CryptoAPIRequestPacket *from) {
	/*  0  */
	keyVersion = from->keyVersion;
	/*  1  */
	sessionkey = from->sessionkey;
	hashmethod = from->hashmethod;
	sessionkeylength = from->sessionkeylength;
	provider = from->provider;
	sessionkeymethod = from->sessionkeymethod;
	
}


CryptoChallengePacket::CryptoChallengePacket() {
	/*  0  */
	clientChallenge = "";
	/*  1  */
	macho_version = 0;
	boot_version = 0.0;
	boot_build = 0;
	boot_codename = "";
	boot_region = "";
	user_name = "";
	user_password = NULL;
	user_languageid = "";
	user_affiliateid = 0;
}

CryptoChallengePacket::~CryptoChallengePacket() {
	/*  0  */
	/*  1  */
	delete user_password;
}

void CryptoChallengePacket::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCryptoChallengePacket", pfx);
	/*  0  */
	_log(l_type, "%sclientChallenge='%s'", pfx, clientChallenge.c_str());
	/*  1  */
	_log(l_type, "%smacho_version=%lu", pfx, macho_version);
	_log(l_type, "%sboot_version=%.13f", pfx, boot_version);
	_log(l_type, "%sboot_build=%lu", pfx, boot_build);
	_log(l_type, "%sboot_codename='%s'", pfx, boot_codename.c_str());
	_log(l_type, "%sboot_region='%s'", pfx, boot_region.c_str());
	_log(l_type, "%suser_name='%s'", pfx, user_name.c_str());
	_log(l_type, "%suser_password:", pfx);
	std::string user_password_n(pfx);
	user_password_n += "    ";
	if(user_password == NULL) {
		_log(l_type, "%sERROR: NULL REP!", user_password_n.c_str());
	} else {
		user_password->Dump(l_type, user_password_n.c_str());
	}
	_log(l_type, "%suser_languageid='%s'", pfx, user_languageid.c_str());
	_log(l_type, "%suser_affiliateid=%lu", pfx, user_affiliateid);
}

PyRepSubStream *CryptoChallengePacket::Encode() {
	PyRepSubStream *res = NULL;
	PyRep *ss_0;
	PyRepTuple *tuple1 = new PyRepTuple(2);
	/*  0  */
	tuple1->items[0] = new PyRepString(clientChallenge);
	/*  1  */
	PyRepDict *dict2 = new PyRepDict();
	PyRep *dict2_0;
	dict2_0 = new PyRepInteger(macho_version);
	dict2->items[
		new PyRepString("macho_version")
	] = dict2_0;
	PyRep *dict2_1;
	dict2_1 = new PyRepReal(boot_version);
	dict2->items[
		new PyRepString("boot_version")
	] = dict2_1;
	PyRep *dict2_2;
	dict2_2 = new PyRepInteger(boot_build);
	dict2->items[
		new PyRepString("boot_build")
	] = dict2_2;
	PyRep *dict2_3;
	dict2_3 = new PyRepString(boot_codename);
	dict2->items[
		new PyRepString("boot_codename")
	] = dict2_3;
	PyRep *dict2_4;
	dict2_4 = new PyRepString(boot_region);
	dict2->items[
		new PyRepString("boot_region")
	] = dict2_4;
	PyRep *dict2_5;
	dict2_5 = new PyRepString(user_name);
	dict2->items[
		new PyRepString("user_name")
	] = dict2_5;
	PyRep *dict2_6;
	if(user_password == NULL) {
		_log(NET__PACKET_ERROR, "Encode CryptoChallengePacket: user_password is NULL! hacking in a PyRepNone");
		user_password = new PyRepNone();
	}
	dict2_6 = user_password->Clone();
	dict2->items[
		new PyRepString("user_password")
	] = dict2_6;
	PyRep *dict2_7;
	dict2_7 = new PyRepString(user_languageid);
	dict2->items[
		new PyRepString("user_languageid")
	] = dict2_7;
	PyRep *dict2_8;
	dict2_8 = new PyRepInteger(user_affiliateid);
	dict2->items[
		new PyRepString("user_affiliateid")
	] = dict2_8;
	tuple1->items[1] = dict2;
	
	ss_0 = tuple1;
	
	res = new PyRepSubStream(ss_0);

	return(res);
}

PyRepSubStream *CryptoChallengePacket::FastEncode() {
	PyRepSubStream *res = NULL;
	PyRep *ss_0;
	PyRepTuple *tuple1 = new PyRepTuple(2);
	/*  0  */
	tuple1->items[0] = new PyRepString(clientChallenge);
	/*  1  */
	PyRepDict *dict2 = new PyRepDict();
	PyRep *dict2_0;
	dict2_0 = new PyRepInteger(macho_version);
	dict2->items[
		new PyRepString("macho_version")
	] = dict2_0;
	PyRep *dict2_1;
	dict2_1 = new PyRepReal(boot_version);
	dict2->items[
		new PyRepString("boot_version")
	] = dict2_1;
	PyRep *dict2_2;
	dict2_2 = new PyRepInteger(boot_build);
	dict2->items[
		new PyRepString("boot_build")
	] = dict2_2;
	PyRep *dict2_3;
	dict2_3 = new PyRepString(boot_codename);
	dict2->items[
		new PyRepString("boot_codename")
	] = dict2_3;
	PyRep *dict2_4;
	dict2_4 = new PyRepString(boot_region);
	dict2->items[
		new PyRepString("boot_region")
	] = dict2_4;
	PyRep *dict2_5;
	dict2_5 = new PyRepString(user_name);
	dict2->items[
		new PyRepString("user_name")
	] = dict2_5;
	PyRep *dict2_6;
	if(user_password == NULL) {
		_log(NET__PACKET_ERROR, "Encode CryptoChallengePacket: user_password is NULL! hacking in a PyRepNone");
		user_password = new PyRepNone();
	}
	dict2_6 = user_password;
	user_password = NULL;
	dict2->items[
		new PyRepString("user_password")
	] = dict2_6;
	PyRep *dict2_7;
	dict2_7 = new PyRepString(user_languageid);
	dict2->items[
		new PyRepString("user_languageid")
	] = dict2_7;
	PyRep *dict2_8;
	dict2_8 = new PyRepInteger(user_affiliateid);
	dict2->items[
		new PyRepString("user_affiliateid")
	] = dict2_8;
	tuple1->items[1] = dict2;
	
	ss_0 = tuple1;
	
	res = new PyRepSubStream(ss_0);

	return(res);
}

bool CryptoChallengePacket::Decode(PyRepSubStream **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CryptoChallengePacket::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode CryptoChallengePacket failed: ss_0 is not a substream: %s", packet->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_0 = (PyRepSubStream *) packet;
	//make sure its decoded
	ss_0->DecodeData();
	if(ss_0->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode CryptoChallengePacket failed: Unable to decode ss_0");
		delete packet;
		return(false);
	}
	
	if(!ss_0->decoded->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CryptoChallengePacket failed: tuple1 is the wrong type: %s", ss_0->decoded->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple1 = (PyRepTuple *) ss_0->decoded;
	if(tuple1->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode CryptoChallengePacket failed: tuple1 is the wrong size: expected 2, but got %d", tuple1->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple1->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode CryptoChallengePacket failed: clientChallenge is not a string: %s", tuple1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple1->items[0];
	clientChallenge = string_2->value;
	/*  1  */
	if(!tuple1->items[1]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode CryptoChallengePacket failed: dict3 is the wrong type: %s", tuple1->items[1]->TypeString());
		delete packet;
		return(false);
	}
	bool dict3_macho_version = false;
	bool dict3_boot_version = false;
	bool dict3_boot_build = false;
	bool dict3_boot_codename = false;
	bool dict3_boot_region = false;
	bool dict3_user_name = false;
	bool dict3_user_password = false;
	bool dict3_user_languageid = false;
	bool dict3_user_affiliateid = false;
	PyRepDict *dict3 = (PyRepDict *) tuple1->items[1];
	
	PyRepDict::iterator dict3_cur, dict3_end;
	dict3_cur = dict3->items.begin();
	dict3_end = dict3->items.end();
	for(; dict3_cur != dict3_end; dict3_cur++) {
		PyRep *key__ = dict3_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode CryptoChallengePacket failed: a key in dict3 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "macho_version") {
			dict3_macho_version = true;
	if(!dict3_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CryptoChallengePacket failed: macho_version is not an int: %s", dict3_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) dict3_cur->second;
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CryptoChallengePacket: truncating 64 bit into into 32 bit int for field macho_version");
	}
	macho_version = int_4->value;
		} else
		if(key_string__->value == "boot_version") {
			dict3_boot_version = true;
	if(!dict3_cur->second->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode CryptoChallengePacket failed: boot_version is not a real: %s", dict3_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_5 = (PyRepReal *) dict3_cur->second;
	boot_version = real_5->value;
		} else
		if(key_string__->value == "boot_build") {
			dict3_boot_build = true;
	if(!dict3_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CryptoChallengePacket failed: boot_build is not an int: %s", dict3_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_6 = (PyRepInteger *) dict3_cur->second;
	if(int_6->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CryptoChallengePacket: truncating 64 bit into into 32 bit int for field boot_build");
	}
	boot_build = int_6->value;
		} else
		if(key_string__->value == "boot_codename") {
			dict3_boot_codename = true;
	if(!dict3_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode CryptoChallengePacket failed: boot_codename is not a string: %s", dict3_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_7 = (PyRepString *) dict3_cur->second;
	boot_codename = string_7->value;
		} else
		if(key_string__->value == "boot_region") {
			dict3_boot_region = true;
	if(!dict3_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode CryptoChallengePacket failed: boot_region is not a string: %s", dict3_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_8 = (PyRepString *) dict3_cur->second;
	boot_region = string_8->value;
		} else
		if(key_string__->value == "user_name") {
			dict3_user_name = true;
	if(!dict3_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode CryptoChallengePacket failed: user_name is not a string: %s", dict3_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_9 = (PyRepString *) dict3_cur->second;
	user_name = string_9->value;
		} else
		if(key_string__->value == "user_password") {
			dict3_user_password = true;
	delete user_password;
	user_password = dict3_cur->second;
	dict3_cur->second = NULL;
	
		} else
		if(key_string__->value == "user_languageid") {
			dict3_user_languageid = true;
	if(!dict3_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode CryptoChallengePacket failed: user_languageid is not a string: %s", dict3_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_10 = (PyRepString *) dict3_cur->second;
	user_languageid = string_10->value;
		} else
		if(key_string__->value == "user_affiliateid") {
			dict3_user_affiliateid = true;
	if(!dict3_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CryptoChallengePacket failed: user_affiliateid is not an int: %s", dict3_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_11 = (PyRepInteger *) dict3_cur->second;
	if(int_11->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CryptoChallengePacket: truncating 64 bit into into 32 bit int for field user_affiliateid");
	}
	user_affiliateid = int_11->value;
		} else
		{
			_log(NET__PACKET_ERROR, "Decode CryptoChallengePacket failed: Unknown key string '%s' in dict3", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict3_macho_version) {
		_log(NET__PACKET_ERROR, "Decode CryptoChallengePacket failed: Missing dict entry for 'macho_version' in dict3");
		delete packet;
		return(false);
	}
	
	if(!dict3_boot_version) {
		_log(NET__PACKET_ERROR, "Decode CryptoChallengePacket failed: Missing dict entry for 'boot_version' in dict3");
		delete packet;
		return(false);
	}
	
	if(!dict3_boot_build) {
		_log(NET__PACKET_ERROR, "Decode CryptoChallengePacket failed: Missing dict entry for 'boot_build' in dict3");
		delete packet;
		return(false);
	}
	
	if(!dict3_boot_codename) {
		_log(NET__PACKET_ERROR, "Decode CryptoChallengePacket failed: Missing dict entry for 'boot_codename' in dict3");
		delete packet;
		return(false);
	}
	
	if(!dict3_boot_region) {
		_log(NET__PACKET_ERROR, "Decode CryptoChallengePacket failed: Missing dict entry for 'boot_region' in dict3");
		delete packet;
		return(false);
	}
	
	if(!dict3_user_name) {
		_log(NET__PACKET_ERROR, "Decode CryptoChallengePacket failed: Missing dict entry for 'user_name' in dict3");
		delete packet;
		return(false);
	}
	
	if(!dict3_user_password) {
		_log(NET__PACKET_ERROR, "Decode CryptoChallengePacket failed: Missing dict entry for 'user_password' in dict3");
		delete packet;
		return(false);
	}
	
	if(!dict3_user_languageid) {
		_log(NET__PACKET_ERROR, "Decode CryptoChallengePacket failed: Missing dict entry for 'user_languageid' in dict3");
		delete packet;
		return(false);
	}
	
	if(!dict3_user_affiliateid) {
		_log(NET__PACKET_ERROR, "Decode CryptoChallengePacket failed: Missing dict entry for 'user_affiliateid' in dict3");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

CryptoChallengePacket *CryptoChallengePacket::Clone() const {
	CryptoChallengePacket *res = new CryptoChallengePacket;
	res->CloneFrom(this);
	return(res);
}

void CryptoChallengePacket::CloneFrom(const CryptoChallengePacket *from) {
	/*  0  */
	clientChallenge = from->clientChallenge;
	/*  1  */
	macho_version = from->macho_version;
	boot_version = from->boot_version;
	boot_build = from->boot_build;
	boot_codename = from->boot_codename;
	boot_region = from->boot_region;
	user_name = from->user_name;
	delete user_password;
	if(from->user_password == NULL) {
		user_password = NULL;
	} else {
		user_password = from->user_password->Clone();
	}
	user_languageid = from->user_languageid;
	user_affiliateid = from->user_affiliateid;
	
}


CryptoServerHandshake::CryptoServerHandshake() {
	/*  0: serverChallenge  */
	serverChallenge = "";
	/*  1: func  */
	func = "";
	/*  2: context  */
	/*  3: response  */
	challenge_responsehash = "";
	macho_version = 0;
	boot_version = 0.0;
	boot_build = 0;
	boot_codename = "";
	boot_region = "";
	cluster_usercount = 0;
	proxy_nodeid = 0;
	user_logonqueueposition = 0;
}

CryptoServerHandshake::~CryptoServerHandshake() {
	/*  0: serverChallenge  */
	/*  1: func  */
	/*  2: context  */
	std::map<std::string, PyRep *>::iterator context_cur, context_end;
	//free any existing elements first
	context_cur = context.begin();
	context_end = context.end();
	for(; context_cur != context_end; context_cur++) {
		delete context_cur->second;
	}
	
	/*  3: response  */
}

void CryptoServerHandshake::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCryptoServerHandshake", pfx);
	/*  0: serverChallenge  */
	_log(l_type, "%sserverChallenge='%s'", pfx, serverChallenge.c_str());
	/*  1: func  */
	_log(l_type, "%sfunc='%s'", pfx, func.c_str());
	/*  2: context  */
	_log(l_type, "%scontext: Dictionaty with %d enetires", pfx, context.size());
	std::map<std::string, PyRep *>::const_iterator context_cur, context_end;
	context_cur = context.begin();
	context_end = context.end();
	for(; context_cur != context_end; context_cur++) {
		_log(l_type, "%s Key: %s", pfx, context_cur->first.c_str());
		std::string n(pfx);
		n += "      ";
		context_cur->second->Dump(stdout, n.c_str());
	}
	
	/*  3: response  */
	_log(l_type, "%schallenge_responsehash='%s'", pfx, challenge_responsehash.c_str());
	_log(l_type, "%smacho_version=%lu", pfx, macho_version);
	_log(l_type, "%sboot_version=%.13f", pfx, boot_version);
	_log(l_type, "%sboot_build=%lu", pfx, boot_build);
	_log(l_type, "%sboot_codename='%s'", pfx, boot_codename.c_str());
	_log(l_type, "%sboot_region='%s'", pfx, boot_region.c_str());
	_log(l_type, "%scluster_usercount=%lu", pfx, cluster_usercount);
	_log(l_type, "%sproxy_nodeid=%lu", pfx, proxy_nodeid);
	_log(l_type, "%suser_logonqueueposition=%lu", pfx, user_logonqueueposition);
}

PyRepSubStream *CryptoServerHandshake::Encode() {
	PyRepSubStream *res = NULL;
	PyRep *ss_0;
	PyRepTuple *tuple1 = new PyRepTuple(4);
	/*  0: serverChallenge  */
	tuple1->items[0] = new PyRepString(serverChallenge);
	/*  1: func  */
	tuple1->items[1] = new PyRepString(func);
	/*  2: context  */
	
	PyRepDict *dict2 = new PyRepDict();
	std::map<std::string, PyRep *>::iterator context_cur, context_end;
	context_cur = context.begin();
	context_end = context.end();
	for(; context_cur != context_end; context_cur++) {
		dict2->items[
			new PyRepString(context_cur->first)
		] = context_cur->second->Clone();
	}
	tuple1->items[2] = dict2;
	
	/*  3: response  */
	PyRepDict *dict3 = new PyRepDict();
	PyRep *dict3_0;
	dict3_0 = new PyRepString(challenge_responsehash);
	dict3->items[
		new PyRepString("challenge_responsehash")
	] = dict3_0;
	PyRep *dict3_1;
	dict3_1 = new PyRepInteger(macho_version);
	dict3->items[
		new PyRepString("macho_version")
	] = dict3_1;
	PyRep *dict3_2;
	dict3_2 = new PyRepReal(boot_version);
	dict3->items[
		new PyRepString("boot_version")
	] = dict3_2;
	PyRep *dict3_3;
	dict3_3 = new PyRepInteger(boot_build);
	dict3->items[
		new PyRepString("boot_build")
	] = dict3_3;
	PyRep *dict3_4;
	dict3_4 = new PyRepString(boot_codename);
	dict3->items[
		new PyRepString("boot_codename")
	] = dict3_4;
	PyRep *dict3_5;
	dict3_5 = new PyRepString(boot_region);
	dict3->items[
		new PyRepString("boot_region")
	] = dict3_5;
	PyRep *dict3_6;
	dict3_6 = new PyRepInteger(cluster_usercount);
	dict3->items[
		new PyRepString("cluster_usercount")
	] = dict3_6;
	PyRep *dict3_7;
	dict3_7 = new PyRepInteger(proxy_nodeid);
	dict3->items[
		new PyRepString("proxy_nodeid")
	] = dict3_7;
	PyRep *dict3_8;
	dict3_8 = new PyRepInteger(user_logonqueueposition);
	dict3->items[
		new PyRepString("user_logonqueueposition")
	] = dict3_8;
	tuple1->items[3] = dict3;
	
	ss_0 = tuple1;
	
	res = new PyRepSubStream(ss_0);

	return(res);
}

PyRepSubStream *CryptoServerHandshake::FastEncode() {
	PyRepSubStream *res = NULL;
	PyRep *ss_0;
	PyRepTuple *tuple1 = new PyRepTuple(4);
	/*  0: serverChallenge  */
	tuple1->items[0] = new PyRepString(serverChallenge);
	/*  1: func  */
	tuple1->items[1] = new PyRepString(func);
	/*  2: context  */
	
	PyRepDict *dict2 = new PyRepDict();
	std::map<std::string, PyRep *>::iterator context_cur, context_end;
	context_cur = context.begin();
	context_end = context.end();
	for(; context_cur != context_end; context_cur++) {
		dict2->items[
			new PyRepString(context_cur->first)
		] = context_cur->second;
	}
	context.clear();
	tuple1->items[2] = dict2;
	
	/*  3: response  */
	PyRepDict *dict3 = new PyRepDict();
	PyRep *dict3_0;
	dict3_0 = new PyRepString(challenge_responsehash);
	dict3->items[
		new PyRepString("challenge_responsehash")
	] = dict3_0;
	PyRep *dict3_1;
	dict3_1 = new PyRepInteger(macho_version);
	dict3->items[
		new PyRepString("macho_version")
	] = dict3_1;
	PyRep *dict3_2;
	dict3_2 = new PyRepReal(boot_version);
	dict3->items[
		new PyRepString("boot_version")
	] = dict3_2;
	PyRep *dict3_3;
	dict3_3 = new PyRepInteger(boot_build);
	dict3->items[
		new PyRepString("boot_build")
	] = dict3_3;
	PyRep *dict3_4;
	dict3_4 = new PyRepString(boot_codename);
	dict3->items[
		new PyRepString("boot_codename")
	] = dict3_4;
	PyRep *dict3_5;
	dict3_5 = new PyRepString(boot_region);
	dict3->items[
		new PyRepString("boot_region")
	] = dict3_5;
	PyRep *dict3_6;
	dict3_6 = new PyRepInteger(cluster_usercount);
	dict3->items[
		new PyRepString("cluster_usercount")
	] = dict3_6;
	PyRep *dict3_7;
	dict3_7 = new PyRepInteger(proxy_nodeid);
	dict3->items[
		new PyRepString("proxy_nodeid")
	] = dict3_7;
	PyRep *dict3_8;
	dict3_8 = new PyRepInteger(user_logonqueueposition);
	dict3->items[
		new PyRepString("user_logonqueueposition")
	] = dict3_8;
	tuple1->items[3] = dict3;
	
	ss_0 = tuple1;
	
	res = new PyRepSubStream(ss_0);

	return(res);
}

bool CryptoServerHandshake::Decode(PyRepSubStream **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CryptoServerHandshake::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: ss_0 is not a substream: %s", packet->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_0 = (PyRepSubStream *) packet;
	//make sure its decoded
	ss_0->DecodeData();
	if(ss_0->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: Unable to decode ss_0");
		delete packet;
		return(false);
	}
	
	if(!ss_0->decoded->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: tuple1 is the wrong type: %s", ss_0->decoded->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple1 = (PyRepTuple *) ss_0->decoded;
	if(tuple1->items.size() != 4) {
		_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: tuple1 is the wrong size: expected 4, but got %d", tuple1->items.size());
		delete packet;
		return(false);
	}

	/*  0: serverChallenge  */
	if(!tuple1->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: serverChallenge is not a string: %s", tuple1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple1->items[0];
	serverChallenge = string_2->value;
	/*  1: func  */
	if(!tuple1->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: func is not a string: %s", tuple1->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) tuple1->items[1];
	func = string_3->value;
	/*  2: context  */
	if(!tuple1->items[2]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: context is not a dict: %s", tuple1->items[2]->TypeString());
		delete packet;
		return(false);
	}
	context.clear();
	PyRepDict *dict_4 = (PyRepDict *) tuple1->items[2];
	PyRepDict::iterator context_cur, context_end;
	context_cur = dict_4->items.begin();
	context_end = dict_4->items.end();
	int context_index;
	for(context_index = 0; context_cur != context_end; context_cur++, context_index++) {
		if(!context_cur->first->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: Key %d in dict context is not a string: %s", context_index, context_cur->first->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *k = (PyRepString *) context_cur->first;
		context[k->value] = context_cur->second->Clone();
	}
	
	/*  3: response  */
	if(!tuple1->items[3]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: dict5 is the wrong type: %s", tuple1->items[3]->TypeString());
		delete packet;
		return(false);
	}
	bool dict5_challenge_responsehash = false;
	bool dict5_macho_version = false;
	bool dict5_boot_version = false;
	bool dict5_boot_build = false;
	bool dict5_boot_codename = false;
	bool dict5_boot_region = false;
	bool dict5_cluster_usercount = false;
	bool dict5_proxy_nodeid = false;
	bool dict5_user_logonqueueposition = false;
	PyRepDict *dict5 = (PyRepDict *) tuple1->items[3];
	
	PyRepDict::iterator dict5_cur, dict5_end;
	dict5_cur = dict5->items.begin();
	dict5_end = dict5->items.end();
	for(; dict5_cur != dict5_end; dict5_cur++) {
		PyRep *key__ = dict5_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: a key in dict5 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "challenge_responsehash") {
			dict5_challenge_responsehash = true;
	if(!dict5_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: challenge_responsehash is not a string: %s", dict5_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_6 = (PyRepString *) dict5_cur->second;
	challenge_responsehash = string_6->value;
		} else
		if(key_string__->value == "macho_version") {
			dict5_macho_version = true;
	if(!dict5_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: macho_version is not an int: %s", dict5_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_7 = (PyRepInteger *) dict5_cur->second;
	if(int_7->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CryptoServerHandshake: truncating 64 bit into into 32 bit int for field macho_version");
	}
	macho_version = int_7->value;
		} else
		if(key_string__->value == "boot_version") {
			dict5_boot_version = true;
	if(!dict5_cur->second->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: boot_version is not a real: %s", dict5_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_8 = (PyRepReal *) dict5_cur->second;
	boot_version = real_8->value;
		} else
		if(key_string__->value == "boot_build") {
			dict5_boot_build = true;
	if(!dict5_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: boot_build is not an int: %s", dict5_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_9 = (PyRepInteger *) dict5_cur->second;
	if(int_9->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CryptoServerHandshake: truncating 64 bit into into 32 bit int for field boot_build");
	}
	boot_build = int_9->value;
		} else
		if(key_string__->value == "boot_codename") {
			dict5_boot_codename = true;
	if(!dict5_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: boot_codename is not a string: %s", dict5_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_10 = (PyRepString *) dict5_cur->second;
	boot_codename = string_10->value;
		} else
		if(key_string__->value == "boot_region") {
			dict5_boot_region = true;
	if(!dict5_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: boot_region is not a string: %s", dict5_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_11 = (PyRepString *) dict5_cur->second;
	boot_region = string_11->value;
		} else
		if(key_string__->value == "cluster_usercount") {
			dict5_cluster_usercount = true;
	if(!dict5_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: cluster_usercount is not an int: %s", dict5_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_12 = (PyRepInteger *) dict5_cur->second;
	if(int_12->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CryptoServerHandshake: truncating 64 bit into into 32 bit int for field cluster_usercount");
	}
	cluster_usercount = int_12->value;
		} else
		if(key_string__->value == "proxy_nodeid") {
			dict5_proxy_nodeid = true;
	if(!dict5_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: proxy_nodeid is not an int: %s", dict5_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_13 = (PyRepInteger *) dict5_cur->second;
	if(int_13->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CryptoServerHandshake: truncating 64 bit into into 32 bit int for field proxy_nodeid");
	}
	proxy_nodeid = int_13->value;
		} else
		if(key_string__->value == "user_logonqueueposition") {
			dict5_user_logonqueueposition = true;
	if(!dict5_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: user_logonqueueposition is not an int: %s", dict5_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_14 = (PyRepInteger *) dict5_cur->second;
	if(int_14->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CryptoServerHandshake: truncating 64 bit into into 32 bit int for field user_logonqueueposition");
	}
	user_logonqueueposition = int_14->value;
		} else
		{
			_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: Unknown key string '%s' in dict5", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict5_challenge_responsehash) {
		_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: Missing dict entry for 'challenge_responsehash' in dict5");
		delete packet;
		return(false);
	}
	
	if(!dict5_macho_version) {
		_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: Missing dict entry for 'macho_version' in dict5");
		delete packet;
		return(false);
	}
	
	if(!dict5_boot_version) {
		_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: Missing dict entry for 'boot_version' in dict5");
		delete packet;
		return(false);
	}
	
	if(!dict5_boot_build) {
		_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: Missing dict entry for 'boot_build' in dict5");
		delete packet;
		return(false);
	}
	
	if(!dict5_boot_codename) {
		_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: Missing dict entry for 'boot_codename' in dict5");
		delete packet;
		return(false);
	}
	
	if(!dict5_boot_region) {
		_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: Missing dict entry for 'boot_region' in dict5");
		delete packet;
		return(false);
	}
	
	if(!dict5_cluster_usercount) {
		_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: Missing dict entry for 'cluster_usercount' in dict5");
		delete packet;
		return(false);
	}
	
	if(!dict5_proxy_nodeid) {
		_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: Missing dict entry for 'proxy_nodeid' in dict5");
		delete packet;
		return(false);
	}
	
	if(!dict5_user_logonqueueposition) {
		_log(NET__PACKET_ERROR, "Decode CryptoServerHandshake failed: Missing dict entry for 'user_logonqueueposition' in dict5");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

CryptoServerHandshake *CryptoServerHandshake::Clone() const {
	CryptoServerHandshake *res = new CryptoServerHandshake;
	res->CloneFrom(this);
	return(res);
}

void CryptoServerHandshake::CloneFrom(const CryptoServerHandshake *from) {
	/*  0: serverChallenge  */
	serverChallenge = from->serverChallenge;
	/*  1: func  */
	func = from->func;
	/*  2: context  */
	std::map<std::string, PyRep *>::const_iterator context_cur, context_end;
	//free any existing elements first
	context_cur = context.begin();
	context_end = context.end();
	for(; context_cur != context_end; context_cur++) {
		delete context_cur->second;
	}
	context.clear();
	//now we can copy in the new ones...
	context_cur = from->context.begin();
	context_end = from->context.end();
	for(; context_cur != context_end; context_cur++) {
		context[context_cur->first] = context_cur->second->Clone();
	}
	
	/*  3: response  */
	challenge_responsehash = from->challenge_responsehash;
	macho_version = from->macho_version;
	boot_version = from->boot_version;
	boot_build = from->boot_build;
	boot_codename = from->boot_codename;
	boot_region = from->boot_region;
	cluster_usercount = from->cluster_usercount;
	proxy_nodeid = from->proxy_nodeid;
	user_logonqueueposition = from->user_logonqueueposition;
	
}


CryptoHandshakeResult::CryptoHandshakeResult() {
	/*  0  */
	challenge_responsehash = "";
	/*  1  */
	func_output = "";
	/*  2  */
	func_result = 0;
}

CryptoHandshakeResult::~CryptoHandshakeResult() {
	/*  0  */
	/*  1  */
	/*  2  */
}

void CryptoHandshakeResult::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCryptoHandshakeResult", pfx);
	/*  0  */
	_log(l_type, "%schallenge_responsehash='%s'", pfx, challenge_responsehash.c_str());
	/*  1  */
	_log(l_type, "%sfunc_output='%s'", pfx, func_output.c_str());
	/*  2  */
	_log(l_type, "%sfunc_result=%lu", pfx, func_result);
}

PyRepSubStream *CryptoHandshakeResult::Encode() {
	PyRepSubStream *res = NULL;
	PyRep *ss_0;
	PyRepTuple *tuple1 = new PyRepTuple(3);
	/*  0  */
	tuple1->items[0] = new PyRepString(challenge_responsehash);
	/*  1  */
	tuple1->items[1] = new PyRepString(func_output);
	/*  2  */
	tuple1->items[2] = new PyRepInteger(func_result);
	ss_0 = tuple1;
	
	res = new PyRepSubStream(ss_0);

	return(res);
}

PyRepSubStream *CryptoHandshakeResult::FastEncode() {
	PyRepSubStream *res = NULL;
	PyRep *ss_0;
	PyRepTuple *tuple1 = new PyRepTuple(3);
	/*  0  */
	tuple1->items[0] = new PyRepString(challenge_responsehash);
	/*  1  */
	tuple1->items[1] = new PyRepString(func_output);
	/*  2  */
	tuple1->items[2] = new PyRepInteger(func_result);
	ss_0 = tuple1;
	
	res = new PyRepSubStream(ss_0);

	return(res);
}

bool CryptoHandshakeResult::Decode(PyRepSubStream **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CryptoHandshakeResult::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode CryptoHandshakeResult failed: ss_0 is not a substream: %s", packet->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_0 = (PyRepSubStream *) packet;
	//make sure its decoded
	ss_0->DecodeData();
	if(ss_0->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode CryptoHandshakeResult failed: Unable to decode ss_0");
		delete packet;
		return(false);
	}
	
	if(!ss_0->decoded->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CryptoHandshakeResult failed: tuple1 is the wrong type: %s", ss_0->decoded->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple1 = (PyRepTuple *) ss_0->decoded;
	if(tuple1->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode CryptoHandshakeResult failed: tuple1 is the wrong size: expected 3, but got %d", tuple1->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple1->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode CryptoHandshakeResult failed: challenge_responsehash is not a string: %s", tuple1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple1->items[0];
	challenge_responsehash = string_2->value;
	/*  1  */
	if(!tuple1->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode CryptoHandshakeResult failed: func_output is not a string: %s", tuple1->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) tuple1->items[1];
	func_output = string_3->value;
	/*  2  */
	if(!tuple1->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CryptoHandshakeResult failed: func_result is not an int: %s", tuple1->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple1->items[2];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CryptoHandshakeResult: truncating 64 bit into into 32 bit int for field func_result");
	}
	func_result = int_4->value;

	delete packet;
	return(true);
}

CryptoHandshakeResult *CryptoHandshakeResult::Clone() const {
	CryptoHandshakeResult *res = new CryptoHandshakeResult;
	res->CloneFrom(this);
	return(res);
}

void CryptoHandshakeResult::CloneFrom(const CryptoHandshakeResult *from) {
	/*  0  */
	challenge_responsehash = from->challenge_responsehash;
	/*  1  */
	func_output = from->func_output;
	/*  2  */
	func_result = from->func_result;
	
}



