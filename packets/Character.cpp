/*  EVEmu: EVE Online Server Emulator
  
  **************************************************************
  This file is automatically generated, DO NOT EDIT IT DIRECTLY.
  **************************************************************
  
  (If you need to customize an object, you must copy that object
  into another source file, and give up the ability to generate it)
  
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; version 2 of the License.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY except by those people which sell it, which
  are required to give you total support for your newly bought product;
  without even the implied warranty of MERCHANTABILITY or FITNESS FOR
  A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/


#include <string>
#include "../packets/Character.h"
#include "../common/PyRep.h"




RspGetCharactersToSelect::RspGetCharactersToSelect() {
	/*  0  */
}

RspGetCharactersToSelect::~RspGetCharactersToSelect() {
	/*  0  */
}

void RspGetCharactersToSelect::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspGetCharactersToSelect", pfx);
	/*  0  */
	_log(l_type, "%schars:", pfx);
	std::string chars_n(pfx);
	chars_n += "    ";
	chars.Dump(l_type, chars_n.c_str());
}

PyRepTuple *RspGetCharactersToSelect::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
		ss_1 = chars.Encode();
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

PyRepTuple *RspGetCharactersToSelect::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
		ss_1 = chars.FastEncode();
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspGetCharactersToSelect::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspGetCharactersToSelect::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharactersToSelect failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharactersToSelect failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharactersToSelect failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharactersToSelect failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	PyRep *rep_2 = ss_1->decoded;
	ss_1->decoded = NULL;
	if(!chars.Decode(&rep_2)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharactersToSelect failed: unable to decode element chars");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

RspGetCharactersToSelect *RspGetCharactersToSelect::Clone() const {
	RspGetCharactersToSelect *res = new RspGetCharactersToSelect;
	res->CloneFrom(this);
	return(res);
}

void RspGetCharactersToSelect::CloneFrom(const RspGetCharactersToSelect *from) {
	/*  0  */
	chars.CloneFrom(&from->chars);
	
}


CallGetCharacterToSelect::CallGetCharacterToSelect() {
	/*  0  */
	charID = 0;
}

CallGetCharacterToSelect::~CallGetCharacterToSelect() {
	/*  0  */
}

void CallGetCharacterToSelect::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallGetCharacterToSelect", pfx);
	/*  0  */
	_log(l_type, "%scharID=%lu", pfx, charID);
}

PyRepTuple *CallGetCharacterToSelect::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	tuple0->items[0] = new PyRepInteger(charID);
	res = tuple0;
	

	return(res);
}

PyRepTuple *CallGetCharacterToSelect::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	tuple0->items[0] = new PyRepInteger(charID);
	res = tuple0;
	

	return(res);
}

bool CallGetCharacterToSelect::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallGetCharacterToSelect::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallGetCharacterToSelect failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode CallGetCharacterToSelect failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallGetCharacterToSelect failed: charID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallGetCharacterToSelect: truncating 64 bit into into 32 bit int for field charID");
	}
	charID = int_1->value;

	delete packet;
	return(true);
}

CallGetCharacterToSelect *CallGetCharacterToSelect::Clone() const {
	CallGetCharacterToSelect *res = new CallGetCharacterToSelect;
	res->CloneFrom(this);
	return(res);
}

void CallGetCharacterToSelect::CloneFrom(const CallGetCharacterToSelect *from) {
	/*  0  */
	charID = from->charID;
	
}


RspGetCharacterToSelect::RspGetCharacterToSelect() {
	/*  0  */
}

RspGetCharacterToSelect::~RspGetCharacterToSelect() {
	/*  0  */
}

void RspGetCharacterToSelect::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspGetCharacterToSelect", pfx);
	/*  0  */
	_log(l_type, "%scharacter:", pfx);
	std::string character_n(pfx);
	character_n += "    ";
	character.Dump(l_type, character_n.c_str());
}

PyRepTuple *RspGetCharacterToSelect::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
		ss_1 = character.Encode();
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

PyRepTuple *RspGetCharacterToSelect::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
		ss_1 = character.FastEncode();
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspGetCharacterToSelect::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspGetCharacterToSelect::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharacterToSelect failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharacterToSelect failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharacterToSelect failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharacterToSelect failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	PyRep *rep_2 = ss_1->decoded;
	ss_1->decoded = NULL;
	if(!character.Decode(&rep_2)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharacterToSelect failed: unable to decode element character");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

RspGetCharacterToSelect *RspGetCharacterToSelect::Clone() const {
	RspGetCharacterToSelect *res = new RspGetCharacterToSelect;
	res->CloneFrom(this);
	return(res);
}

void RspGetCharacterToSelect::CloneFrom(const RspGetCharacterToSelect *from) {
	/*  0  */
	character.CloneFrom(&from->character);
	
}


RspGetCharCreationInfo::RspGetCharCreationInfo() {
	/*  0  */
}

RspGetCharCreationInfo::~RspGetCharCreationInfo() {
	/*  0  */
	std::map<std::string, PyRep *>::iterator caches_cur, caches_end;
	//free any existing elements first
	caches_cur = caches.begin();
	caches_end = caches.end();
	for(; caches_cur != caches_end; caches_cur++) {
		delete caches_cur->second;
	}
	
}

void RspGetCharCreationInfo::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspGetCharCreationInfo", pfx);
	/*  0  */
	_log(l_type, "%scaches: Dictionaty with %d enetires", pfx, caches.size());
	std::map<std::string, PyRep *>::const_iterator caches_cur, caches_end;
	caches_cur = caches.begin();
	caches_end = caches.end();
	for(; caches_cur != caches_end; caches_cur++) {
		_log(l_type, "%s Key: %s", pfx, caches_cur->first.c_str());
		std::string n(pfx);
		n += "      ";
		caches_cur->second->Dump(stdout, n.c_str());
	}
	
}

PyRepTuple *RspGetCharCreationInfo::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	
	PyRepDict *dict2 = new PyRepDict();
	std::map<std::string, PyRep *>::iterator caches_cur, caches_end;
	caches_cur = caches.begin();
	caches_end = caches.end();
	for(; caches_cur != caches_end; caches_cur++) {
		dict2->items[
			new PyRepString(caches_cur->first)
		] = caches_cur->second->Clone();
	}
	ss_1 = dict2;
	
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

PyRepTuple *RspGetCharCreationInfo::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	
	PyRepDict *dict2 = new PyRepDict();
	std::map<std::string, PyRep *>::iterator caches_cur, caches_end;
	caches_cur = caches.begin();
	caches_end = caches.end();
	for(; caches_cur != caches_end; caches_cur++) {
		dict2->items[
			new PyRepString(caches_cur->first)
		] = caches_cur->second;
	}
	caches.clear();
	ss_1 = dict2;
	
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspGetCharCreationInfo::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspGetCharCreationInfo::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharCreationInfo failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharCreationInfo failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharCreationInfo failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharCreationInfo failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	if(!ss_1->decoded->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCharCreationInfo failed: caches is not a dict: %s", ss_1->decoded->TypeString());
		delete packet;
		return(false);
	}
	caches.clear();
	PyRepDict *dict_2 = (PyRepDict *) ss_1->decoded;
	PyRepDict::iterator caches_cur, caches_end;
	caches_cur = dict_2->items.begin();
	caches_end = dict_2->items.end();
	int caches_index;
	for(caches_index = 0; caches_cur != caches_end; caches_cur++, caches_index++) {
		if(!caches_cur->first->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode RspGetCharCreationInfo failed: Key %d in dict caches is not a string: %s", caches_index, caches_cur->first->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *k = (PyRepString *) caches_cur->first;
		caches[k->value] = caches_cur->second->Clone();
	}
	

	delete packet;
	return(true);
}

RspGetCharCreationInfo *RspGetCharCreationInfo::Clone() const {
	RspGetCharCreationInfo *res = new RspGetCharCreationInfo;
	res->CloneFrom(this);
	return(res);
}

void RspGetCharCreationInfo::CloneFrom(const RspGetCharCreationInfo *from) {
	/*  0  */
	std::map<std::string, PyRep *>::const_iterator caches_cur, caches_end;
	//free any existing elements first
	caches_cur = caches.begin();
	caches_end = caches.end();
	for(; caches_cur != caches_end; caches_cur++) {
		delete caches_cur->second;
	}
	caches.clear();
	//now we can copy in the new ones...
	caches_cur = from->caches.begin();
	caches_end = from->caches.end();
	for(; caches_cur != caches_end; caches_cur++) {
		caches[caches_cur->first] = caches_cur->second->Clone();
	}
	
	
}


CallSelectCharacterID::CallSelectCharacterID() {
	/*  0  */
	charID = 0;
}

CallSelectCharacterID::~CallSelectCharacterID() {
	/*  0  */
}

void CallSelectCharacterID::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallSelectCharacterID", pfx);
	/*  0  */
	_log(l_type, "%scharID=%lu", pfx, charID);
}

PyRepTuple *CallSelectCharacterID::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	tuple0->items[0] = new PyRepInteger(charID);
	res = tuple0;
	

	return(res);
}

PyRepTuple *CallSelectCharacterID::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	tuple0->items[0] = new PyRepInteger(charID);
	res = tuple0;
	

	return(res);
}

bool CallSelectCharacterID::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallSelectCharacterID::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallSelectCharacterID failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode CallSelectCharacterID failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallSelectCharacterID failed: charID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallSelectCharacterID: truncating 64 bit into into 32 bit int for field charID");
	}
	charID = int_1->value;

	delete packet;
	return(true);
}

CallSelectCharacterID *CallSelectCharacterID::Clone() const {
	CallSelectCharacterID *res = new CallSelectCharacterID;
	res->CloneFrom(this);
	return(res);
}

void CallSelectCharacterID::CloneFrom(const CallSelectCharacterID *from) {
	/*  0  */
	charID = from->charID;
	
}


CallValidateName::CallValidateName() {
	/*  0  */
	name = "";
}

CallValidateName::~CallValidateName() {
	/*  0  */
}

void CallValidateName::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallValidateName", pfx);
	/*  0  */
	_log(l_type, "%sname='%s'", pfx, name.c_str());
}

PyRepTuple *CallValidateName::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	tuple0->items[0] = new PyRepString(name);
	res = tuple0;
	

	return(res);
}

PyRepTuple *CallValidateName::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	tuple0->items[0] = new PyRepString(name);
	res = tuple0;
	

	return(res);
}

bool CallValidateName::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallValidateName::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallValidateName failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode CallValidateName failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode CallValidateName failed: name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	name = string_1->value;

	delete packet;
	return(true);
}

CallValidateName *CallValidateName::Clone() const {
	CallValidateName *res = new CallValidateName;
	res->CloneFrom(this);
	return(res);
}

void CallValidateName::CloneFrom(const CallValidateName *from) {
	/*  0  */
	name = from->name;
	
}


RspValidateName::RspValidateName() {
	/*  0  */
	result = false;
}

RspValidateName::~RspValidateName() {
	/*  0  */
}

void RspValidateName::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspValidateName", pfx);
	/*  0  */
	_log(l_type, "%sresult=%s", pfx, result?"true":"false");
}

PyRepTuple *RspValidateName::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	ss_1 = new PyRepBoolean(result);
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

PyRepTuple *RspValidateName::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	ss_1 = new PyRepBoolean(result);
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspValidateName::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspValidateName::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspValidateName failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspValidateName failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspValidateName failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspValidateName failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	if(!ss_1->decoded->CheckType(PyRep::Boolean)) {
		_log(NET__PACKET_ERROR, "Decode RspValidateName failed: result is not a boolean: %s", ss_1->decoded->TypeString());
		delete packet;
		return(false);
	}
	PyRepBoolean *bool_2 = (PyRepBoolean *) ss_1->decoded;
	result = bool_2->value;

	delete packet;
	return(true);
}

RspValidateName *RspValidateName::Clone() const {
	RspValidateName *res = new RspValidateName;
	res->CloneFrom(this);
	return(res);
}

void RspValidateName::CloneFrom(const RspValidateName *from) {
	/*  0  */
	result = from->result;
	
}


CallCreateCharacter::CallCreateCharacter() {
	/*  0  */
	name = "";
	/*  1  */
	bloodlineID = 0;
	/*  2  */
	genderID = 0;
	/*  3  */
	ancestryID = 0;
	/*  4  */
	schoolID = 0;
	/*  5  */
	departmentID = 0;
	/*  6  */
	fieldID = 0;
	/*  7  */
	specialityID = 0;
	/*  8  */
	IntelligenceAdd = 0;
	/*  9  */
	CharismaAdd = 0;
	/*  10  */
	PerceptionAdd = 0;
	/*  11  */
	MemoryAdd = 0;
	/*  12  */
	WillpowerAdd = 0;
	/*  13  */
}

CallCreateCharacter::~CallCreateCharacter() {
	/*  0  */
	/*  1  */
	/*  2  */
	/*  3  */
	/*  4  */
	/*  5  */
	/*  6  */
	/*  7  */
	/*  8  */
	/*  9  */
	/*  10  */
	/*  11  */
	/*  12  */
	/*  13  */
	std::map<std::string, PyRep *>::iterator appearance_cur, appearance_end;
	//free any existing elements first
	appearance_cur = appearance.begin();
	appearance_end = appearance.end();
	for(; appearance_cur != appearance_end; appearance_cur++) {
		delete appearance_cur->second;
	}
	
}

void CallCreateCharacter::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallCreateCharacter", pfx);
	/*  0  */
	_log(l_type, "%sname='%s'", pfx, name.c_str());
	/*  1  */
	_log(l_type, "%sbloodlineID=%lu", pfx, bloodlineID);
	/*  2  */
	_log(l_type, "%sgenderID=%lu", pfx, genderID);
	/*  3  */
	_log(l_type, "%sancestryID=%lu", pfx, ancestryID);
	/*  4  */
	_log(l_type, "%sschoolID=%lu", pfx, schoolID);
	/*  5  */
	_log(l_type, "%sdepartmentID=%lu", pfx, departmentID);
	/*  6  */
	_log(l_type, "%sfieldID=%lu", pfx, fieldID);
	/*  7  */
	_log(l_type, "%sspecialityID=%lu", pfx, specialityID);
	/*  8  */
	_log(l_type, "%sIntelligenceAdd=%lu", pfx, IntelligenceAdd);
	/*  9  */
	_log(l_type, "%sCharismaAdd=%lu", pfx, CharismaAdd);
	/*  10  */
	_log(l_type, "%sPerceptionAdd=%lu", pfx, PerceptionAdd);
	/*  11  */
	_log(l_type, "%sMemoryAdd=%lu", pfx, MemoryAdd);
	/*  12  */
	_log(l_type, "%sWillpowerAdd=%lu", pfx, WillpowerAdd);
	/*  13  */
	_log(l_type, "%sappearance: Dictionaty with %d enetires", pfx, appearance.size());
	std::map<std::string, PyRep *>::const_iterator appearance_cur, appearance_end;
	appearance_cur = appearance.begin();
	appearance_end = appearance.end();
	for(; appearance_cur != appearance_end; appearance_cur++) {
		_log(l_type, "%s Key: %s", pfx, appearance_cur->first.c_str());
		std::string n(pfx);
		n += "      ";
		appearance_cur->second->Dump(stdout, n.c_str());
	}
	
}

PyRepTuple *CallCreateCharacter::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(14);
	/*  0  */
	tuple0->items[0] = new PyRepString(name);
	/*  1  */
	tuple0->items[1] = new PyRepInteger(bloodlineID);
	/*  2  */
	tuple0->items[2] = new PyRepInteger(genderID);
	/*  3  */
	tuple0->items[3] = new PyRepInteger(ancestryID);
	/*  4  */
	tuple0->items[4] = new PyRepInteger(schoolID);
	/*  5  */
	tuple0->items[5] = new PyRepInteger(departmentID);
	/*  6  */
	tuple0->items[6] = new PyRepInteger(fieldID);
	/*  7  */
	tuple0->items[7] = new PyRepInteger(specialityID);
	/*  8  */
	tuple0->items[8] = new PyRepInteger(IntelligenceAdd);
	/*  9  */
	tuple0->items[9] = new PyRepInteger(CharismaAdd);
	/*  10  */
	tuple0->items[10] = new PyRepInteger(PerceptionAdd);
	/*  11  */
	tuple0->items[11] = new PyRepInteger(MemoryAdd);
	/*  12  */
	tuple0->items[12] = new PyRepInteger(WillpowerAdd);
	/*  13  */
	
	PyRepDict *dict1 = new PyRepDict();
	std::map<std::string, PyRep *>::iterator appearance_cur, appearance_end;
	appearance_cur = appearance.begin();
	appearance_end = appearance.end();
	for(; appearance_cur != appearance_end; appearance_cur++) {
		dict1->items[
			new PyRepString(appearance_cur->first)
		] = appearance_cur->second->Clone();
	}
	tuple0->items[13] = dict1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *CallCreateCharacter::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(14);
	/*  0  */
	tuple0->items[0] = new PyRepString(name);
	/*  1  */
	tuple0->items[1] = new PyRepInteger(bloodlineID);
	/*  2  */
	tuple0->items[2] = new PyRepInteger(genderID);
	/*  3  */
	tuple0->items[3] = new PyRepInteger(ancestryID);
	/*  4  */
	tuple0->items[4] = new PyRepInteger(schoolID);
	/*  5  */
	tuple0->items[5] = new PyRepInteger(departmentID);
	/*  6  */
	tuple0->items[6] = new PyRepInteger(fieldID);
	/*  7  */
	tuple0->items[7] = new PyRepInteger(specialityID);
	/*  8  */
	tuple0->items[8] = new PyRepInteger(IntelligenceAdd);
	/*  9  */
	tuple0->items[9] = new PyRepInteger(CharismaAdd);
	/*  10  */
	tuple0->items[10] = new PyRepInteger(PerceptionAdd);
	/*  11  */
	tuple0->items[11] = new PyRepInteger(MemoryAdd);
	/*  12  */
	tuple0->items[12] = new PyRepInteger(WillpowerAdd);
	/*  13  */
	
	PyRepDict *dict1 = new PyRepDict();
	std::map<std::string, PyRep *>::iterator appearance_cur, appearance_end;
	appearance_cur = appearance.begin();
	appearance_end = appearance.end();
	for(; appearance_cur != appearance_end; appearance_cur++) {
		dict1->items[
			new PyRepString(appearance_cur->first)
		] = appearance_cur->second;
	}
	appearance.clear();
	tuple0->items[13] = dict1;
	
	res = tuple0;
	

	return(res);
}

bool CallCreateCharacter::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallCreateCharacter::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallCreateCharacter failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 14) {
		_log(NET__PACKET_ERROR, "Decode CallCreateCharacter failed: tuple0 is the wrong size: expected 14, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode CallCreateCharacter failed: name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallCreateCharacter failed: bloodlineID is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallCreateCharacter: truncating 64 bit into into 32 bit int for field bloodlineID");
	}
	bloodlineID = int_2->value;
	/*  2  */
	if(!tuple0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallCreateCharacter failed: genderID is not an int: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple0->items[2];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallCreateCharacter: truncating 64 bit into into 32 bit int for field genderID");
	}
	genderID = int_3->value;
	/*  3  */
	if(!tuple0->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallCreateCharacter failed: ancestryID is not an int: %s", tuple0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple0->items[3];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallCreateCharacter: truncating 64 bit into into 32 bit int for field ancestryID");
	}
	ancestryID = int_4->value;
	/*  4  */
	if(!tuple0->items[4]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallCreateCharacter failed: schoolID is not an int: %s", tuple0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) tuple0->items[4];
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallCreateCharacter: truncating 64 bit into into 32 bit int for field schoolID");
	}
	schoolID = int_5->value;
	/*  5  */
	if(!tuple0->items[5]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallCreateCharacter failed: departmentID is not an int: %s", tuple0->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_6 = (PyRepInteger *) tuple0->items[5];
	if(int_6->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallCreateCharacter: truncating 64 bit into into 32 bit int for field departmentID");
	}
	departmentID = int_6->value;
	/*  6  */
	if(!tuple0->items[6]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallCreateCharacter failed: fieldID is not an int: %s", tuple0->items[6]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_7 = (PyRepInteger *) tuple0->items[6];
	if(int_7->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallCreateCharacter: truncating 64 bit into into 32 bit int for field fieldID");
	}
	fieldID = int_7->value;
	/*  7  */
	if(!tuple0->items[7]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallCreateCharacter failed: specialityID is not an int: %s", tuple0->items[7]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_8 = (PyRepInteger *) tuple0->items[7];
	if(int_8->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallCreateCharacter: truncating 64 bit into into 32 bit int for field specialityID");
	}
	specialityID = int_8->value;
	/*  8  */
	if(!tuple0->items[8]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallCreateCharacter failed: IntelligenceAdd is not an int: %s", tuple0->items[8]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_9 = (PyRepInteger *) tuple0->items[8];
	if(int_9->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallCreateCharacter: truncating 64 bit into into 32 bit int for field IntelligenceAdd");
	}
	IntelligenceAdd = int_9->value;
	/*  9  */
	if(!tuple0->items[9]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallCreateCharacter failed: CharismaAdd is not an int: %s", tuple0->items[9]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_10 = (PyRepInteger *) tuple0->items[9];
	if(int_10->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallCreateCharacter: truncating 64 bit into into 32 bit int for field CharismaAdd");
	}
	CharismaAdd = int_10->value;
	/*  10  */
	if(!tuple0->items[10]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallCreateCharacter failed: PerceptionAdd is not an int: %s", tuple0->items[10]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_11 = (PyRepInteger *) tuple0->items[10];
	if(int_11->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallCreateCharacter: truncating 64 bit into into 32 bit int for field PerceptionAdd");
	}
	PerceptionAdd = int_11->value;
	/*  11  */
	if(!tuple0->items[11]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallCreateCharacter failed: MemoryAdd is not an int: %s", tuple0->items[11]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_12 = (PyRepInteger *) tuple0->items[11];
	if(int_12->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallCreateCharacter: truncating 64 bit into into 32 bit int for field MemoryAdd");
	}
	MemoryAdd = int_12->value;
	/*  12  */
	if(!tuple0->items[12]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallCreateCharacter failed: WillpowerAdd is not an int: %s", tuple0->items[12]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_13 = (PyRepInteger *) tuple0->items[12];
	if(int_13->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallCreateCharacter: truncating 64 bit into into 32 bit int for field WillpowerAdd");
	}
	WillpowerAdd = int_13->value;
	/*  13  */
	if(!tuple0->items[13]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode CallCreateCharacter failed: appearance is not a dict: %s", tuple0->items[13]->TypeString());
		delete packet;
		return(false);
	}
	appearance.clear();
	PyRepDict *dict_14 = (PyRepDict *) tuple0->items[13];
	PyRepDict::iterator appearance_cur, appearance_end;
	appearance_cur = dict_14->items.begin();
	appearance_end = dict_14->items.end();
	int appearance_index;
	for(appearance_index = 0; appearance_cur != appearance_end; appearance_cur++, appearance_index++) {
		if(!appearance_cur->first->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode CallCreateCharacter failed: Key %d in dict appearance is not a string: %s", appearance_index, appearance_cur->first->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *k = (PyRepString *) appearance_cur->first;
		appearance[k->value] = appearance_cur->second->Clone();
	}
	

	delete packet;
	return(true);
}

CallCreateCharacter *CallCreateCharacter::Clone() const {
	CallCreateCharacter *res = new CallCreateCharacter;
	res->CloneFrom(this);
	return(res);
}

void CallCreateCharacter::CloneFrom(const CallCreateCharacter *from) {
	/*  0  */
	name = from->name;
	/*  1  */
	bloodlineID = from->bloodlineID;
	/*  2  */
	genderID = from->genderID;
	/*  3  */
	ancestryID = from->ancestryID;
	/*  4  */
	schoolID = from->schoolID;
	/*  5  */
	departmentID = from->departmentID;
	/*  6  */
	fieldID = from->fieldID;
	/*  7  */
	specialityID = from->specialityID;
	/*  8  */
	IntelligenceAdd = from->IntelligenceAdd;
	/*  9  */
	CharismaAdd = from->CharismaAdd;
	/*  10  */
	PerceptionAdd = from->PerceptionAdd;
	/*  11  */
	MemoryAdd = from->MemoryAdd;
	/*  12  */
	WillpowerAdd = from->WillpowerAdd;
	/*  13  */
	std::map<std::string, PyRep *>::const_iterator appearance_cur, appearance_end;
	//free any existing elements first
	appearance_cur = appearance.begin();
	appearance_end = appearance.end();
	for(; appearance_cur != appearance_end; appearance_cur++) {
		delete appearance_cur->second;
	}
	appearance.clear();
	//now we can copy in the new ones...
	appearance_cur = from->appearance.begin();
	appearance_end = from->appearance.end();
	for(; appearance_cur != appearance_end; appearance_cur++) {
		appearance[appearance_cur->first] = appearance_cur->second->Clone();
	}
	
	
}


RspCreateCharacter::RspCreateCharacter() {
	/*  0  */
	charID = 0;
}

RspCreateCharacter::~RspCreateCharacter() {
	/*  0  */
}

void RspCreateCharacter::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspCreateCharacter", pfx);
	/*  0  */
	_log(l_type, "%scharID=%lu", pfx, charID);
}

PyRepTuple *RspCreateCharacter::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	ss_1 = new PyRepInteger(charID);
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

PyRepTuple *RspCreateCharacter::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	ss_1 = new PyRepInteger(charID);
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspCreateCharacter::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspCreateCharacter::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspCreateCharacter failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspCreateCharacter failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspCreateCharacter failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspCreateCharacter failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	if(!ss_1->decoded->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode RspCreateCharacter failed: charID is not an int: %s", ss_1->decoded->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) ss_1->decoded;
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode RspCreateCharacter: truncating 64 bit into into 32 bit int for field charID");
	}
	charID = int_2->value;

	delete packet;
	return(true);
}

RspCreateCharacter *RspCreateCharacter::Clone() const {
	RspCreateCharacter *res = new RspCreateCharacter;
	res->CloneFrom(this);
	return(res);
}

void RspCreateCharacter::CloneFrom(const RspCreateCharacter *from) {
	/*  0  */
	charID = from->charID;
	
}


NotifyOnCharNowInStation::NotifyOnCharNowInStation() {
	/*  0  */
	charID = 0;
}

NotifyOnCharNowInStation::~NotifyOnCharNowInStation() {
	/*  0  */
}

void NotifyOnCharNowInStation::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotifyOnCharNowInStation", pfx);
	/*  0  */
	_log(l_type, "%scharID=%lu", pfx, charID);
}

PyRepTuple *NotifyOnCharNowInStation::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	tuple0->items[0] = new PyRepInteger(charID);
	res = tuple0;
	

	return(res);
}

PyRepTuple *NotifyOnCharNowInStation::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	tuple0->items[0] = new PyRepInteger(charID);
	res = tuple0;
	

	return(res);
}

bool NotifyOnCharNowInStation::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool NotifyOnCharNowInStation::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnCharNowInStation failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnCharNowInStation failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnCharNowInStation failed: charID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode NotifyOnCharNowInStation: truncating 64 bit into into 32 bit int for field charID");
	}
	charID = int_1->value;

	delete packet;
	return(true);
}

NotifyOnCharNowInStation *NotifyOnCharNowInStation::Clone() const {
	NotifyOnCharNowInStation *res = new NotifyOnCharNowInStation;
	res->CloneFrom(this);
	return(res);
}

void NotifyOnCharNowInStation::CloneFrom(const NotifyOnCharNowInStation *from) {
	/*  0  */
	charID = from->charID;
	
}


Call_SetNote::Call_SetNote() {
	itemID = 0;
	note = "";
}

Call_SetNote::~Call_SetNote() {
}

void Call_SetNote::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_SetNote", pfx);
	_log(l_type, "%sitemID=%lu", pfx, itemID);
	_log(l_type, "%snote='%s'", pfx, note.c_str());
}

PyRepTuple *Call_SetNote::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(itemID);
	tuple0->items[1] = new PyRepString(note);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_SetNote::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(itemID);
	tuple0->items[1] = new PyRepString(note);
	res = tuple0;
	

	return(res);
}

bool Call_SetNote::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_SetNote::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_SetNote failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Call_SetNote failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_SetNote failed: itemID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_SetNote: truncating 64 bit into into 32 bit int for field itemID");
	}
	itemID = int_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Call_SetNote failed: note is not a string: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple0->items[1];
	note = string_2->value;

	delete packet;
	return(true);
}

Call_SetNote *Call_SetNote::Clone() const {
	Call_SetNote *res = new Call_SetNote;
	res->CloneFrom(this);
	return(res);
}

void Call_SetNote::CloneFrom(const Call_SetNote *from) {
	itemID = from->itemID;
	note = from->note;
	
}


Call_AddOwnerNote::Call_AddOwnerNote() {
	label = "";
	content = "";
}

Call_AddOwnerNote::~Call_AddOwnerNote() {
}

void Call_AddOwnerNote::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_AddOwnerNote", pfx);
	_log(l_type, "%slabel='%s'", pfx, label.c_str());
	_log(l_type, "%scontent='%s'", pfx, content.c_str());
}

PyRepTuple *Call_AddOwnerNote::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepString(label);
	tuple0->items[1] = new PyRepString(content);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_AddOwnerNote::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepString(label);
	tuple0->items[1] = new PyRepString(content);
	res = tuple0;
	

	return(res);
}

bool Call_AddOwnerNote::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_AddOwnerNote::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_AddOwnerNote failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Call_AddOwnerNote failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Call_AddOwnerNote failed: label is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	label = string_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Call_AddOwnerNote failed: content is not a string: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple0->items[1];
	content = string_2->value;

	delete packet;
	return(true);
}

Call_AddOwnerNote *Call_AddOwnerNote::Clone() const {
	Call_AddOwnerNote *res = new Call_AddOwnerNote;
	res->CloneFrom(this);
	return(res);
}

void Call_AddOwnerNote::CloneFrom(const Call_AddOwnerNote *from) {
	label = from->label;
	content = from->content;
	
}


Call_EditOwnerNote::Call_EditOwnerNote() {
	noteID = 0;
	label = "";
	content = "";
}

Call_EditOwnerNote::~Call_EditOwnerNote() {
}

void Call_EditOwnerNote::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_EditOwnerNote", pfx);
	_log(l_type, "%snoteID=%lu", pfx, noteID);
	_log(l_type, "%slabel='%s'", pfx, label.c_str());
	_log(l_type, "%scontent='%s'", pfx, content.c_str());
}

PyRepTuple *Call_EditOwnerNote::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	tuple0->items[0] = new PyRepInteger(noteID);
	tuple0->items[1] = new PyRepString(label);
	tuple0->items[2] = new PyRepString(content);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_EditOwnerNote::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	tuple0->items[0] = new PyRepInteger(noteID);
	tuple0->items[1] = new PyRepString(label);
	tuple0->items[2] = new PyRepString(content);
	res = tuple0;
	

	return(res);
}

bool Call_EditOwnerNote::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_EditOwnerNote::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_EditOwnerNote failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode Call_EditOwnerNote failed: tuple0 is the wrong size: expected 3, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_EditOwnerNote failed: noteID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_EditOwnerNote: truncating 64 bit into into 32 bit int for field noteID");
	}
	noteID = int_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Call_EditOwnerNote failed: label is not a string: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple0->items[1];
	label = string_2->value;
	if(!tuple0->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Call_EditOwnerNote failed: content is not a string: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) tuple0->items[2];
	content = string_3->value;

	delete packet;
	return(true);
}

Call_EditOwnerNote *Call_EditOwnerNote::Clone() const {
	Call_EditOwnerNote *res = new Call_EditOwnerNote;
	res->CloneFrom(this);
	return(res);
}

void Call_EditOwnerNote::CloneFrom(const Call_EditOwnerNote *from) {
	noteID = from->noteID;
	label = from->label;
	content = from->content;
	
}



