/*  EVEmu: EVE Online Server Emulator
  
  **************************************************************
  This file is automatically generated, DO NOT EDIT IT DIRECTLY.
  **************************************************************
  
  (If you need to customize an object, you must copy that object
  into another source file, and give up the ability to generate it)
  
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; version 2 of the License.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY except by those people which sell it, which
  are required to give you total support for your newly bought product;
  without even the implied warranty of MERCHANTABILITY or FITNESS FOR
  A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/


#include <string>
#include "..\packets\Inventory.h"
#include "../common/PyRep.h"




NotifyOnItemChange::NotifyOnItemChange() {
	/*  0: this is a util.Row  */
	itemRow = NULL;
	/*  1: map from row index (ix* constants) to the old value for the item.   */
}

NotifyOnItemChange::~NotifyOnItemChange() {
	/*  0: this is a util.Row  */
	delete itemRow;
	/*  1: map from row index (ix* constants) to the old value for the item.   */
	std::map<uint32, PyRep *>::iterator changes_cur, changes_end;
	//free any existing elements first
	changes_cur = changes.begin();
	changes_end = changes.end();
	for(; changes_cur != changes_end; changes_cur++) {
		delete changes_cur->second;
	}
	
}

void NotifyOnItemChange::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotifyOnItemChange", pfx);
	/*  0: this is a util.Row  */
	_log(l_type, "%sitemRow:", pfx);
	std::string itemRow_n(pfx);
	itemRow_n += "    ";
	if(itemRow == NULL) {
		_log(l_type, "%sERROR: NULL REP!", itemRow_n.c_str());
	} else {
		itemRow->Dump(l_type, itemRow_n.c_str());
	}
	/*  1: map from row index (ix* constants) to the old value for the item.   */
	_log(l_type, "%schanges: Dictionaty with %d enetires", pfx, changes.size());
	std::map<uint32, PyRep *>::const_iterator changes_cur, changes_end;
	changes_cur = changes.begin();
	changes_end = changes.end();
	for(; changes_cur != changes_end; changes_cur++) {
		_log(l_type, "%s   Key: %lu", pfx, changes_cur->first);
		std::string n(pfx);
		n += "        ";
		changes_cur->second->Dump(stdout, n.c_str());
	}
	
}

PyRepTuple *NotifyOnItemChange::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0: this is a util.Row  */
	if(itemRow == NULL) {
		_log(NET__PACKET_ERROR, "Encode NotifyOnItemChange: itemRow is NULL! hacking in a PyRepNone");
		itemRow = new PyRepNone();
	}
	tuple0->items[0] = itemRow->Clone();
	/*  1: map from row index (ix* constants) to the old value for the item.   */
	
	PyRepDict *dict1 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator changes_cur, changes_end;
	changes_cur = changes.begin();
	changes_end = changes.end();
	for(; changes_cur != changes_end; changes_cur++) {
		dict1->items[
			new PyRepInteger(changes_cur->first)
		] = changes_cur->second->Clone();
	}
	tuple0->items[1] = dict1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *NotifyOnItemChange::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0: this is a util.Row  */
	if(itemRow == NULL) {
		_log(NET__PACKET_ERROR, "Encode NotifyOnItemChange: itemRow is NULL! hacking in a PyRepNone");
		itemRow = new PyRepNone();
	}
	tuple0->items[0] = itemRow;
	itemRow = NULL;
	/*  1: map from row index (ix* constants) to the old value for the item.   */
	
	PyRepDict *dict1 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator changes_cur, changes_end;
	changes_cur = changes.begin();
	changes_end = changes.end();
	for(; changes_cur != changes_end; changes_cur++) {
		dict1->items[
			new PyRepInteger(changes_cur->first)
		] = changes_cur->second;
	}
	changes.clear();
	tuple0->items[1] = dict1;
	
	res = tuple0;
	

	return(res);
}

bool NotifyOnItemChange::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool NotifyOnItemChange::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnItemChange failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnItemChange failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0: this is a util.Row  */
	delete itemRow;
	itemRow = tuple0->items[0];
	tuple0->items[0] = NULL;
	
	/*  1: map from row index (ix* constants) to the old value for the item.   */
	if(!tuple0->items[1]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnItemChange failed: changes is not a dict: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	changes.clear();
	PyRepDict *dict_1 = (PyRepDict *) tuple0->items[1];
	PyRepDict::iterator changes_cur, changes_end;
	changes_cur = dict_1->items.begin();
	changes_end = dict_1->items.end();
	int changes_index;
	for(changes_index = 0; changes_cur != changes_end; changes_cur++, changes_index++) {
		if(!changes_cur->first->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode NotifyOnItemChange failed: Key %d in dict changes is not an integer: %s", changes_index, changes_cur->first->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *k = (PyRepInteger *) changes_cur->first;
		if(k->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode NotifyOnItemChange: truncating 64 bit into into 32 bit int in key of entry %d in field changes", changes_index);
		}
		changes[k->value] = changes_cur->second->Clone();
	}
	

	delete packet;
	return(true);
}

NotifyOnItemChange *NotifyOnItemChange::Clone() const {
	NotifyOnItemChange *res = new NotifyOnItemChange;
	res->CloneFrom(this);
	return(res);
}

void NotifyOnItemChange::CloneFrom(const NotifyOnItemChange *from) {
	/*  0: this is a util.Row  */
	delete itemRow;
	if(from->itemRow == NULL) {
		itemRow = NULL;
	} else {
		itemRow = from->itemRow->Clone();
	}
	/*  1: map from row index (ix* constants) to the old value for the item.   */
	std::map<uint32, PyRep *>::const_iterator changes_cur, changes_end;
	//free any existing elements first
	changes_cur = changes.begin();
	changes_end = changes.end();
	for(; changes_cur != changes_end; changes_cur++) {
		delete changes_cur->second;
	}
	changes.clear();
	//now we can copy in the new ones...
	changes_cur = from->changes.begin();
	changes_end = from->changes.end();
	for(; changes_cur != changes_end; changes_cur++) {
		changes[changes_cur->first] = changes_cur->second->Clone();
	}
	
	
}


NotifyOnSkillStartTraining::NotifyOnSkillStartTraining() {
	itemID = 0;
	endOfTraining = 0;
}

NotifyOnSkillStartTraining::~NotifyOnSkillStartTraining() {
}

void NotifyOnSkillStartTraining::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotifyOnSkillStartTraining", pfx);
	_log(l_type, "%sitemID=%lu", pfx, itemID);
	_log(l_type, "%sendOfTraining=" I64u, pfx, endOfTraining);
}

PyRepTuple *NotifyOnSkillStartTraining::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(itemID);
	tuple0->items[1] = new PyRepInteger(endOfTraining);
	res = tuple0;
	

	return(res);
}

PyRepTuple *NotifyOnSkillStartTraining::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(itemID);
	tuple0->items[1] = new PyRepInteger(endOfTraining);
	res = tuple0;
	

	return(res);
}

bool NotifyOnSkillStartTraining::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool NotifyOnSkillStartTraining::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnSkillStartTraining failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnSkillStartTraining failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnSkillStartTraining failed: itemID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode NotifyOnSkillStartTraining: truncating 64 bit into into 32 bit int for field itemID");
	}
	itemID = int_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnSkillStartTraining failed: endOfTraining is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_2 = (PyRepInteger *) tuple0->items[1];
	endOfTraining = int64_2->value;

	delete packet;
	return(true);
}

NotifyOnSkillStartTraining *NotifyOnSkillStartTraining::Clone() const {
	NotifyOnSkillStartTraining *res = new NotifyOnSkillStartTraining;
	res->CloneFrom(this);
	return(res);
}

void NotifyOnSkillStartTraining::CloneFrom(const NotifyOnSkillStartTraining *from) {
	itemID = from->itemID;
	endOfTraining = from->endOfTraining;
	
}


NotifyOnSkillTrainingStopped::NotifyOnSkillTrainingStopped() {
	itemID = 0;
	endOfTraining = 0;
}

NotifyOnSkillTrainingStopped::~NotifyOnSkillTrainingStopped() {
}

void NotifyOnSkillTrainingStopped::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotifyOnSkillTrainingStopped", pfx);
	_log(l_type, "%sitemID=%lu", pfx, itemID);
	_log(l_type, "%sendOfTraining=" I64u, pfx, endOfTraining);
}

PyRepTuple *NotifyOnSkillTrainingStopped::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(itemID);
	tuple0->items[1] = new PyRepInteger(endOfTraining);
	res = tuple0;
	

	return(res);
}

PyRepTuple *NotifyOnSkillTrainingStopped::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(itemID);
	tuple0->items[1] = new PyRepInteger(endOfTraining);
	res = tuple0;
	

	return(res);
}

bool NotifyOnSkillTrainingStopped::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool NotifyOnSkillTrainingStopped::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnSkillTrainingStopped failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnSkillTrainingStopped failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnSkillTrainingStopped failed: itemID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode NotifyOnSkillTrainingStopped: truncating 64 bit into into 32 bit int for field itemID");
	}
	itemID = int_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnSkillTrainingStopped failed: endOfTraining is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_2 = (PyRepInteger *) tuple0->items[1];
	endOfTraining = int64_2->value;

	delete packet;
	return(true);
}

NotifyOnSkillTrainingStopped *NotifyOnSkillTrainingStopped::Clone() const {
	NotifyOnSkillTrainingStopped *res = new NotifyOnSkillTrainingStopped;
	res->CloneFrom(this);
	return(res);
}

void NotifyOnSkillTrainingStopped::CloneFrom(const NotifyOnSkillTrainingStopped *from) {
	itemID = from->itemID;
	endOfTraining = from->endOfTraining;
	
}


CallSetLabel::CallSetLabel() {
	itemID = 0;
	itemName = "";
}

CallSetLabel::~CallSetLabel() {
}

void CallSetLabel::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallSetLabel", pfx);
	_log(l_type, "%sitemID=%lu", pfx, itemID);
	_log(l_type, "%sitemName='%s'", pfx, itemName.c_str());
}

PyRepTuple *CallSetLabel::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(itemID);
	tuple0->items[1] = new PyRepString(itemName);
	res = tuple0;
	

	return(res);
}

PyRepTuple *CallSetLabel::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(itemID);
	tuple0->items[1] = new PyRepString(itemName);
	res = tuple0;
	

	return(res);
}

bool CallSetLabel::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallSetLabel::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallSetLabel failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode CallSetLabel failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallSetLabel failed: itemID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallSetLabel: truncating 64 bit into into 32 bit int for field itemID");
	}
	itemID = int_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode CallSetLabel failed: itemName is not a string: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple0->items[1];
	itemName = string_2->value;

	delete packet;
	return(true);
}

CallSetLabel *CallSetLabel::Clone() const {
	CallSetLabel *res = new CallSetLabel;
	res->CloneFrom(this);
	return(res);
}

void CallSetLabel::CloneFrom(const CallSetLabel *from) {
	itemID = from->itemID;
	itemName = from->itemName;
	
}


InvBroker_BindArgs::InvBroker_BindArgs() {
	entityID = 0;
	unknown1 = NULL;
}

InvBroker_BindArgs::~InvBroker_BindArgs() {
	delete unknown1;
}

void InvBroker_BindArgs::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sInvBroker_BindArgs", pfx);
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	_log(l_type, "%sunknown1:", pfx);
	std::string unknown1_n(pfx);
	unknown1_n += "    ";
	if(unknown1 == NULL) {
		_log(l_type, "%sERROR: NULL REP!", unknown1_n.c_str());
	} else {
		unknown1->Dump(l_type, unknown1_n.c_str());
	}
}

PyRepTuple *InvBroker_BindArgs::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(entityID);
	if(unknown1 == NULL) {
		_log(NET__PACKET_ERROR, "Encode InvBroker_BindArgs: unknown1 is NULL! hacking in a PyRepNone");
		unknown1 = new PyRepNone();
	}
	tuple0->items[1] = unknown1->Clone();
	res = tuple0;
	

	return(res);
}

PyRepTuple *InvBroker_BindArgs::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(entityID);
	if(unknown1 == NULL) {
		_log(NET__PACKET_ERROR, "Encode InvBroker_BindArgs: unknown1 is NULL! hacking in a PyRepNone");
		unknown1 = new PyRepNone();
	}
	tuple0->items[1] = unknown1;
	unknown1 = NULL;
	res = tuple0;
	

	return(res);
}

bool InvBroker_BindArgs::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool InvBroker_BindArgs::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode InvBroker_BindArgs failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode InvBroker_BindArgs failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode InvBroker_BindArgs failed: entityID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode InvBroker_BindArgs: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_1->value;
	delete unknown1;
	unknown1 = tuple0->items[1];
	tuple0->items[1] = NULL;
	

	delete packet;
	return(true);
}

InvBroker_BindArgs *InvBroker_BindArgs::Clone() const {
	InvBroker_BindArgs *res = new InvBroker_BindArgs;
	res->CloneFrom(this);
	return(res);
}

void InvBroker_BindArgs::CloneFrom(const InvBroker_BindArgs *from) {
	entityID = from->entityID;
	delete unknown1;
	if(from->unknown1 == NULL) {
		unknown1 = NULL;
	} else {
		unknown1 = from->unknown1->Clone();
	}
	
}


Inventory_GetInventory::Inventory_GetInventory() {
	container = 0;
	argument = NULL;
}

Inventory_GetInventory::~Inventory_GetInventory() {
	delete argument;
}

void Inventory_GetInventory::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sInventory_GetInventory", pfx);
	_log(l_type, "%scontainer=%lu", pfx, container);
	_log(l_type, "%sargument:", pfx);
	std::string argument_n(pfx);
	argument_n += "    ";
	if(argument == NULL) {
		_log(l_type, "%sERROR: NULL REP!", argument_n.c_str());
	} else {
		argument->Dump(l_type, argument_n.c_str());
	}
}

PyRepTuple *Inventory_GetInventory::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(container);
	if(argument == NULL) {
		_log(NET__PACKET_ERROR, "Encode Inventory_GetInventory: argument is NULL! hacking in a PyRepNone");
		argument = new PyRepNone();
	}
	tuple0->items[1] = argument->Clone();
	res = tuple0;
	

	return(res);
}

PyRepTuple *Inventory_GetInventory::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(container);
	if(argument == NULL) {
		_log(NET__PACKET_ERROR, "Encode Inventory_GetInventory: argument is NULL! hacking in a PyRepNone");
		argument = new PyRepNone();
	}
	tuple0->items[1] = argument;
	argument = NULL;
	res = tuple0;
	

	return(res);
}

bool Inventory_GetInventory::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Inventory_GetInventory::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_GetInventory failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Inventory_GetInventory failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_GetInventory failed: container is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_GetInventory: truncating 64 bit into into 32 bit int for field container");
	}
	container = int_1->value;
	delete argument;
	argument = tuple0->items[1];
	tuple0->items[1] = NULL;
	

	delete packet;
	return(true);
}

Inventory_GetInventory *Inventory_GetInventory::Clone() const {
	Inventory_GetInventory *res = new Inventory_GetInventory;
	res->CloneFrom(this);
	return(res);
}

void Inventory_GetInventory::CloneFrom(const Inventory_GetInventory *from) {
	container = from->container;
	delete argument;
	if(from->argument == NULL) {
		argument = NULL;
	} else {
		argument = from->argument->Clone();
	}
	
}


Inventory_CallAdd::Inventory_CallAdd() {
	itemID = 0;
	quantity = 0;
	flag = 0;
}

Inventory_CallAdd::~Inventory_CallAdd() {
}

void Inventory_CallAdd::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sInventory_CallAdd", pfx);
	_log(l_type, "%sitemID=%lu", pfx, itemID);
	_log(l_type, "%squantity=%lu", pfx, quantity);
	_log(l_type, "%sflag=%lu", pfx, flag);
}

PyRepTuple *Inventory_CallAdd::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	tuple0->items[0] = new PyRepInteger(itemID);
	tuple0->items[1] = new PyRepInteger(quantity);
	tuple0->items[2] = new PyRepInteger(flag);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Inventory_CallAdd::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	tuple0->items[0] = new PyRepInteger(itemID);
	tuple0->items[1] = new PyRepInteger(quantity);
	tuple0->items[2] = new PyRepInteger(flag);
	res = tuple0;
	

	return(res);
}

bool Inventory_CallAdd::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Inventory_CallAdd::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallAdd failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallAdd failed: tuple0 is the wrong size: expected 3, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallAdd failed: itemID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_CallAdd: truncating 64 bit into into 32 bit int for field itemID");
	}
	itemID = int_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallAdd failed: quantity is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_CallAdd: truncating 64 bit into into 32 bit int for field quantity");
	}
	quantity = int_2->value;
	if(!tuple0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallAdd failed: flag is not an int: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple0->items[2];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_CallAdd: truncating 64 bit into into 32 bit int for field flag");
	}
	flag = int_3->value;

	delete packet;
	return(true);
}

Inventory_CallAdd *Inventory_CallAdd::Clone() const {
	Inventory_CallAdd *res = new Inventory_CallAdd;
	res->CloneFrom(this);
	return(res);
}

void Inventory_CallAdd::CloneFrom(const Inventory_CallAdd *from) {
	itemID = from->itemID;
	quantity = from->quantity;
	flag = from->flag;
	
}


Inventory_CallAddCargoContainer::Inventory_CallAddCargoContainer() {
	itemID = 0;
	quantity = 0;
}

Inventory_CallAddCargoContainer::~Inventory_CallAddCargoContainer() {
}

void Inventory_CallAddCargoContainer::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sInventory_CallAddCargoContainer", pfx);
	_log(l_type, "%sitemID=%lu", pfx, itemID);
	_log(l_type, "%squantity=%lu", pfx, quantity);
}

PyRepTuple *Inventory_CallAddCargoContainer::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(itemID);
	tuple0->items[1] = new PyRepInteger(quantity);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Inventory_CallAddCargoContainer::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(itemID);
	tuple0->items[1] = new PyRepInteger(quantity);
	res = tuple0;
	

	return(res);
}

bool Inventory_CallAddCargoContainer::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Inventory_CallAddCargoContainer::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallAddCargoContainer failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallAddCargoContainer failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallAddCargoContainer failed: itemID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_CallAddCargoContainer: truncating 64 bit into into 32 bit int for field itemID");
	}
	itemID = int_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallAddCargoContainer failed: quantity is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_CallAddCargoContainer: truncating 64 bit into into 32 bit int for field quantity");
	}
	quantity = int_2->value;

	delete packet;
	return(true);
}

Inventory_CallAddCargoContainer *Inventory_CallAddCargoContainer::Clone() const {
	Inventory_CallAddCargoContainer *res = new Inventory_CallAddCargoContainer;
	res->CloneFrom(this);
	return(res);
}

void Inventory_CallAddCargoContainer::CloneFrom(const Inventory_CallAddCargoContainer *from) {
	itemID = from->itemID;
	quantity = from->quantity;
	
}


Inventory_CallMultiAdd::Inventory_CallMultiAdd() {
	quantity = 0;
	/*  almost always 1 on a multiadd  */
	flag = 0;
}

Inventory_CallMultiAdd::~Inventory_CallMultiAdd() {
	/*  almost always 1 on a multiadd  */
}

void Inventory_CallMultiAdd::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sInventory_CallMultiAdd", pfx);
	_log(l_type, "%sitemIDs: Integer list with %d enetires", pfx, itemIDs.size());
	std::vector<uint32>::const_iterator itemIDs_cur, itemIDs_end;
	itemIDs_cur = itemIDs.begin();
	itemIDs_end = itemIDs.end();
	int itemIDs_index;
	for(itemIDs_index = 0; itemIDs_cur != itemIDs_end; itemIDs_cur++, itemIDs_index++) {
		_log(l_type, "%s   [%02d] %d", pfx, itemIDs_index, *itemIDs_cur);
	}
	
	_log(l_type, "%squantity=%lu", pfx, quantity);
	/*  almost always 1 on a multiadd  */
	_log(l_type, "%sflag=%lu", pfx, flag);
}

PyRepTuple *Inventory_CallMultiAdd::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator itemIDs_cur, itemIDs_end;
	itemIDs_cur = itemIDs.begin();
	itemIDs_end = itemIDs.end();
	for(; itemIDs_cur != itemIDs_end; itemIDs_cur++) {
		list1->items.push_back(
			new PyRepInteger(*itemIDs_cur)
		);
	}
	tuple0->items[0] = list1;
	
	if(quantity == 1) {
		tuple0->items[1] = new PyRepNone();
	} else {
		tuple0->items[1] = new PyRepInteger(quantity);
	}
	/*  almost always 1 on a multiadd  */
	tuple0->items[2] = new PyRepInteger(flag);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Inventory_CallMultiAdd::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator itemIDs_cur, itemIDs_end;
	itemIDs_cur = itemIDs.begin();
	itemIDs_end = itemIDs.end();
	for(; itemIDs_cur != itemIDs_end; itemIDs_cur++) {
		list1->items.push_back(
			new PyRepInteger(*itemIDs_cur)
		);
	}
	tuple0->items[0] = list1;
	
	if(quantity == 1) {
		tuple0->items[1] = new PyRepNone();
	} else {
		tuple0->items[1] = new PyRepInteger(quantity);
	}
	/*  almost always 1 on a multiadd  */
	tuple0->items[2] = new PyRepInteger(flag);
	res = tuple0;
	

	return(res);
}

bool Inventory_CallMultiAdd::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Inventory_CallMultiAdd::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallMultiAdd failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallMultiAdd failed: tuple0 is the wrong size: expected 3, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallMultiAdd failed: itemIDs is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	itemIDs.clear();
	PyRepList *list_1 = (PyRepList *) tuple0->items[0];
	PyRepList::iterator itemIDs_cur, itemIDs_end;
	itemIDs_cur = list_1->items.begin();
	itemIDs_end = list_1->items.end();
	int itemIDs_index;
	for(itemIDs_index = 0; itemIDs_cur != itemIDs_end; itemIDs_cur++, itemIDs_index++) {
		if(!(*itemIDs_cur)->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode Inventory_CallMultiAdd failed: Element %d in list itemIDs is not an integer: %s", itemIDs_index, (*itemIDs_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *t = (PyRepInteger *) (*itemIDs_cur);
		if(t->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode Inventory_CallMultiAdd: truncating 64 bit into into 32 bit int for item %d in field itemIDs", itemIDs_index);
		}
		itemIDs.push_back(t->value);
	}

	if(tuple0->items[1]->CheckType(PyRep::None)) {
		quantity = 1;
	} else {
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallMultiAdd failed: quantity is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_CallMultiAdd: truncating 64 bit into into 32 bit int for field quantity");
	}
	quantity = int_2->value;
	}
	/*  almost always 1 on a multiadd  */
	if(!tuple0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallMultiAdd failed: flag is not an int: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple0->items[2];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_CallMultiAdd: truncating 64 bit into into 32 bit int for field flag");
	}
	flag = int_3->value;

	delete packet;
	return(true);
}

Inventory_CallMultiAdd *Inventory_CallMultiAdd::Clone() const {
	Inventory_CallMultiAdd *res = new Inventory_CallMultiAdd;
	res->CloneFrom(this);
	return(res);
}

void Inventory_CallMultiAdd::CloneFrom(const Inventory_CallMultiAdd *from) {
	itemIDs = from->itemIDs;
	quantity = from->quantity;
	/*  almost always 1 on a multiadd  */
	flag = from->flag;
	
}


Inventory_CallReplaceCharges::Inventory_CallReplaceCharges() {
	flag = 0;
	itemID = 0;
	quantity = 0;
}

Inventory_CallReplaceCharges::~Inventory_CallReplaceCharges() {
}

void Inventory_CallReplaceCharges::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sInventory_CallReplaceCharges", pfx);
	_log(l_type, "%sflag=%lu", pfx, flag);
	_log(l_type, "%sitemID=%lu", pfx, itemID);
	_log(l_type, "%squantity=%lu", pfx, quantity);
}

PyRepTuple *Inventory_CallReplaceCharges::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	tuple0->items[0] = new PyRepInteger(flag);
	tuple0->items[1] = new PyRepInteger(itemID);
	tuple0->items[2] = new PyRepInteger(quantity);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Inventory_CallReplaceCharges::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	tuple0->items[0] = new PyRepInteger(flag);
	tuple0->items[1] = new PyRepInteger(itemID);
	tuple0->items[2] = new PyRepInteger(quantity);
	res = tuple0;
	

	return(res);
}

bool Inventory_CallReplaceCharges::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Inventory_CallReplaceCharges::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallReplaceCharges failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallReplaceCharges failed: tuple0 is the wrong size: expected 3, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallReplaceCharges failed: flag is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_CallReplaceCharges: truncating 64 bit into into 32 bit int for field flag");
	}
	flag = int_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallReplaceCharges failed: itemID is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_CallReplaceCharges: truncating 64 bit into into 32 bit int for field itemID");
	}
	itemID = int_2->value;
	if(!tuple0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallReplaceCharges failed: quantity is not an int: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple0->items[2];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_CallReplaceCharges: truncating 64 bit into into 32 bit int for field quantity");
	}
	quantity = int_3->value;

	delete packet;
	return(true);
}

Inventory_CallReplaceCharges *Inventory_CallReplaceCharges::Clone() const {
	Inventory_CallReplaceCharges *res = new Inventory_CallReplaceCharges;
	res->CloneFrom(this);
	return(res);
}

void Inventory_CallReplaceCharges::CloneFrom(const Inventory_CallReplaceCharges *from) {
	flag = from->flag;
	itemID = from->itemID;
	quantity = from->quantity;
	
}


Inventory_CallMultiMergeElement::Inventory_CallMultiMergeElement() {
	draggedItemID = 0;
	stationaryItemID = 0;
	draggedQty = 0;
}

Inventory_CallMultiMergeElement::~Inventory_CallMultiMergeElement() {
}

void Inventory_CallMultiMergeElement::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sInventory_CallMultiMergeElement", pfx);
	_log(l_type, "%sdraggedItemID=%lu", pfx, draggedItemID);
	_log(l_type, "%sstationaryItemID=%lu", pfx, stationaryItemID);
	_log(l_type, "%sdraggedQty=%lu", pfx, draggedQty);
}

PyRepTuple *Inventory_CallMultiMergeElement::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	tuple0->items[0] = new PyRepInteger(draggedItemID);
	tuple0->items[1] = new PyRepInteger(stationaryItemID);
	tuple0->items[2] = new PyRepInteger(draggedQty);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Inventory_CallMultiMergeElement::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	tuple0->items[0] = new PyRepInteger(draggedItemID);
	tuple0->items[1] = new PyRepInteger(stationaryItemID);
	tuple0->items[2] = new PyRepInteger(draggedQty);
	res = tuple0;
	

	return(res);
}

bool Inventory_CallMultiMergeElement::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Inventory_CallMultiMergeElement::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallMultiMergeElement failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallMultiMergeElement failed: tuple0 is the wrong size: expected 3, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallMultiMergeElement failed: draggedItemID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_CallMultiMergeElement: truncating 64 bit into into 32 bit int for field draggedItemID");
	}
	draggedItemID = int_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallMultiMergeElement failed: stationaryItemID is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_CallMultiMergeElement: truncating 64 bit into into 32 bit int for field stationaryItemID");
	}
	stationaryItemID = int_2->value;
	if(!tuple0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallMultiMergeElement failed: draggedQty is not an int: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple0->items[2];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_CallMultiMergeElement: truncating 64 bit into into 32 bit int for field draggedQty");
	}
	draggedQty = int_3->value;

	delete packet;
	return(true);
}

Inventory_CallMultiMergeElement *Inventory_CallMultiMergeElement::Clone() const {
	Inventory_CallMultiMergeElement *res = new Inventory_CallMultiMergeElement;
	res->CloneFrom(this);
	return(res);
}

void Inventory_CallMultiMergeElement::CloneFrom(const Inventory_CallMultiMergeElement *from) {
	draggedItemID = from->draggedItemID;
	stationaryItemID = from->stationaryItemID;
	draggedQty = from->draggedQty;
	
}


Inventory_CallMultiMerge::Inventory_CallMultiMerge() {
}

Inventory_CallMultiMerge::~Inventory_CallMultiMerge() {
}

void Inventory_CallMultiMerge::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sInventory_CallMultiMerge", pfx);
	_log(l_type, "%sMMElements: ", pfx);
	std::string MMElements_n(pfx);
	MMElements_n += "    ";
	MMElements.Dump(l_type, MMElements_n.c_str());
}

PyRepTuple *Inventory_CallMultiMerge::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	tuple0->items[0] = MMElements.Clone();
	res = tuple0;
	

	return(res);
}

PyRepTuple *Inventory_CallMultiMerge::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	
	PyRepList *list1 = new PyRepList();
	list1->items = MMElements.items;
	MMElements.items.clear();
	tuple0->items[0] = list1;
	res = tuple0;
	

	return(res);
}

bool Inventory_CallMultiMerge::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Inventory_CallMultiMerge::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallMultiMerge failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallMultiMerge failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallMultiMerge failed: MMElements is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_MMElements = (PyRepList *) tuple0->items[0];	MMElements.items = list_MMElements->items;
	list_MMElements->items.clear();
	

	delete packet;
	return(true);
}

Inventory_CallMultiMerge *Inventory_CallMultiMerge::Clone() const {
	Inventory_CallMultiMerge *res = new Inventory_CallMultiMerge;
	res->CloneFrom(this);
	return(res);
}

void Inventory_CallMultiMerge::CloneFrom(const Inventory_CallMultiMerge *from) {
	MMElements.CloneFrom(&from->MMElements);
	
}


Inventory_ItemCannotBeInDroneBayException::Inventory_ItemCannotBeInDroneBayException() {
	/* object of type ccp_exceptions.UserError */
	exceptionType = "ItemCannotBeInDroneBay";
	exceptTypeDict = "ItemCannotBeInDroneBay";
}

Inventory_ItemCannotBeInDroneBayException::~Inventory_ItemCannotBeInDroneBayException() {
}

void Inventory_ItemCannotBeInDroneBayException::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sInventory_ItemCannotBeInDroneBayException", pfx);
	_log(l_type, "%sObject of type ccp_exceptions.UserError:", pfx);
	_log(l_type, "%sexceptionType='%s'", pfx, exceptionType.c_str());
	_log(l_type, "%sexceptTypeDict='%s'", pfx, exceptTypeDict.c_str());
}

PyRepObject *Inventory_ItemCannotBeInDroneBayException::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepTuple *tuple2 = new PyRepTuple(1);
	tuple2->items[0] = new PyRepString(exceptionType);
	dict1_0 = tuple2;
	
	dict1->items[
		new PyRepString("args")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepString(exceptTypeDict);
	dict1->items[
		new PyRepString("msg")
	] = dict1_1;
	PyRep *dict1_2;
	dict1_2 = new PyRepNone();
	dict1->items[
		new PyRepString("dict")
	] = dict1_2;
	args0 = dict1;
	
	res = new PyRepObject(
			"ccp_exceptions.UserError",
			args0
		);
	

	return(res);
}

PyRepObject *Inventory_ItemCannotBeInDroneBayException::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepTuple *tuple2 = new PyRepTuple(1);
	tuple2->items[0] = new PyRepString(exceptionType);
	dict1_0 = tuple2;
	
	dict1->items[
		new PyRepString("args")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepString(exceptTypeDict);
	dict1->items[
		new PyRepString("msg")
	] = dict1_1;
	PyRep *dict1_2;
	dict1_2 = new PyRepNone();
	dict1->items[
		new PyRepString("dict")
	] = dict1_2;
	args0 = dict1;
	
	res = new PyRepObject(
			"ccp_exceptions.UserError",
			args0
		);
	

	return(res);
}

bool Inventory_ItemCannotBeInDroneBayException::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Inventory_ItemCannotBeInDroneBayException::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_ItemCannotBeInDroneBayException failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "ccp_exceptions.UserError") {
		_log(NET__PACKET_ERROR, "Decode Inventory_ItemCannotBeInDroneBayException failed: obj_0 is the wrong object type. Expected 'ccp_exceptions.UserError', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_ItemCannotBeInDroneBayException failed: dict1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict1_args_tuple = false;
	bool dict1_exceptTypeDict = false;
	bool dict1_useless = false;
	PyRepDict *dict1 = (PyRepDict *) obj_0->arguments;
	
	PyRepDict::iterator dict1_cur, dict1_end;
	dict1_cur = dict1->items.begin();
	dict1_end = dict1->items.end();
	for(; dict1_cur != dict1_end; dict1_cur++) {
		PyRep *key__ = dict1_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode Inventory_ItemCannotBeInDroneBayException failed: a key in dict1 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "args") {
			dict1_args_tuple = true;
	if(!dict1_cur->second->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_ItemCannotBeInDroneBayException failed: tuple2 is the wrong type: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) dict1_cur->second;
	if(tuple2->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode Inventory_ItemCannotBeInDroneBayException failed: tuple2 is the wrong size: expected 1, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	if(!tuple2->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_ItemCannotBeInDroneBayException failed: exceptionType is not a string: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) tuple2->items[0];
	exceptionType = string_3->value;
		} else
		if(key_string__->value == "msg") {
			dict1_exceptTypeDict = true;
	if(!dict1_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_ItemCannotBeInDroneBayException failed: exceptTypeDict is not a string: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_4 = (PyRepString *) dict1_cur->second;
	exceptTypeDict = string_4->value;
		} else
		if(key_string__->value == "dict") {
			dict1_useless = true;
	if(!dict1_cur->second->CheckType(PyRep::None)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_ItemCannotBeInDroneBayException failed: expecting a None but got a %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	
		} else
		{
			_log(NET__PACKET_ERROR, "Decode Inventory_ItemCannotBeInDroneBayException failed: Unknown key string '%s' in dict1", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict1_args_tuple) {
		_log(NET__PACKET_ERROR, "Decode Inventory_ItemCannotBeInDroneBayException failed: Missing dict entry for 'args_tuple' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_exceptTypeDict) {
		_log(NET__PACKET_ERROR, "Decode Inventory_ItemCannotBeInDroneBayException failed: Missing dict entry for 'exceptTypeDict' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_useless) {
		_log(NET__PACKET_ERROR, "Decode Inventory_ItemCannotBeInDroneBayException failed: Missing dict entry for 'useless' in dict1");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

Inventory_ItemCannotBeInDroneBayException *Inventory_ItemCannotBeInDroneBayException::Clone() const {
	Inventory_ItemCannotBeInDroneBayException *res = new Inventory_ItemCannotBeInDroneBayException;
	res->CloneFrom(this);
	return(res);
}

void Inventory_ItemCannotBeInDroneBayException::CloneFrom(const Inventory_ItemCannotBeInDroneBayException *from) {
	/* object of type ccp_exceptions.UserError */
	exceptionType = from->exceptionType;
	exceptTypeDict = from->exceptTypeDict;
	
}


Inventory_NotEnoughCargoSpaceException::Inventory_NotEnoughCargoSpaceException() {
	/* object of type ccp_exceptions.UserError */
	exceptionType = "NotEnoughCargoSpace";
	spaceavail = 0.0;
	volume = 1.0;
	exceptTypeDict = "NotEnoughCargoSpace";
	spaceavaildict = 0.0;
	volumedict = 1.0;
}

Inventory_NotEnoughCargoSpaceException::~Inventory_NotEnoughCargoSpaceException() {
}

void Inventory_NotEnoughCargoSpaceException::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sInventory_NotEnoughCargoSpaceException", pfx);
	_log(l_type, "%sObject of type ccp_exceptions.UserError:", pfx);
	_log(l_type, "%sexceptionType='%s'", pfx, exceptionType.c_str());
	_log(l_type, "%sspaceavail=%.13f", pfx, spaceavail);
	_log(l_type, "%svolume=%.13f", pfx, volume);
	_log(l_type, "%sexceptTypeDict='%s'", pfx, exceptTypeDict.c_str());
	_log(l_type, "%sspaceavaildict=%.13f", pfx, spaceavaildict);
	_log(l_type, "%svolumedict=%.13f", pfx, volumedict);
}

PyRepObject *Inventory_NotEnoughCargoSpaceException::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepTuple *tuple2 = new PyRepTuple(2);
	tuple2->items[0] = new PyRepString(exceptionType);
	PyRepDict *dict3 = new PyRepDict();
	PyRep *dict3_0;
	dict3_0 = new PyRepReal(spaceavail);
	dict3->items[
		new PyRepString("available")
	] = dict3_0;
	PyRep *dict3_1;
	dict3_1 = new PyRepReal(volume);
	dict3->items[
		new PyRepString("volume")
	] = dict3_1;
	tuple2->items[1] = dict3;
	
	dict1_0 = tuple2;
	
	dict1->items[
		new PyRepString("args")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepString(exceptTypeDict);
	dict1->items[
		new PyRepString("msg")
	] = dict1_1;
	PyRep *dict1_2;
	PyRepDict *dict4 = new PyRepDict();
	PyRep *dict4_0;
	dict4_0 = new PyRepReal(spaceavaildict);
	dict4->items[
		new PyRepString("available")
	] = dict4_0;
	PyRep *dict4_1;
	dict4_1 = new PyRepReal(volumedict);
	dict4->items[
		new PyRepString("volume")
	] = dict4_1;
	dict1_2 = dict4;
	
	dict1->items[
		new PyRepString("dict")
	] = dict1_2;
	args0 = dict1;
	
	res = new PyRepObject(
			"ccp_exceptions.UserError",
			args0
		);
	

	return(res);
}

PyRepObject *Inventory_NotEnoughCargoSpaceException::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepTuple *tuple2 = new PyRepTuple(2);
	tuple2->items[0] = new PyRepString(exceptionType);
	PyRepDict *dict3 = new PyRepDict();
	PyRep *dict3_0;
	dict3_0 = new PyRepReal(spaceavail);
	dict3->items[
		new PyRepString("available")
	] = dict3_0;
	PyRep *dict3_1;
	dict3_1 = new PyRepReal(volume);
	dict3->items[
		new PyRepString("volume")
	] = dict3_1;
	tuple2->items[1] = dict3;
	
	dict1_0 = tuple2;
	
	dict1->items[
		new PyRepString("args")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepString(exceptTypeDict);
	dict1->items[
		new PyRepString("msg")
	] = dict1_1;
	PyRep *dict1_2;
	PyRepDict *dict4 = new PyRepDict();
	PyRep *dict4_0;
	dict4_0 = new PyRepReal(spaceavaildict);
	dict4->items[
		new PyRepString("available")
	] = dict4_0;
	PyRep *dict4_1;
	dict4_1 = new PyRepReal(volumedict);
	dict4->items[
		new PyRepString("volume")
	] = dict4_1;
	dict1_2 = dict4;
	
	dict1->items[
		new PyRepString("dict")
	] = dict1_2;
	args0 = dict1;
	
	res = new PyRepObject(
			"ccp_exceptions.UserError",
			args0
		);
	

	return(res);
}

bool Inventory_NotEnoughCargoSpaceException::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Inventory_NotEnoughCargoSpaceException::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_NotEnoughCargoSpaceException failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "ccp_exceptions.UserError") {
		_log(NET__PACKET_ERROR, "Decode Inventory_NotEnoughCargoSpaceException failed: obj_0 is the wrong object type. Expected 'ccp_exceptions.UserError', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_NotEnoughCargoSpaceException failed: dict1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict1_args_tuple = false;
	bool dict1_exceptTypeDict = false;
	bool dict1_arg_dict = false;
	PyRepDict *dict1 = (PyRepDict *) obj_0->arguments;
	
	PyRepDict::iterator dict1_cur, dict1_end;
	dict1_cur = dict1->items.begin();
	dict1_end = dict1->items.end();
	for(; dict1_cur != dict1_end; dict1_cur++) {
		PyRep *key__ = dict1_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode Inventory_NotEnoughCargoSpaceException failed: a key in dict1 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "args") {
			dict1_args_tuple = true;
	if(!dict1_cur->second->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_NotEnoughCargoSpaceException failed: tuple2 is the wrong type: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) dict1_cur->second;
	if(tuple2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Inventory_NotEnoughCargoSpaceException failed: tuple2 is the wrong size: expected 2, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	if(!tuple2->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_NotEnoughCargoSpaceException failed: exceptionType is not a string: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) tuple2->items[0];
	exceptionType = string_3->value;
	if(!tuple2->items[1]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_NotEnoughCargoSpaceException failed: dict4 is the wrong type: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	bool dict4_spaceavail = false;
	bool dict4_volume = false;
	PyRepDict *dict4 = (PyRepDict *) tuple2->items[1];
	
	PyRepDict::iterator dict4_cur, dict4_end;
	dict4_cur = dict4->items.begin();
	dict4_end = dict4->items.end();
	for(; dict4_cur != dict4_end; dict4_cur++) {
		PyRep *key__ = dict4_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode Inventory_NotEnoughCargoSpaceException failed: a key in dict4 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "available") {
			dict4_spaceavail = true;
	if(!dict4_cur->second->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_NotEnoughCargoSpaceException failed: spaceavail is not a real: %s", dict4_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_5 = (PyRepReal *) dict4_cur->second;
	spaceavail = real_5->value;
		} else
		if(key_string__->value == "volume") {
			dict4_volume = true;
	if(!dict4_cur->second->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_NotEnoughCargoSpaceException failed: volume is not a real: %s", dict4_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_6 = (PyRepReal *) dict4_cur->second;
	volume = real_6->value;
		} else
		{
			_log(NET__PACKET_ERROR, "Decode Inventory_NotEnoughCargoSpaceException failed: Unknown key string '%s' in dict4", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict4_spaceavail) {
		_log(NET__PACKET_ERROR, "Decode Inventory_NotEnoughCargoSpaceException failed: Missing dict entry for 'spaceavail' in dict4");
		delete packet;
		return(false);
	}
	
	if(!dict4_volume) {
		_log(NET__PACKET_ERROR, "Decode Inventory_NotEnoughCargoSpaceException failed: Missing dict entry for 'volume' in dict4");
		delete packet;
		return(false);
	}
	
		} else
		if(key_string__->value == "msg") {
			dict1_exceptTypeDict = true;
	if(!dict1_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_NotEnoughCargoSpaceException failed: exceptTypeDict is not a string: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_7 = (PyRepString *) dict1_cur->second;
	exceptTypeDict = string_7->value;
		} else
		if(key_string__->value == "dict") {
			dict1_arg_dict = true;
	if(!dict1_cur->second->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_NotEnoughCargoSpaceException failed: dict8 is the wrong type: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	bool dict8_spaceavaildict = false;
	bool dict8_volumedict = false;
	PyRepDict *dict8 = (PyRepDict *) dict1_cur->second;
	
	PyRepDict::iterator dict8_cur, dict8_end;
	dict8_cur = dict8->items.begin();
	dict8_end = dict8->items.end();
	for(; dict8_cur != dict8_end; dict8_cur++) {
		PyRep *key__ = dict8_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode Inventory_NotEnoughCargoSpaceException failed: a key in dict8 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "available") {
			dict8_spaceavaildict = true;
	if(!dict8_cur->second->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_NotEnoughCargoSpaceException failed: spaceavaildict is not a real: %s", dict8_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_9 = (PyRepReal *) dict8_cur->second;
	spaceavaildict = real_9->value;
		} else
		if(key_string__->value == "volume") {
			dict8_volumedict = true;
	if(!dict8_cur->second->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_NotEnoughCargoSpaceException failed: volumedict is not a real: %s", dict8_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_10 = (PyRepReal *) dict8_cur->second;
	volumedict = real_10->value;
		} else
		{
			_log(NET__PACKET_ERROR, "Decode Inventory_NotEnoughCargoSpaceException failed: Unknown key string '%s' in dict8", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict8_spaceavaildict) {
		_log(NET__PACKET_ERROR, "Decode Inventory_NotEnoughCargoSpaceException failed: Missing dict entry for 'spaceavaildict' in dict8");
		delete packet;
		return(false);
	}
	
	if(!dict8_volumedict) {
		_log(NET__PACKET_ERROR, "Decode Inventory_NotEnoughCargoSpaceException failed: Missing dict entry for 'volumedict' in dict8");
		delete packet;
		return(false);
	}
	
		} else
		{
			_log(NET__PACKET_ERROR, "Decode Inventory_NotEnoughCargoSpaceException failed: Unknown key string '%s' in dict1", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict1_args_tuple) {
		_log(NET__PACKET_ERROR, "Decode Inventory_NotEnoughCargoSpaceException failed: Missing dict entry for 'args_tuple' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_exceptTypeDict) {
		_log(NET__PACKET_ERROR, "Decode Inventory_NotEnoughCargoSpaceException failed: Missing dict entry for 'exceptTypeDict' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_arg_dict) {
		_log(NET__PACKET_ERROR, "Decode Inventory_NotEnoughCargoSpaceException failed: Missing dict entry for 'arg_dict' in dict1");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

Inventory_NotEnoughCargoSpaceException *Inventory_NotEnoughCargoSpaceException::Clone() const {
	Inventory_NotEnoughCargoSpaceException *res = new Inventory_NotEnoughCargoSpaceException;
	res->CloneFrom(this);
	return(res);
}

void Inventory_NotEnoughCargoSpaceException::CloneFrom(const Inventory_NotEnoughCargoSpaceException *from) {
	/* object of type ccp_exceptions.UserError */
	exceptionType = from->exceptionType;
	spaceavail = from->spaceavail;
	volume = from->volume;
	exceptTypeDict = from->exceptTypeDict;
	spaceavaildict = from->spaceavaildict;
	volumedict = from->volumedict;
	
}


Inventory_CallStackAll::Inventory_CallStackAll() {
	locationFlag = 0;
}

Inventory_CallStackAll::~Inventory_CallStackAll() {
}

void Inventory_CallStackAll::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sInventory_CallStackAll", pfx);
	_log(l_type, "%slocationFlag=%lu", pfx, locationFlag);
}

PyRepTuple *Inventory_CallStackAll::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	if(locationFlag == 0) {
		tuple0->items[0] = new PyRepNone();
	} else {
		tuple0->items[0] = new PyRepInteger(locationFlag);
	}
	res = tuple0;
	

	return(res);
}

PyRepTuple *Inventory_CallStackAll::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	if(locationFlag == 0) {
		tuple0->items[0] = new PyRepNone();
	} else {
		tuple0->items[0] = new PyRepInteger(locationFlag);
	}
	res = tuple0;
	

	return(res);
}

bool Inventory_CallStackAll::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Inventory_CallStackAll::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallStackAll failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallStackAll failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(tuple0->items[0]->CheckType(PyRep::None)) {
		locationFlag = 0;
	} else {
	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallStackAll failed: locationFlag is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_CallStackAll: truncating 64 bit into into 32 bit int for field locationFlag");
	}
	locationFlag = int_1->value;
	}

	delete packet;
	return(true);
}

Inventory_CallStackAll *Inventory_CallStackAll::Clone() const {
	Inventory_CallStackAll *res = new Inventory_CallStackAll;
	res->CloneFrom(this);
	return(res);
}

void Inventory_CallStackAll::CloneFrom(const Inventory_CallStackAll *from) {
	locationFlag = from->locationFlag;
	
}


OnModuleAttributeChange::OnModuleAttributeChange() {
	/*  0  */
	/*  0  */
	/*  0  */
	string0 = "OnModuleAttributeChange";
	/*  1  */
	ownerID = 0;
	/*  2  */
	itemKey = 0;
	/*  3  */
	attributeID = 0;
	/*  4  */
	time = 0;
	/*  5  */
	newValue = 0.0;
	/*  6  */
	/*  0  */
	newValue2 = 0.0;
	/*  1  */
	time2 = 0;
	/*  2  */
	real8 = 0.0;
	/*  3  */
	oldValue = 0.0;
}

OnModuleAttributeChange::~OnModuleAttributeChange() {
	/*  0  */
	/*  0  */
	/*  0  */
	/*  1  */
	/*  2  */
	/*  3  */
	/*  4  */
	/*  5  */
	/*  6  */
	/*  0  */
	/*  1  */
	/*  2  */
	/*  3  */
}

void OnModuleAttributeChange::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sOnModuleAttributeChange", pfx);
	/*  0  */
	/*  0  */
	/*  0  */
	_log(l_type, "%sstring0='%s'", pfx, string0.c_str());
	/*  1  */
	_log(l_type, "%sownerID=%lu", pfx, ownerID);
	/*  2  */
	_log(l_type, "%sitemKey=%lu", pfx, itemKey);
	/*  3  */
	_log(l_type, "%sattributeID=%lu", pfx, attributeID);
	/*  4  */
	_log(l_type, "%stime=" I64u, pfx, time);
	/*  5  */
	_log(l_type, "%snewValue=%.13f", pfx, newValue);
	/*  6  */
	/*  0  */
	_log(l_type, "%snewValue2=%.13f", pfx, newValue2);
	/*  1  */
	_log(l_type, "%stime2=" I64u, pfx, time2);
	/*  2  */
	_log(l_type, "%sreal8=%.13f", pfx, real8);
	/*  3  */
	_log(l_type, "%soldValue=%.13f", pfx, oldValue);
}

PyRepTuple *OnModuleAttributeChange::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRepList *list1 = new PyRepList();
	list1->items.resize(1, NULL);
	/*  0  */
	PyRepTuple *tuple2 = new PyRepTuple(7);
	/*  0  */
	tuple2->items[0] = new PyRepString(string0);
	/*  1  */
	tuple2->items[1] = new PyRepInteger(ownerID);
	/*  2  */
	tuple2->items[2] = new PyRepInteger(itemKey);
	/*  3  */
	tuple2->items[3] = new PyRepInteger(attributeID);
	/*  4  */
	tuple2->items[4] = new PyRepInteger(time);
	/*  5  */
	tuple2->items[5] = new PyRepReal(newValue);
	/*  6  */
	PyRepList *list3 = new PyRepList();
	list3->items.resize(4, NULL);
	/*  0  */
	list3->items[0] = new PyRepReal(newValue2);
	/*  1  */
	list3->items[1] = new PyRepInteger(time2);
	/*  2  */
	list3->items[2] = new PyRepReal(real8);
	/*  3  */
	list3->items[3] = new PyRepReal(oldValue);
	tuple2->items[6] = list3;
	
	list1->items[0] = tuple2;
	
	tuple0->items[0] = list1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *OnModuleAttributeChange::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRepList *list1 = new PyRepList();
	list1->items.resize(1, NULL);
	/*  0  */
	PyRepTuple *tuple2 = new PyRepTuple(7);
	/*  0  */
	tuple2->items[0] = new PyRepString(string0);
	/*  1  */
	tuple2->items[1] = new PyRepInteger(ownerID);
	/*  2  */
	tuple2->items[2] = new PyRepInteger(itemKey);
	/*  3  */
	tuple2->items[3] = new PyRepInteger(attributeID);
	/*  4  */
	tuple2->items[4] = new PyRepInteger(time);
	/*  5  */
	tuple2->items[5] = new PyRepReal(newValue);
	/*  6  */
	PyRepList *list3 = new PyRepList();
	list3->items.resize(4, NULL);
	/*  0  */
	list3->items[0] = new PyRepReal(newValue2);
	/*  1  */
	list3->items[1] = new PyRepInteger(time2);
	/*  2  */
	list3->items[2] = new PyRepReal(real8);
	/*  3  */
	list3->items[3] = new PyRepReal(oldValue);
	tuple2->items[6] = list3;
	
	list1->items[0] = tuple2;
	
	tuple0->items[0] = list1;
	
	res = tuple0;
	

	return(res);
}

bool OnModuleAttributeChange::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool OnModuleAttributeChange::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: list1 is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list1 = (PyRepList *) tuple0->items[0];
	if(list1->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: list1 is the wrong size: expected 1, but got %d", list1->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!list1->items[0]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: tuple2 is the wrong type: %s", list1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) list1->items[0];
	if(tuple2->items.size() != 7) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: tuple2 is the wrong size: expected 7, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple2->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: string0 is not a string: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) tuple2->items[0];
	string0 = string_3->value;
	/*  1  */
	if(!tuple2->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: ownerID is not an int: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple2->items[1];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode OnModuleAttributeChange: truncating 64 bit into into 32 bit int for field ownerID");
	}
	ownerID = int_4->value;
	/*  2  */
	if(!tuple2->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: itemKey is not an int: %s", tuple2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) tuple2->items[2];
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode OnModuleAttributeChange: truncating 64 bit into into 32 bit int for field itemKey");
	}
	itemKey = int_5->value;
	/*  3  */
	if(!tuple2->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: attributeID is not an int: %s", tuple2->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_6 = (PyRepInteger *) tuple2->items[3];
	if(int_6->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode OnModuleAttributeChange: truncating 64 bit into into 32 bit int for field attributeID");
	}
	attributeID = int_6->value;
	/*  4  */
	if(!tuple2->items[4]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: time is not an int: %s", tuple2->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_7 = (PyRepInteger *) tuple2->items[4];
	time = int64_7->value;
	/*  5  */
	if(!tuple2->items[5]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: newValue is not a real: %s", tuple2->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_8 = (PyRepReal *) tuple2->items[5];
	newValue = real_8->value;
	/*  6  */
	if(!tuple2->items[6]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: list9 is not a list: %s", tuple2->items[6]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list9 = (PyRepList *) tuple2->items[6];
	if(list9->items.size() != 4) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: list9 is the wrong size: expected 4, but got %d", list9->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!list9->items[0]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: newValue2 is not a real: %s", list9->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_10 = (PyRepReal *) list9->items[0];
	newValue2 = real_10->value;
	/*  1  */
	if(!list9->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: time2 is not an int: %s", list9->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_11 = (PyRepInteger *) list9->items[1];
	time2 = int64_11->value;
	/*  2  */
	if(!list9->items[2]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: real8 is not a real: %s", list9->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_12 = (PyRepReal *) list9->items[2];
	real8 = real_12->value;
	/*  3  */
	if(!list9->items[3]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: oldValue is not a real: %s", list9->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_13 = (PyRepReal *) list9->items[3];
	oldValue = real_13->value;

	delete packet;
	return(true);
}

OnModuleAttributeChange *OnModuleAttributeChange::Clone() const {
	OnModuleAttributeChange *res = new OnModuleAttributeChange;
	res->CloneFrom(this);
	return(res);
}

void OnModuleAttributeChange::CloneFrom(const OnModuleAttributeChange *from) {
	/*  0  */
	/*  0  */
	/*  0  */
	string0 = from->string0;
	/*  1  */
	ownerID = from->ownerID;
	/*  2  */
	itemKey = from->itemKey;
	/*  3  */
	attributeID = from->attributeID;
	/*  4  */
	time = from->time;
	/*  5  */
	newValue = from->newValue;
	/*  6  */
	/*  0  */
	newValue2 = from->newValue2;
	/*  1  */
	time2 = from->time2;
	/*  2  */
	real8 = from->real8;
	/*  3  */
	oldValue = from->oldValue;
	
}


Call_GetJournal::Call_GetJournal() {
	accountKey = 0;
	fromDate = 0;
	/*  may be None (but prolly wont be)  */
	refTypeID = 0;
	/*  may be None  */
	corpAccount = NULL;
	/*  soft bool  */
	refID = NULL;
	/*  may be None  */
	rev = 0;
}

Call_GetJournal::~Call_GetJournal() {
	/*  may be None (but prolly wont be)  */
	/*  may be None  */
	delete corpAccount;
	/*  soft bool  */
	delete refID;
	/*  may be None  */
}

void Call_GetJournal::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_GetJournal", pfx);
	_log(l_type, "%saccountKey=%lu", pfx, accountKey);
	_log(l_type, "%sfromDate=" I64u, pfx, fromDate);
	/*  may be None (but prolly wont be)  */
	_log(l_type, "%srefTypeID=%lu", pfx, refTypeID);
	/*  may be None  */
	_log(l_type, "%scorpAccount:", pfx);
	std::string corpAccount_n(pfx);
	corpAccount_n += "    ";
	if(corpAccount == NULL) {
		_log(l_type, "%sERROR: NULL REP!", corpAccount_n.c_str());
	} else {
		corpAccount->Dump(l_type, corpAccount_n.c_str());
	}
	/*  soft bool  */
	_log(l_type, "%srefID:", pfx);
	std::string refID_n(pfx);
	refID_n += "    ";
	if(refID == NULL) {
		_log(l_type, "%sERROR: NULL REP!", refID_n.c_str());
	} else {
		refID->Dump(l_type, refID_n.c_str());
	}
	/*  may be None  */
	_log(l_type, "%srev=%lu", pfx, rev);
}

PyRepTuple *Call_GetJournal::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(6);
	tuple0->items[0] = new PyRepInteger(accountKey);
	if(fromDate == 0) {
		tuple0->items[1] = new PyRepNone();
	} else {
		tuple0->items[1] = new PyRepInteger(fromDate);
	}
	/*  may be None (but prolly wont be)  */
	if(refTypeID == 0) {
		tuple0->items[2] = new PyRepNone();
	} else {
		tuple0->items[2] = new PyRepInteger(refTypeID);
	}
	/*  may be None  */
	if(corpAccount == NULL) {
		_log(NET__PACKET_ERROR, "Encode Call_GetJournal: corpAccount is NULL! hacking in a PyRepNone");
		corpAccount = new PyRepNone();
	}
	tuple0->items[3] = corpAccount->Clone();
	/*  soft bool  */
	if(refID == NULL) {
		_log(NET__PACKET_ERROR, "Encode Call_GetJournal: refID is NULL! hacking in a PyRepNone");
		refID = new PyRepNone();
	}
	tuple0->items[4] = refID->Clone();
	/*  may be None  */
	tuple0->items[5] = new PyRepInteger(rev);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_GetJournal::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(6);
	tuple0->items[0] = new PyRepInteger(accountKey);
	if(fromDate == 0) {
		tuple0->items[1] = new PyRepNone();
	} else {
		tuple0->items[1] = new PyRepInteger(fromDate);
	}
	/*  may be None (but prolly wont be)  */
	if(refTypeID == 0) {
		tuple0->items[2] = new PyRepNone();
	} else {
		tuple0->items[2] = new PyRepInteger(refTypeID);
	}
	/*  may be None  */
	if(corpAccount == NULL) {
		_log(NET__PACKET_ERROR, "Encode Call_GetJournal: corpAccount is NULL! hacking in a PyRepNone");
		corpAccount = new PyRepNone();
	}
	tuple0->items[3] = corpAccount;
	corpAccount = NULL;
	/*  soft bool  */
	if(refID == NULL) {
		_log(NET__PACKET_ERROR, "Encode Call_GetJournal: refID is NULL! hacking in a PyRepNone");
		refID = new PyRepNone();
	}
	tuple0->items[4] = refID;
	refID = NULL;
	/*  may be None  */
	tuple0->items[5] = new PyRepInteger(rev);
	res = tuple0;
	

	return(res);
}

bool Call_GetJournal::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_GetJournal::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetJournal failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 6) {
		_log(NET__PACKET_ERROR, "Decode Call_GetJournal failed: tuple0 is the wrong size: expected 6, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetJournal failed: accountKey is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_GetJournal: truncating 64 bit into into 32 bit int for field accountKey");
	}
	accountKey = int_1->value;
	if(tuple0->items[1]->CheckType(PyRep::None)) {
		fromDate = 0;
	} else {
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetJournal failed: fromDate is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_2 = (PyRepInteger *) tuple0->items[1];
	fromDate = int64_2->value;
	}
	/*  may be None (but prolly wont be)  */
	if(tuple0->items[2]->CheckType(PyRep::None)) {
		refTypeID = 0;
	} else {
	if(!tuple0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetJournal failed: refTypeID is not an int: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple0->items[2];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_GetJournal: truncating 64 bit into into 32 bit int for field refTypeID");
	}
	refTypeID = int_3->value;
	}
	/*  may be None  */
	delete corpAccount;
	corpAccount = tuple0->items[3];
	tuple0->items[3] = NULL;
	
	/*  soft bool  */
	delete refID;
	refID = tuple0->items[4];
	tuple0->items[4] = NULL;
	
	/*  may be None  */
	if(!tuple0->items[5]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetJournal failed: rev is not an int: %s", tuple0->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple0->items[5];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_GetJournal: truncating 64 bit into into 32 bit int for field rev");
	}
	rev = int_4->value;

	delete packet;
	return(true);
}

Call_GetJournal *Call_GetJournal::Clone() const {
	Call_GetJournal *res = new Call_GetJournal;
	res->CloneFrom(this);
	return(res);
}

void Call_GetJournal::CloneFrom(const Call_GetJournal *from) {
	accountKey = from->accountKey;
	fromDate = from->fromDate;
	/*  may be None (but prolly wont be)  */
	refTypeID = from->refTypeID;
	/*  may be None  */
	delete corpAccount;
	if(from->corpAccount == NULL) {
		corpAccount = NULL;
	} else {
		corpAccount = from->corpAccount->Clone();
	}
	/*  soft bool  */
	delete refID;
	if(from->refID == NULL) {
		refID = NULL;
	} else {
		refID = from->refID->Clone();
	}
	/*  may be None  */
	rev = from->rev;
	
}


Call_AssembleShip::Call_AssembleShip() {
}

Call_AssembleShip::~Call_AssembleShip() {
}

void Call_AssembleShip::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_AssembleShip", pfx);
	_log(l_type, "%sitems: Integer list with %d enetires", pfx, items.size());
	std::vector<uint32>::const_iterator items_cur, items_end;
	items_cur = items.begin();
	items_end = items.end();
	int items_index;
	for(items_index = 0; items_cur != items_end; items_cur++, items_index++) {
		_log(l_type, "%s   [%02d] %d", pfx, items_index, *items_cur);
	}
	
}

PyRepTuple *Call_AssembleShip::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator items_cur, items_end;
	items_cur = items.begin();
	items_end = items.end();
	for(; items_cur != items_end; items_cur++) {
		list1->items.push_back(
			new PyRepInteger(*items_cur)
		);
	}
	tuple0->items[0] = list1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_AssembleShip::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator items_cur, items_end;
	items_cur = items.begin();
	items_end = items.end();
	for(; items_cur != items_end; items_cur++) {
		list1->items.push_back(
			new PyRepInteger(*items_cur)
		);
	}
	tuple0->items[0] = list1;
	
	res = tuple0;
	

	return(res);
}

bool Call_AssembleShip::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_AssembleShip::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_AssembleShip failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode Call_AssembleShip failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Call_AssembleShip failed: items is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	items.clear();
	PyRepList *list_1 = (PyRepList *) tuple0->items[0];
	PyRepList::iterator items_cur, items_end;
	items_cur = list_1->items.begin();
	items_end = list_1->items.end();
	int items_index;
	for(items_index = 0; items_cur != items_end; items_cur++, items_index++) {
		if(!(*items_cur)->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode Call_AssembleShip failed: Element %d in list items is not an integer: %s", items_index, (*items_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *t = (PyRepInteger *) (*items_cur);
		if(t->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode Call_AssembleShip: truncating 64 bit into into 32 bit int for item %d in field items", items_index);
		}
		items.push_back(t->value);
	}


	delete packet;
	return(true);
}

Call_AssembleShip *Call_AssembleShip::Clone() const {
	Call_AssembleShip *res = new Call_AssembleShip;
	res->CloneFrom(this);
	return(res);
}

void Call_AssembleShip::CloneFrom(const Call_AssembleShip *from) {
	items = from->items;
	
}


EntityEffectState::EntityEffectState() {
	/*  the first 7 fields are the standard effect `environment`
         fields indexed by ENV_IDX_*, see OnGodmaShipEffect  */
	/*  Begin Environment  */
	env_itemID = 0;
	env_charID = 0;
	env_shipID = 0;
	env_target = 0;
	/*  optional  */
	env_other = 0;
	/*  optional (not positive that this is an int)  */
	/*  not sure what data goes in here.  */
	env_effectID = 0;
	/*  End Environment  */
	startTime = 0;
	duration = 0;
	/*  saw 0x7 placeholder  */
	repeat = 0;
	/*  saw 0  */
	/*  randomSeed  */
}

EntityEffectState::~EntityEffectState() {
	/*  the first 7 fields are the standard effect `environment`
         fields indexed by ENV_IDX_*, see OnGodmaShipEffect  */
	/*  Begin Environment  */
	/*  optional  */
	/*  optional (not positive that this is an int)  */
	/*  not sure what data goes in here.  */
	/*  End Environment  */
	/*  saw 0x7 placeholder  */
	/*  saw 0  */
	/*  randomSeed  */
}

void EntityEffectState::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sEntityEffectState", pfx);
	/*  the first 7 fields are the standard effect `environment`
         fields indexed by ENV_IDX_*, see OnGodmaShipEffect  */
	/*  Begin Environment  */
	_log(l_type, "%senv_itemID=%lu", pfx, env_itemID);
	_log(l_type, "%senv_charID=%lu", pfx, env_charID);
	_log(l_type, "%senv_shipID=%lu", pfx, env_shipID);
	_log(l_type, "%senv_target=%lu", pfx, env_target);
	/*  optional  */
	_log(l_type, "%senv_other=%lu", pfx, env_other);
	/*  optional (not positive that this is an int)  */
	_log(l_type, "%senv_area: ", pfx);
	std::string env_area_n(pfx);
	env_area_n += "    ";
	env_area.Dump(l_type, env_area_n.c_str());
	/*  not sure what data goes in here.  */
	_log(l_type, "%senv_effectID=%lu", pfx, env_effectID);
	/*  End Environment  */
	_log(l_type, "%sstartTime=" I64u, pfx, startTime);
	_log(l_type, "%sduration=%lu", pfx, duration);
	/*  saw 0x7 placeholder  */
	_log(l_type, "%srepeat=%lu", pfx, repeat);
	/*  saw 0  */
	/*  randomSeed  */
}

PyRepList *EntityEffectState::Encode() {
	PyRepList *res = NULL;
	PyRepList *list0 = new PyRepList();
	list0->items.resize(11, NULL);
	/*  the first 7 fields are the standard effect `environment`
         fields indexed by ENV_IDX_*, see OnGodmaShipEffect  */
	/*  Begin Environment  */
	list0->items[0] = new PyRepInteger(env_itemID);
	list0->items[1] = new PyRepInteger(env_charID);
	list0->items[2] = new PyRepInteger(env_shipID);
	if(env_target == 0) {
		list0->items[3] = new PyRepNone();
	} else {
		list0->items[3] = new PyRepInteger(env_target);
	}
	/*  optional  */
	if(env_other == 0) {
		list0->items[4] = new PyRepNone();
	} else {
		list0->items[4] = new PyRepInteger(env_other);
	}
	/*  optional (not positive that this is an int)  */
	list0->items[5] = env_area.Clone();
	/*  not sure what data goes in here.  */
	list0->items[6] = new PyRepInteger(env_effectID);
	/*  End Environment  */
	list0->items[7] = new PyRepInteger(startTime);
	list0->items[8] = new PyRepInteger(duration);
	/*  saw 0x7 placeholder  */
	list0->items[9] = new PyRepInteger(repeat);
	/*  saw 0  */
	list0->items[10] = new PyRepNone();
	/*  randomSeed  */
	res = list0;
	

	return(res);
}

PyRepList *EntityEffectState::FastEncode() {
	PyRepList *res = NULL;
	PyRepList *list0 = new PyRepList();
	list0->items.resize(11, NULL);
	/*  the first 7 fields are the standard effect `environment`
         fields indexed by ENV_IDX_*, see OnGodmaShipEffect  */
	/*  Begin Environment  */
	list0->items[0] = new PyRepInteger(env_itemID);
	list0->items[1] = new PyRepInteger(env_charID);
	list0->items[2] = new PyRepInteger(env_shipID);
	if(env_target == 0) {
		list0->items[3] = new PyRepNone();
	} else {
		list0->items[3] = new PyRepInteger(env_target);
	}
	/*  optional  */
	if(env_other == 0) {
		list0->items[4] = new PyRepNone();
	} else {
		list0->items[4] = new PyRepInteger(env_other);
	}
	/*  optional (not positive that this is an int)  */
	
	PyRepList *list1 = new PyRepList();
	list1->items = env_area.items;
	env_area.items.clear();
	list0->items[5] = list1;
	/*  not sure what data goes in here.  */
	list0->items[6] = new PyRepInteger(env_effectID);
	/*  End Environment  */
	list0->items[7] = new PyRepInteger(startTime);
	list0->items[8] = new PyRepInteger(duration);
	/*  saw 0x7 placeholder  */
	list0->items[9] = new PyRepInteger(repeat);
	/*  saw 0  */
	list0->items[10] = new PyRepNone();
	/*  randomSeed  */
	res = list0;
	

	return(res);
}

bool EntityEffectState::Decode(PyRepList **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool EntityEffectState::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode EntityEffectState failed: list0 is not a list: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list0 = (PyRepList *) packet;
	if(list0->items.size() != 11) {
		_log(NET__PACKET_ERROR, "Decode EntityEffectState failed: list0 is the wrong size: expected 11, but got %d", list0->items.size());
		delete packet;
		return(false);
	}

	/*  the first 7 fields are the standard effect `environment`
         fields indexed by ENV_IDX_*, see OnGodmaShipEffect  */
	/*  Begin Environment  */
	if(!list0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityEffectState failed: env_itemID is not an int: %s", list0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) list0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityEffectState: truncating 64 bit into into 32 bit int for field env_itemID");
	}
	env_itemID = int_1->value;
	if(!list0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityEffectState failed: env_charID is not an int: %s", list0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) list0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityEffectState: truncating 64 bit into into 32 bit int for field env_charID");
	}
	env_charID = int_2->value;
	if(!list0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityEffectState failed: env_shipID is not an int: %s", list0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) list0->items[2];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityEffectState: truncating 64 bit into into 32 bit int for field env_shipID");
	}
	env_shipID = int_3->value;
	if(list0->items[3]->CheckType(PyRep::None)) {
		env_target = 0;
	} else {
	if(!list0->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityEffectState failed: env_target is not an int: %s", list0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) list0->items[3];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityEffectState: truncating 64 bit into into 32 bit int for field env_target");
	}
	env_target = int_4->value;
	}
	/*  optional  */
	if(list0->items[4]->CheckType(PyRep::None)) {
		env_other = 0;
	} else {
	if(!list0->items[4]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityEffectState failed: env_other is not an int: %s", list0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) list0->items[4];
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityEffectState: truncating 64 bit into into 32 bit int for field env_other");
	}
	env_other = int_5->value;
	}
	/*  optional (not positive that this is an int)  */
	if(!list0->items[5]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode EntityEffectState failed: env_area is not a list: %s", list0->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_env_area = (PyRepList *) list0->items[5];	env_area.items = list_env_area->items;
	list_env_area->items.clear();
	
	/*  not sure what data goes in here.  */
	if(!list0->items[6]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityEffectState failed: env_effectID is not an int: %s", list0->items[6]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_6 = (PyRepInteger *) list0->items[6];
	if(int_6->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityEffectState: truncating 64 bit into into 32 bit int for field env_effectID");
	}
	env_effectID = int_6->value;
	/*  End Environment  */
	if(!list0->items[7]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityEffectState failed: startTime is not an int: %s", list0->items[7]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_7 = (PyRepInteger *) list0->items[7];
	startTime = int64_7->value;
	if(!list0->items[8]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityEffectState failed: duration is not an int: %s", list0->items[8]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_8 = (PyRepInteger *) list0->items[8];
	if(int_8->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityEffectState: truncating 64 bit into into 32 bit int for field duration");
	}
	duration = int_8->value;
	/*  saw 0x7 placeholder  */
	if(!list0->items[9]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityEffectState failed: repeat is not an int: %s", list0->items[9]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_9 = (PyRepInteger *) list0->items[9];
	if(int_9->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityEffectState: truncating 64 bit into into 32 bit int for field repeat");
	}
	repeat = int_9->value;
	/*  saw 0  */
	if(!list0->items[10]->CheckType(PyRep::None)) {
		_log(NET__PACKET_ERROR, "Decode EntityEffectState failed: expecting a None but got a %s", list0->items[10]->TypeString());
		delete packet;
		return(false);
	}
	
	/*  randomSeed  */

	delete packet;
	return(true);
}

EntityEffectState *EntityEffectState::Clone() const {
	EntityEffectState *res = new EntityEffectState;
	res->CloneFrom(this);
	return(res);
}

void EntityEffectState::CloneFrom(const EntityEffectState *from) {
	/*  the first 7 fields are the standard effect `environment`
         fields indexed by ENV_IDX_*, see OnGodmaShipEffect  */
	/*  Begin Environment  */
	env_itemID = from->env_itemID;
	env_charID = from->env_charID;
	env_shipID = from->env_shipID;
	env_target = from->env_target;
	/*  optional  */
	env_other = from->env_other;
	/*  optional (not positive that this is an int)  */
	env_area.CloneFrom(&from->env_area);
	/*  not sure what data goes in here.  */
	env_effectID = from->env_effectID;
	/*  End Environment  */
	startTime = from->startTime;
	duration = from->duration;
	/*  saw 0x7 placeholder  */
	repeat = from->repeat;
	/*  saw 0  */
	/*  randomSeed  */
	
}


Rsp_CommonGetInfo_Entry::Rsp_CommonGetInfo_Entry() {
	itemID = 0;
	/*  this is an EntityRowObject  */
	invItem = NULL;
	/*  this maps effectType to EntityEffectState  */
	/*  maps attribute ID to it's value, which may be int or real  */
	time = 0;
}

Rsp_CommonGetInfo_Entry::~Rsp_CommonGetInfo_Entry() {
	/*  this is an EntityRowObject  */
	delete invItem;
	/*  this maps effectType to EntityEffectState  */
	std::map<uint32, PyRep *>::iterator activeEffects_cur, activeEffects_end;
	//free any existing elements first
	activeEffects_cur = activeEffects.begin();
	activeEffects_end = activeEffects.end();
	for(; activeEffects_cur != activeEffects_end; activeEffects_cur++) {
		delete activeEffects_cur->second;
	}
	
	/*  maps attribute ID to it's value, which may be int or real  */
	std::map<uint32, PyRep *>::iterator attributes_cur, attributes_end;
	//free any existing elements first
	attributes_cur = attributes.begin();
	attributes_end = attributes.end();
	for(; attributes_cur != attributes_end; attributes_cur++) {
		delete attributes_cur->second;
	}
	
}

void Rsp_CommonGetInfo_Entry::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRsp_CommonGetInfo_Entry", pfx);
	_log(l_type, "%sitemID=%lu", pfx, itemID);
	/*  this is an EntityRowObject  */
	_log(l_type, "%sinvItem:", pfx);
	std::string invItem_n(pfx);
	invItem_n += "    ";
	if(invItem == NULL) {
		_log(l_type, "%sERROR: NULL REP!", invItem_n.c_str());
	} else {
		invItem->Dump(l_type, invItem_n.c_str());
	}
	/*  this maps effectType to EntityEffectState  */
	_log(l_type, "%sactiveEffects: Dictionaty with %d enetires", pfx, activeEffects.size());
	std::map<uint32, PyRep *>::const_iterator activeEffects_cur, activeEffects_end;
	activeEffects_cur = activeEffects.begin();
	activeEffects_end = activeEffects.end();
	for(; activeEffects_cur != activeEffects_end; activeEffects_cur++) {
		_log(l_type, "%s   Key: %lu", pfx, activeEffects_cur->first);
		std::string n(pfx);
		n += "        ";
		activeEffects_cur->second->Dump(stdout, n.c_str());
	}
	
	/*  maps attribute ID to it's value, which may be int or real  */
	_log(l_type, "%sattributes: Dictionaty with %d enetires", pfx, attributes.size());
	std::map<uint32, PyRep *>::const_iterator attributes_cur, attributes_end;
	attributes_cur = attributes.begin();
	attributes_end = attributes.end();
	for(; attributes_cur != attributes_end; attributes_cur++) {
		_log(l_type, "%s   Key: %lu", pfx, attributes_cur->first);
		std::string n(pfx);
		n += "        ";
		attributes_cur->second->Dump(stdout, n.c_str());
	}
	
	_log(l_type, "%stime=" I64u, pfx, time);
}

PyRepList *Rsp_CommonGetInfo_Entry::Encode() {
	PyRepList *res = NULL;
	PyRepList *list0 = new PyRepList();
	list0->items.resize(5, NULL);
	list0->items[0] = new PyRepInteger(itemID);
	/*  this is an EntityRowObject  */
	if(invItem == NULL) {
		_log(NET__PACKET_ERROR, "Encode Rsp_CommonGetInfo_Entry: invItem is NULL! hacking in a PyRepNone");
		invItem = new PyRepNone();
	}
	list0->items[1] = invItem->Clone();
	/*  this maps effectType to EntityEffectState  */
	
	PyRepDict *dict1 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator activeEffects_cur, activeEffects_end;
	activeEffects_cur = activeEffects.begin();
	activeEffects_end = activeEffects.end();
	for(; activeEffects_cur != activeEffects_end; activeEffects_cur++) {
		dict1->items[
			new PyRepInteger(activeEffects_cur->first)
		] = activeEffects_cur->second->Clone();
	}
	list0->items[2] = dict1;
	
	/*  maps attribute ID to it's value, which may be int or real  */
	
	PyRepDict *dict2 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator attributes_cur, attributes_end;
	attributes_cur = attributes.begin();
	attributes_end = attributes.end();
	for(; attributes_cur != attributes_end; attributes_cur++) {
		dict2->items[
			new PyRepInteger(attributes_cur->first)
		] = attributes_cur->second->Clone();
	}
	list0->items[3] = dict2;
	
	list0->items[4] = new PyRepInteger(time);
	res = list0;
	

	return(res);
}

PyRepList *Rsp_CommonGetInfo_Entry::FastEncode() {
	PyRepList *res = NULL;
	PyRepList *list0 = new PyRepList();
	list0->items.resize(5, NULL);
	list0->items[0] = new PyRepInteger(itemID);
	/*  this is an EntityRowObject  */
	if(invItem == NULL) {
		_log(NET__PACKET_ERROR, "Encode Rsp_CommonGetInfo_Entry: invItem is NULL! hacking in a PyRepNone");
		invItem = new PyRepNone();
	}
	list0->items[1] = invItem;
	invItem = NULL;
	/*  this maps effectType to EntityEffectState  */
	
	PyRepDict *dict1 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator activeEffects_cur, activeEffects_end;
	activeEffects_cur = activeEffects.begin();
	activeEffects_end = activeEffects.end();
	for(; activeEffects_cur != activeEffects_end; activeEffects_cur++) {
		dict1->items[
			new PyRepInteger(activeEffects_cur->first)
		] = activeEffects_cur->second;
	}
	activeEffects.clear();
	list0->items[2] = dict1;
	
	/*  maps attribute ID to it's value, which may be int or real  */
	
	PyRepDict *dict2 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator attributes_cur, attributes_end;
	attributes_cur = attributes.begin();
	attributes_end = attributes.end();
	for(; attributes_cur != attributes_end; attributes_cur++) {
		dict2->items[
			new PyRepInteger(attributes_cur->first)
		] = attributes_cur->second;
	}
	attributes.clear();
	list0->items[3] = dict2;
	
	list0->items[4] = new PyRepInteger(time);
	res = list0;
	

	return(res);
}

bool Rsp_CommonGetInfo_Entry::Decode(PyRepList **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Rsp_CommonGetInfo_Entry::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo_Entry failed: list0 is not a list: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list0 = (PyRepList *) packet;
	if(list0->items.size() != 5) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo_Entry failed: list0 is the wrong size: expected 5, but got %d", list0->items.size());
		delete packet;
		return(false);
	}

	if(!list0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo_Entry failed: itemID is not an int: %s", list0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) list0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_CommonGetInfo_Entry: truncating 64 bit into into 32 bit int for field itemID");
	}
	itemID = int_1->value;
	/*  this is an EntityRowObject  */
	delete invItem;
	invItem = list0->items[1];
	list0->items[1] = NULL;
	
	/*  this maps effectType to EntityEffectState  */
	if(!list0->items[2]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo_Entry failed: activeEffects is not a dict: %s", list0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	activeEffects.clear();
	PyRepDict *dict_2 = (PyRepDict *) list0->items[2];
	PyRepDict::iterator activeEffects_cur, activeEffects_end;
	activeEffects_cur = dict_2->items.begin();
	activeEffects_end = dict_2->items.end();
	int activeEffects_index;
	for(activeEffects_index = 0; activeEffects_cur != activeEffects_end; activeEffects_cur++, activeEffects_index++) {
		if(!activeEffects_cur->first->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo_Entry failed: Key %d in dict activeEffects is not an integer: %s", activeEffects_index, activeEffects_cur->first->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *k = (PyRepInteger *) activeEffects_cur->first;
		if(k->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode Rsp_CommonGetInfo_Entry: truncating 64 bit into into 32 bit int in key of entry %d in field activeEffects", activeEffects_index);
		}
		activeEffects[k->value] = activeEffects_cur->second->Clone();
	}
	
	/*  maps attribute ID to it's value, which may be int or real  */
	if(!list0->items[3]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo_Entry failed: attributes is not a dict: %s", list0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	attributes.clear();
	PyRepDict *dict_3 = (PyRepDict *) list0->items[3];
	PyRepDict::iterator attributes_cur, attributes_end;
	attributes_cur = dict_3->items.begin();
	attributes_end = dict_3->items.end();
	int attributes_index;
	for(attributes_index = 0; attributes_cur != attributes_end; attributes_cur++, attributes_index++) {
		if(!attributes_cur->first->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo_Entry failed: Key %d in dict attributes is not an integer: %s", attributes_index, attributes_cur->first->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *k = (PyRepInteger *) attributes_cur->first;
		if(k->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode Rsp_CommonGetInfo_Entry: truncating 64 bit into into 32 bit int in key of entry %d in field attributes", attributes_index);
		}
		attributes[k->value] = attributes_cur->second->Clone();
	}
	
	if(!list0->items[4]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo_Entry failed: time is not an int: %s", list0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_4 = (PyRepInteger *) list0->items[4];
	time = int64_4->value;

	delete packet;
	return(true);
}

Rsp_CommonGetInfo_Entry *Rsp_CommonGetInfo_Entry::Clone() const {
	Rsp_CommonGetInfo_Entry *res = new Rsp_CommonGetInfo_Entry;
	res->CloneFrom(this);
	return(res);
}

void Rsp_CommonGetInfo_Entry::CloneFrom(const Rsp_CommonGetInfo_Entry *from) {
	itemID = from->itemID;
	/*  this is an EntityRowObject  */
	delete invItem;
	if(from->invItem == NULL) {
		invItem = NULL;
	} else {
		invItem = from->invItem->Clone();
	}
	/*  this maps effectType to EntityEffectState  */
	std::map<uint32, PyRep *>::const_iterator activeEffects_cur, activeEffects_end;
	//free any existing elements first
	activeEffects_cur = activeEffects.begin();
	activeEffects_end = activeEffects.end();
	for(; activeEffects_cur != activeEffects_end; activeEffects_cur++) {
		delete activeEffects_cur->second;
	}
	activeEffects.clear();
	//now we can copy in the new ones...
	activeEffects_cur = from->activeEffects.begin();
	activeEffects_end = from->activeEffects.end();
	for(; activeEffects_cur != activeEffects_end; activeEffects_cur++) {
		activeEffects[activeEffects_cur->first] = activeEffects_cur->second->Clone();
	}
	
	/*  maps attribute ID to it's value, which may be int or real  */
	std::map<uint32, PyRep *>::const_iterator attributes_cur, attributes_end;
	//free any existing elements first
	attributes_cur = attributes.begin();
	attributes_end = attributes.end();
	for(; attributes_cur != attributes_end; attributes_cur++) {
		delete attributes_cur->second;
	}
	attributes.clear();
	//now we can copy in the new ones...
	attributes_cur = from->attributes.begin();
	attributes_end = from->attributes.end();
	for(; attributes_cur != attributes_end; attributes_cur++) {
		attributes[attributes_cur->first] = attributes_cur->second->Clone();
	}
	
	time = from->time;
	
}


Rsp_ItemGetInfo::Rsp_ItemGetInfo() {
	/* object of type util.Row */
	head_itemID = "itemID";
	head_invItem = "invItem";
	head_activeEffects = "activeEffects";
	head_attributes = "attributes";
	head_time = "time";
}

Rsp_ItemGetInfo::~Rsp_ItemGetInfo() {
}

void Rsp_ItemGetInfo::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRsp_ItemGetInfo", pfx);
	_log(l_type, "%sObject of type util.Row:", pfx);
	_log(l_type, "%shead_itemID='%s'", pfx, head_itemID.c_str());
	_log(l_type, "%shead_invItem='%s'", pfx, head_invItem.c_str());
	_log(l_type, "%shead_activeEffects='%s'", pfx, head_activeEffects.c_str());
	_log(l_type, "%shead_attributes='%s'", pfx, head_attributes.c_str());
	_log(l_type, "%shead_time='%s'", pfx, head_time.c_str());
	_log(l_type, "%sentry:", pfx);
	std::string entry_n(pfx);
	entry_n += "    ";
	entry.Dump(l_type, entry_n.c_str());
}

PyRepObject *Rsp_ItemGetInfo::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepList *list2 = new PyRepList();
	list2->items.resize(5, NULL);
	list2->items[0] = new PyRepString(head_itemID);
	list2->items[1] = new PyRepString(head_invItem);
	list2->items[2] = new PyRepString(head_activeEffects);
	list2->items[3] = new PyRepString(head_attributes);
	list2->items[4] = new PyRepString(head_time);
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
		dict1_1 = entry.Encode();
	dict1->items[
		new PyRepString("line")
	] = dict1_1;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.Row",
			args0
		);
	

	return(res);
}

PyRepObject *Rsp_ItemGetInfo::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepList *list2 = new PyRepList();
	list2->items.resize(5, NULL);
	list2->items[0] = new PyRepString(head_itemID);
	list2->items[1] = new PyRepString(head_invItem);
	list2->items[2] = new PyRepString(head_activeEffects);
	list2->items[3] = new PyRepString(head_attributes);
	list2->items[4] = new PyRepString(head_time);
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
		dict1_1 = entry.FastEncode();
	dict1->items[
		new PyRepString("line")
	] = dict1_1;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.Row",
			args0
		);
	

	return(res);
}

bool Rsp_ItemGetInfo::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Rsp_ItemGetInfo::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "util.Row") {
		_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: obj_0 is the wrong object type. Expected 'util.Row', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: dict1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict1_header = false;
	bool dict1_entry = false;
	PyRepDict *dict1 = (PyRepDict *) obj_0->arguments;
	
	PyRepDict::iterator dict1_cur, dict1_end;
	dict1_cur = dict1->items.begin();
	dict1_end = dict1->items.end();
	for(; dict1_cur != dict1_end; dict1_cur++) {
		PyRep *key__ = dict1_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: a key in dict1 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "header") {
			dict1_header = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: list2 is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list2 = (PyRepList *) dict1_cur->second;
	if(list2->items.size() != 5) {
		_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: list2 is the wrong size: expected 5, but got %d", list2->items.size());
		delete packet;
		return(false);
	}

	if(!list2->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: head_itemID is not a string: %s", list2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) list2->items[0];
	head_itemID = string_3->value;
	if(!list2->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: head_invItem is not a string: %s", list2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_4 = (PyRepString *) list2->items[1];
	head_invItem = string_4->value;
	if(!list2->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: head_activeEffects is not a string: %s", list2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_5 = (PyRepString *) list2->items[2];
	head_activeEffects = string_5->value;
	if(!list2->items[3]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: head_attributes is not a string: %s", list2->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_6 = (PyRepString *) list2->items[3];
	head_attributes = string_6->value;
	if(!list2->items[4]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: head_time is not a string: %s", list2->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_7 = (PyRepString *) list2->items[4];
	head_time = string_7->value;
		} else
		if(key_string__->value == "line") {
			dict1_entry = true;
	PyRep *rep_8 = dict1_cur->second;
	dict1_cur->second = NULL;
	if(!entry.Decode(&rep_8)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: unable to decode element entry");
		delete packet;
		return(false);
	}
	
		} else
		{
			_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: Unknown key string '%s' in dict1", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict1_header) {
		_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: Missing dict entry for 'header' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_entry) {
		_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: Missing dict entry for 'entry' in dict1");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

Rsp_ItemGetInfo *Rsp_ItemGetInfo::Clone() const {
	Rsp_ItemGetInfo *res = new Rsp_ItemGetInfo;
	res->CloneFrom(this);
	return(res);
}

void Rsp_ItemGetInfo::CloneFrom(const Rsp_ItemGetInfo *from) {
	/* object of type util.Row */
	head_itemID = from->head_itemID;
	head_invItem = from->head_invItem;
	head_activeEffects = from->head_activeEffects;
	head_attributes = from->head_attributes;
	head_time = from->head_time;
	entry.CloneFrom(&from->entry);
	
}


Rsp_CommonGetInfo::Rsp_CommonGetInfo() {
	/* object of type util.IndexRowset */
	head_itemID = "itemID";
	head_invItem = "invItem";
	head_activeEffects = "activeEffects";
	head_attributes = "attributes";
	head_time = "time";
	rowclass = "util.Row";
	idName = "itemID";
	/*  For ShipGetInfo: contains a single Rsp_CommonGetInfo_Entry for the ship  */
	/*  For CharGetInfo: contains an Rsp_CommonGetInfo_Entry for the char and each of their skills (and implants?)  */
}

Rsp_CommonGetInfo::~Rsp_CommonGetInfo() {
	/*  For ShipGetInfo: contains a single Rsp_CommonGetInfo_Entry for the ship  */
	/*  For CharGetInfo: contains an Rsp_CommonGetInfo_Entry for the char and each of their skills (and implants?)  */
	std::map<uint32, PyRep *>::iterator items_cur, items_end;
	//free any existing elements first
	items_cur = items.begin();
	items_end = items.end();
	for(; items_cur != items_end; items_cur++) {
		delete items_cur->second;
	}
	
}

void Rsp_CommonGetInfo::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRsp_CommonGetInfo", pfx);
	_log(l_type, "%sObject of type util.IndexRowset:", pfx);
	_log(l_type, "%shead_itemID='%s'", pfx, head_itemID.c_str());
	_log(l_type, "%shead_invItem='%s'", pfx, head_invItem.c_str());
	_log(l_type, "%shead_activeEffects='%s'", pfx, head_activeEffects.c_str());
	_log(l_type, "%shead_attributes='%s'", pfx, head_attributes.c_str());
	_log(l_type, "%shead_time='%s'", pfx, head_time.c_str());
	_log(l_type, "%srowclass='%s'", pfx, rowclass.c_str());
	_log(l_type, "%sidName='%s'", pfx, idName.c_str());
	/*  For ShipGetInfo: contains a single Rsp_CommonGetInfo_Entry for the ship  */
	/*  For CharGetInfo: contains an Rsp_CommonGetInfo_Entry for the char and each of their skills (and implants?)  */
	_log(l_type, "%sitems: Dictionaty with %d enetires", pfx, items.size());
	std::map<uint32, PyRep *>::const_iterator items_cur, items_end;
	items_cur = items.begin();
	items_end = items.end();
	for(; items_cur != items_end; items_cur++) {
		_log(l_type, "%s   Key: %lu", pfx, items_cur->first);
		std::string n(pfx);
		n += "        ";
		items_cur->second->Dump(stdout, n.c_str());
	}
	
}

PyRepObject *Rsp_CommonGetInfo::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepList *list2 = new PyRepList();
	list2->items.resize(5, NULL);
	list2->items[0] = new PyRepString(head_itemID);
	list2->items[1] = new PyRepString(head_invItem);
	list2->items[2] = new PyRepString(head_activeEffects);
	list2->items[3] = new PyRepString(head_attributes);
	list2->items[4] = new PyRepString(head_time);
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepString(rowclass, true);
	dict1->items[
		new PyRepString("RowClass")
	] = dict1_1;
	PyRep *dict1_2;
	dict1_2 = new PyRepString(idName);
	dict1->items[
		new PyRepString("idName")
	] = dict1_2;
	PyRep *dict1_3;
	/*  For ShipGetInfo: contains a single Rsp_CommonGetInfo_Entry for the ship  */
	/*  For CharGetInfo: contains an Rsp_CommonGetInfo_Entry for the char and each of their skills (and implants?)  */
	
	PyRepDict *dict3 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator items_cur, items_end;
	items_cur = items.begin();
	items_end = items.end();
	for(; items_cur != items_end; items_cur++) {
		dict3->items[
			new PyRepInteger(items_cur->first)
		] = items_cur->second->Clone();
	}
	dict1_3 = dict3;
	
	dict1->items[
		new PyRepString("items")
	] = dict1_3;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.IndexRowset",
			args0
		);
	

	return(res);
}

PyRepObject *Rsp_CommonGetInfo::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepList *list2 = new PyRepList();
	list2->items.resize(5, NULL);
	list2->items[0] = new PyRepString(head_itemID);
	list2->items[1] = new PyRepString(head_invItem);
	list2->items[2] = new PyRepString(head_activeEffects);
	list2->items[3] = new PyRepString(head_attributes);
	list2->items[4] = new PyRepString(head_time);
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepString(rowclass, true);
	dict1->items[
		new PyRepString("RowClass")
	] = dict1_1;
	PyRep *dict1_2;
	dict1_2 = new PyRepString(idName);
	dict1->items[
		new PyRepString("idName")
	] = dict1_2;
	PyRep *dict1_3;
	/*  For ShipGetInfo: contains a single Rsp_CommonGetInfo_Entry for the ship  */
	/*  For CharGetInfo: contains an Rsp_CommonGetInfo_Entry for the char and each of their skills (and implants?)  */
	
	PyRepDict *dict3 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator items_cur, items_end;
	items_cur = items.begin();
	items_end = items.end();
	for(; items_cur != items_end; items_cur++) {
		dict3->items[
			new PyRepInteger(items_cur->first)
		] = items_cur->second;
	}
	items.clear();
	dict1_3 = dict3;
	
	dict1->items[
		new PyRepString("items")
	] = dict1_3;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.IndexRowset",
			args0
		);
	

	return(res);
}

bool Rsp_CommonGetInfo::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Rsp_CommonGetInfo::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "util.IndexRowset") {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: obj_0 is the wrong object type. Expected 'util.IndexRowset', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: dict1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict1_header = false;
	bool dict1_rowclass = false;
	bool dict1_idName = false;
	bool dict1_items = false;
	PyRepDict *dict1 = (PyRepDict *) obj_0->arguments;
	
	PyRepDict::iterator dict1_cur, dict1_end;
	dict1_cur = dict1->items.begin();
	dict1_end = dict1->items.end();
	for(; dict1_cur != dict1_end; dict1_cur++) {
		PyRep *key__ = dict1_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: a key in dict1 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "header") {
			dict1_header = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: list2 is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list2 = (PyRepList *) dict1_cur->second;
	if(list2->items.size() != 5) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: list2 is the wrong size: expected 5, but got %d", list2->items.size());
		delete packet;
		return(false);
	}

	if(!list2->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: head_itemID is not a string: %s", list2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) list2->items[0];
	head_itemID = string_3->value;
	if(!list2->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: head_invItem is not a string: %s", list2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_4 = (PyRepString *) list2->items[1];
	head_invItem = string_4->value;
	if(!list2->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: head_activeEffects is not a string: %s", list2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_5 = (PyRepString *) list2->items[2];
	head_activeEffects = string_5->value;
	if(!list2->items[3]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: head_attributes is not a string: %s", list2->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_6 = (PyRepString *) list2->items[3];
	head_attributes = string_6->value;
	if(!list2->items[4]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: head_time is not a string: %s", list2->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_7 = (PyRepString *) list2->items[4];
	head_time = string_7->value;
		} else
		if(key_string__->value == "RowClass") {
			dict1_rowclass = true;
	if(!dict1_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: rowclass is not a string: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_8 = (PyRepString *) dict1_cur->second;
	rowclass = string_8->value;
	if(string_8->is_type_1 != true) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo: String type mismatch on rowclass: expected %d got %d. Continuing anyhow.", true, string_8->is_type_1);
	}
		} else
		if(key_string__->value == "idName") {
			dict1_idName = true;
	if(!dict1_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: idName is not a string: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_9 = (PyRepString *) dict1_cur->second;
	idName = string_9->value;
		} else
		if(key_string__->value == "items") {
			dict1_items = true;
	/*  For ShipGetInfo: contains a single Rsp_CommonGetInfo_Entry for the ship  */
	/*  For CharGetInfo: contains an Rsp_CommonGetInfo_Entry for the char and each of their skills (and implants?)  */
	if(!dict1_cur->second->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: items is not a dict: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	items.clear();
	PyRepDict *dict_10 = (PyRepDict *) dict1_cur->second;
	PyRepDict::iterator items_cur, items_end;
	items_cur = dict_10->items.begin();
	items_end = dict_10->items.end();
	int items_index;
	for(items_index = 0; items_cur != items_end; items_cur++, items_index++) {
		if(!items_cur->first->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: Key %d in dict items is not an integer: %s", items_index, items_cur->first->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *k = (PyRepInteger *) items_cur->first;
		if(k->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode Rsp_CommonGetInfo: truncating 64 bit into into 32 bit int in key of entry %d in field items", items_index);
		}
		items[k->value] = items_cur->second->Clone();
	}
	
		} else
		{
			_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: Unknown key string '%s' in dict1", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict1_header) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: Missing dict entry for 'header' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_rowclass) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: Missing dict entry for 'rowclass' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_idName) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: Missing dict entry for 'idName' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_items) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: Missing dict entry for 'items' in dict1");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

Rsp_CommonGetInfo *Rsp_CommonGetInfo::Clone() const {
	Rsp_CommonGetInfo *res = new Rsp_CommonGetInfo;
	res->CloneFrom(this);
	return(res);
}

void Rsp_CommonGetInfo::CloneFrom(const Rsp_CommonGetInfo *from) {
	/* object of type util.IndexRowset */
	head_itemID = from->head_itemID;
	head_invItem = from->head_invItem;
	head_activeEffects = from->head_activeEffects;
	head_attributes = from->head_attributes;
	head_time = from->head_time;
	rowclass = from->rowclass;
	idName = from->idName;
	/*  For ShipGetInfo: contains a single Rsp_CommonGetInfo_Entry for the ship  */
	/*  For CharGetInfo: contains an Rsp_CommonGetInfo_Entry for the char and each of their skills (and implants?)  */
	std::map<uint32, PyRep *>::const_iterator items_cur, items_end;
	//free any existing elements first
	items_cur = items.begin();
	items_end = items.end();
	for(; items_cur != items_end; items_cur++) {
		delete items_cur->second;
	}
	items.clear();
	//now we can copy in the new ones...
	items_cur = from->items.begin();
	items_end = from->items.end();
	for(; items_cur != items_end; items_cur++) {
		items[items_cur->first] = items_cur->second->Clone();
	}
	
	
}


EntityRowObject::EntityRowObject() {
	/* object of type util.Row */
	head_itemID = "itemID";
	head_typeID = "typeID";
	head_ownerID = "ownerID";
	head_locationID = "locationID";
	head_flag = "flag";
	head_contraband = "contraband";
	head_singleton = "singleton";
	head_quantity = "quantity";
	head_groupID = "groupID";
	head_categoryID = "categoryID";
	head_customInfo = "customInfo";
	itemID = 0;
	typeID = 0;
	ownerID = 0;
	locationID = 0;
	flag = 0;
	contraband = 0;
	singleton = 0;
	quantity = 0;
	groupID = 0;
	categoryID = 0;
	customInfo = "";
}

EntityRowObject::~EntityRowObject() {
}

void EntityRowObject::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sEntityRowObject", pfx);
	_log(l_type, "%sObject of type util.Row:", pfx);
	_log(l_type, "%shead_itemID='%s'", pfx, head_itemID.c_str());
	_log(l_type, "%shead_typeID='%s'", pfx, head_typeID.c_str());
	_log(l_type, "%shead_ownerID='%s'", pfx, head_ownerID.c_str());
	_log(l_type, "%shead_locationID='%s'", pfx, head_locationID.c_str());
	_log(l_type, "%shead_flag='%s'", pfx, head_flag.c_str());
	_log(l_type, "%shead_contraband='%s'", pfx, head_contraband.c_str());
	_log(l_type, "%shead_singleton='%s'", pfx, head_singleton.c_str());
	_log(l_type, "%shead_quantity='%s'", pfx, head_quantity.c_str());
	_log(l_type, "%shead_groupID='%s'", pfx, head_groupID.c_str());
	_log(l_type, "%shead_categoryID='%s'", pfx, head_categoryID.c_str());
	_log(l_type, "%shead_customInfo='%s'", pfx, head_customInfo.c_str());
	_log(l_type, "%sitemID=%lu", pfx, itemID);
	_log(l_type, "%stypeID=%lu", pfx, typeID);
	_log(l_type, "%sownerID=%lu", pfx, ownerID);
	_log(l_type, "%slocationID=%lu", pfx, locationID);
	_log(l_type, "%sflag=%lu", pfx, flag);
	_log(l_type, "%scontraband=%lu", pfx, contraband);
	_log(l_type, "%ssingleton=%lu", pfx, singleton);
	_log(l_type, "%squantity=%lu", pfx, quantity);
	_log(l_type, "%sgroupID=%lu", pfx, groupID);
	_log(l_type, "%scategoryID=%lu", pfx, categoryID);
	_log(l_type, "%scustomInfo='%s'", pfx, customInfo.c_str());
}

PyRepObject *EntityRowObject::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepList *list2 = new PyRepList();
	list2->items.resize(11, NULL);
	list2->items[0] = new PyRepString(head_itemID);
	list2->items[1] = new PyRepString(head_typeID);
	list2->items[2] = new PyRepString(head_ownerID);
	list2->items[3] = new PyRepString(head_locationID);
	list2->items[4] = new PyRepString(head_flag);
	list2->items[5] = new PyRepString(head_contraband);
	list2->items[6] = new PyRepString(head_singleton);
	list2->items[7] = new PyRepString(head_quantity);
	list2->items[8] = new PyRepString(head_groupID);
	list2->items[9] = new PyRepString(head_categoryID);
	list2->items[10] = new PyRepString(head_customInfo);
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	PyRepList *list3 = new PyRepList();
	list3->items.resize(11, NULL);
	list3->items[0] = new PyRepInteger(itemID);
	list3->items[1] = new PyRepInteger(typeID);
	list3->items[2] = new PyRepInteger(ownerID);
	list3->items[3] = new PyRepInteger(locationID);
	list3->items[4] = new PyRepInteger(flag);
	list3->items[5] = new PyRepInteger(contraband);
	list3->items[6] = new PyRepInteger(singleton);
	list3->items[7] = new PyRepInteger(quantity);
	list3->items[8] = new PyRepInteger(groupID);
	list3->items[9] = new PyRepInteger(categoryID);
	list3->items[10] = new PyRepString(customInfo);
	dict1_1 = list3;
	
	dict1->items[
		new PyRepString("line")
	] = dict1_1;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.Row",
			args0
		);
	

	return(res);
}

PyRepObject *EntityRowObject::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepList *list2 = new PyRepList();
	list2->items.resize(11, NULL);
	list2->items[0] = new PyRepString(head_itemID);
	list2->items[1] = new PyRepString(head_typeID);
	list2->items[2] = new PyRepString(head_ownerID);
	list2->items[3] = new PyRepString(head_locationID);
	list2->items[4] = new PyRepString(head_flag);
	list2->items[5] = new PyRepString(head_contraband);
	list2->items[6] = new PyRepString(head_singleton);
	list2->items[7] = new PyRepString(head_quantity);
	list2->items[8] = new PyRepString(head_groupID);
	list2->items[9] = new PyRepString(head_categoryID);
	list2->items[10] = new PyRepString(head_customInfo);
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	PyRepList *list3 = new PyRepList();
	list3->items.resize(11, NULL);
	list3->items[0] = new PyRepInteger(itemID);
	list3->items[1] = new PyRepInteger(typeID);
	list3->items[2] = new PyRepInteger(ownerID);
	list3->items[3] = new PyRepInteger(locationID);
	list3->items[4] = new PyRepInteger(flag);
	list3->items[5] = new PyRepInteger(contraband);
	list3->items[6] = new PyRepInteger(singleton);
	list3->items[7] = new PyRepInteger(quantity);
	list3->items[8] = new PyRepInteger(groupID);
	list3->items[9] = new PyRepInteger(categoryID);
	list3->items[10] = new PyRepString(customInfo);
	dict1_1 = list3;
	
	dict1->items[
		new PyRepString("line")
	] = dict1_1;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.Row",
			args0
		);
	

	return(res);
}

bool EntityRowObject::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool EntityRowObject::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "util.Row") {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: obj_0 is the wrong object type. Expected 'util.Row', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: dict1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict1_header = false;
	bool dict1_line = false;
	PyRepDict *dict1 = (PyRepDict *) obj_0->arguments;
	
	PyRepDict::iterator dict1_cur, dict1_end;
	dict1_cur = dict1->items.begin();
	dict1_end = dict1->items.end();
	for(; dict1_cur != dict1_end; dict1_cur++) {
		PyRep *key__ = dict1_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: a key in dict1 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "header") {
			dict1_header = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: list2 is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list2 = (PyRepList *) dict1_cur->second;
	if(list2->items.size() != 11) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: list2 is the wrong size: expected 11, but got %d", list2->items.size());
		delete packet;
		return(false);
	}

	if(!list2->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: head_itemID is not a string: %s", list2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) list2->items[0];
	head_itemID = string_3->value;
	if(!list2->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: head_typeID is not a string: %s", list2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_4 = (PyRepString *) list2->items[1];
	head_typeID = string_4->value;
	if(!list2->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: head_ownerID is not a string: %s", list2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_5 = (PyRepString *) list2->items[2];
	head_ownerID = string_5->value;
	if(!list2->items[3]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: head_locationID is not a string: %s", list2->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_6 = (PyRepString *) list2->items[3];
	head_locationID = string_6->value;
	if(!list2->items[4]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: head_flag is not a string: %s", list2->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_7 = (PyRepString *) list2->items[4];
	head_flag = string_7->value;
	if(!list2->items[5]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: head_contraband is not a string: %s", list2->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_8 = (PyRepString *) list2->items[5];
	head_contraband = string_8->value;
	if(!list2->items[6]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: head_singleton is not a string: %s", list2->items[6]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_9 = (PyRepString *) list2->items[6];
	head_singleton = string_9->value;
	if(!list2->items[7]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: head_quantity is not a string: %s", list2->items[7]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_10 = (PyRepString *) list2->items[7];
	head_quantity = string_10->value;
	if(!list2->items[8]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: head_groupID is not a string: %s", list2->items[8]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_11 = (PyRepString *) list2->items[8];
	head_groupID = string_11->value;
	if(!list2->items[9]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: head_categoryID is not a string: %s", list2->items[9]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_12 = (PyRepString *) list2->items[9];
	head_categoryID = string_12->value;
	if(!list2->items[10]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: head_customInfo is not a string: %s", list2->items[10]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_13 = (PyRepString *) list2->items[10];
	head_customInfo = string_13->value;
		} else
		if(key_string__->value == "line") {
			dict1_line = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: list14 is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list14 = (PyRepList *) dict1_cur->second;
	if(list14->items.size() != 11) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: list14 is the wrong size: expected 11, but got %d", list14->items.size());
		delete packet;
		return(false);
	}

	if(!list14->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: itemID is not an int: %s", list14->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_15 = (PyRepInteger *) list14->items[0];
	if(int_15->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityRowObject: truncating 64 bit into into 32 bit int for field itemID");
	}
	itemID = int_15->value;
	if(!list14->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: typeID is not an int: %s", list14->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_16 = (PyRepInteger *) list14->items[1];
	if(int_16->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityRowObject: truncating 64 bit into into 32 bit int for field typeID");
	}
	typeID = int_16->value;
	if(!list14->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: ownerID is not an int: %s", list14->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_17 = (PyRepInteger *) list14->items[2];
	if(int_17->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityRowObject: truncating 64 bit into into 32 bit int for field ownerID");
	}
	ownerID = int_17->value;
	if(!list14->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: locationID is not an int: %s", list14->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_18 = (PyRepInteger *) list14->items[3];
	if(int_18->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityRowObject: truncating 64 bit into into 32 bit int for field locationID");
	}
	locationID = int_18->value;
	if(!list14->items[4]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: flag is not an int: %s", list14->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_19 = (PyRepInteger *) list14->items[4];
	if(int_19->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityRowObject: truncating 64 bit into into 32 bit int for field flag");
	}
	flag = int_19->value;
	if(!list14->items[5]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: contraband is not an int: %s", list14->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_20 = (PyRepInteger *) list14->items[5];
	if(int_20->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityRowObject: truncating 64 bit into into 32 bit int for field contraband");
	}
	contraband = int_20->value;
	if(!list14->items[6]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: singleton is not an int: %s", list14->items[6]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_21 = (PyRepInteger *) list14->items[6];
	if(int_21->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityRowObject: truncating 64 bit into into 32 bit int for field singleton");
	}
	singleton = int_21->value;
	if(!list14->items[7]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: quantity is not an int: %s", list14->items[7]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_22 = (PyRepInteger *) list14->items[7];
	if(int_22->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityRowObject: truncating 64 bit into into 32 bit int for field quantity");
	}
	quantity = int_22->value;
	if(!list14->items[8]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: groupID is not an int: %s", list14->items[8]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_23 = (PyRepInteger *) list14->items[8];
	if(int_23->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityRowObject: truncating 64 bit into into 32 bit int for field groupID");
	}
	groupID = int_23->value;
	if(!list14->items[9]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: categoryID is not an int: %s", list14->items[9]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_24 = (PyRepInteger *) list14->items[9];
	if(int_24->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityRowObject: truncating 64 bit into into 32 bit int for field categoryID");
	}
	categoryID = int_24->value;
	if(!list14->items[10]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: customInfo is not a string: %s", list14->items[10]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_25 = (PyRepString *) list14->items[10];
	customInfo = string_25->value;
		} else
		{
			_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: Unknown key string '%s' in dict1", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict1_header) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: Missing dict entry for 'header' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_line) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: Missing dict entry for 'line' in dict1");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

EntityRowObject *EntityRowObject::Clone() const {
	EntityRowObject *res = new EntityRowObject;
	res->CloneFrom(this);
	return(res);
}

void EntityRowObject::CloneFrom(const EntityRowObject *from) {
	/* object of type util.Row */
	head_itemID = from->head_itemID;
	head_typeID = from->head_typeID;
	head_ownerID = from->head_ownerID;
	head_locationID = from->head_locationID;
	head_flag = from->head_flag;
	head_contraband = from->head_contraband;
	head_singleton = from->head_singleton;
	head_quantity = from->head_quantity;
	head_groupID = from->head_groupID;
	head_categoryID = from->head_categoryID;
	head_customInfo = from->head_customInfo;
	itemID = from->itemID;
	typeID = from->typeID;
	ownerID = from->ownerID;
	locationID = from->locationID;
	flag = from->flag;
	contraband = from->contraband;
	singleton = from->singleton;
	quantity = from->quantity;
	groupID = from->groupID;
	categoryID = from->categoryID;
	customInfo = from->customInfo;
	
}


Call_GetOptionsForItemTypes::Call_GetOptionsForItemTypes() {
}

Call_GetOptionsForItemTypes::~Call_GetOptionsForItemTypes() {
}

void Call_GetOptionsForItemTypes::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_GetOptionsForItemTypes", pfx);
	_log(l_type, "%stypeIDs: ", pfx);
	std::string typeIDs_n(pfx);
	typeIDs_n += "    ";
	typeIDs.Dump(l_type, typeIDs_n.c_str());
}

PyRepTuple *Call_GetOptionsForItemTypes::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	tuple0->items[0] = typeIDs.Clone();
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_GetOptionsForItemTypes::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	
	PyRepDict *dict1 = new PyRepDict();
	dict1->items = typeIDs.items;
	typeIDs.items.clear();
	tuple0->items[0] = dict1;
	res = tuple0;
	

	return(res);
}

bool Call_GetOptionsForItemTypes::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_GetOptionsForItemTypes::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetOptionsForItemTypes failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode Call_GetOptionsForItemTypes failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetOptionsForItemTypes failed: typeIDs is not a dict: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepDict *list_typeIDs = (PyRepDict *) tuple0->items[0];	typeIDs.items = list_typeIDs->items;
	list_typeIDs->items.clear();
	

	delete packet;
	return(true);
}

Call_GetOptionsForItemTypes *Call_GetOptionsForItemTypes::Clone() const {
	Call_GetOptionsForItemTypes *res = new Call_GetOptionsForItemTypes;
	res->CloneFrom(this);
	return(res);
}

void Call_GetOptionsForItemTypes::CloneFrom(const Call_GetOptionsForItemTypes *from) {
	typeIDs.CloneFrom(&from->typeIDs);
	
}


Call_GetOptionsForItemTypes_Arg::Call_GetOptionsForItemTypes_Arg() {
	/* object of type util.KeyVal */
	isRecyclable = 0;
	isRefinable = 0;
}

Call_GetOptionsForItemTypes_Arg::~Call_GetOptionsForItemTypes_Arg() {
}

void Call_GetOptionsForItemTypes_Arg::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_GetOptionsForItemTypes_Arg", pfx);
	_log(l_type, "%sObject of type util.KeyVal:", pfx);
	_log(l_type, "%sisRecyclable=%lu", pfx, isRecyclable);
	_log(l_type, "%sisRefinable=%lu", pfx, isRefinable);
}

PyRepObject *Call_GetOptionsForItemTypes_Arg::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	dict1_0 = new PyRepInteger(isRecyclable);
	dict1->items[
		new PyRepString("isRecyclable")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepInteger(isRefinable);
	dict1->items[
		new PyRepString("isRefinable")
	] = dict1_1;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.KeyVal",
			args0
		);
	

	return(res);
}

PyRepObject *Call_GetOptionsForItemTypes_Arg::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	dict1_0 = new PyRepInteger(isRecyclable);
	dict1->items[
		new PyRepString("isRecyclable")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepInteger(isRefinable);
	dict1->items[
		new PyRepString("isRefinable")
	] = dict1_1;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.KeyVal",
			args0
		);
	

	return(res);
}

bool Call_GetOptionsForItemTypes_Arg::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_GetOptionsForItemTypes_Arg::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetOptionsForItemTypes_Arg failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "util.KeyVal") {
		_log(NET__PACKET_ERROR, "Decode Call_GetOptionsForItemTypes_Arg failed: obj_0 is the wrong object type. Expected 'util.KeyVal', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetOptionsForItemTypes_Arg failed: dict1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict1_isRecyclable = false;
	bool dict1_isRefinable = false;
	PyRepDict *dict1 = (PyRepDict *) obj_0->arguments;
	
	PyRepDict::iterator dict1_cur, dict1_end;
	dict1_cur = dict1->items.begin();
	dict1_end = dict1->items.end();
	for(; dict1_cur != dict1_end; dict1_cur++) {
		PyRep *key__ = dict1_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode Call_GetOptionsForItemTypes_Arg failed: a key in dict1 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "isRecyclable") {
			dict1_isRecyclable = true;
	if(!dict1_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetOptionsForItemTypes_Arg failed: isRecyclable is not an int: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) dict1_cur->second;
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_GetOptionsForItemTypes_Arg: truncating 64 bit into into 32 bit int for field isRecyclable");
	}
	isRecyclable = int_2->value;
		} else
		if(key_string__->value == "isRefinable") {
			dict1_isRefinable = true;
	if(!dict1_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetOptionsForItemTypes_Arg failed: isRefinable is not an int: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) dict1_cur->second;
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_GetOptionsForItemTypes_Arg: truncating 64 bit into into 32 bit int for field isRefinable");
	}
	isRefinable = int_3->value;
		} else
		{
			_log(NET__PACKET_ERROR, "Decode Call_GetOptionsForItemTypes_Arg failed: Unknown key string '%s' in dict1", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict1_isRecyclable) {
		_log(NET__PACKET_ERROR, "Decode Call_GetOptionsForItemTypes_Arg failed: Missing dict entry for 'isRecyclable' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_isRefinable) {
		_log(NET__PACKET_ERROR, "Decode Call_GetOptionsForItemTypes_Arg failed: Missing dict entry for 'isRefinable' in dict1");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

Call_GetOptionsForItemTypes_Arg *Call_GetOptionsForItemTypes_Arg::Clone() const {
	Call_GetOptionsForItemTypes_Arg *res = new Call_GetOptionsForItemTypes_Arg;
	res->CloneFrom(this);
	return(res);
}

void Call_GetOptionsForItemTypes_Arg::CloneFrom(const Call_GetOptionsForItemTypes_Arg *from) {
	/* object of type util.KeyVal */
	isRecyclable = from->isRecyclable;
	isRefinable = from->isRefinable;
	
}

	/*  this is ugly, but we dont really have a better way to deal with it right now.  */

Rsp_GetQuote::Rsp_GetQuote() {
	/* object of type util.KeyVal */
	quantityToProcess = 0;
	/* object of type util.Rowset */
	/*  Don't change headerX !  */
	header1 = "typeID";
	header2 = "unrecoverable";
	header3 = "station";
	header4 = "client";
	rowclass = "util.Row";
}

Rsp_GetQuote::~Rsp_GetQuote() {
	/*  Don't change headerX !  */
}

void Rsp_GetQuote::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRsp_GetQuote", pfx);
	_log(l_type, "%sObject of type util.KeyVal:", pfx);
	_log(l_type, "%squantityToProcess=%lu", pfx, quantityToProcess);
	_log(l_type, "%sObject of type util.Rowset:", pfx);
	/*  Don't change headerX !  */
	_log(l_type, "%sheader1='%s'", pfx, header1.c_str());
	_log(l_type, "%sheader2='%s'", pfx, header2.c_str());
	_log(l_type, "%sheader3='%s'", pfx, header3.c_str());
	_log(l_type, "%sheader4='%s'", pfx, header4.c_str());
	_log(l_type, "%srowclass='%s'", pfx, rowclass.c_str());
	_log(l_type, "%slines: ", pfx);
	std::string lines_n(pfx);
	lines_n += "    ";
	lines.Dump(l_type, lines_n.c_str());
}

PyRepObject *Rsp_GetQuote::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	dict1_0 = new PyRepInteger(quantityToProcess);
	dict1->items[
		new PyRepString("quantityToProcess")
	] = dict1_0;
	PyRep *dict1_1;
	PyRep *args2;
	PyRepDict *dict3 = new PyRepDict();
	PyRep *dict3_0;
	PyRepList *list4 = new PyRepList();
	list4->items.resize(4, NULL);
	/*  Don't change headerX !  */
	list4->items[0] = new PyRepString(header1);
	list4->items[1] = new PyRepString(header2);
	list4->items[2] = new PyRepString(header3);
	list4->items[3] = new PyRepString(header4);
	dict3_0 = list4;
	
	dict3->items[
		new PyRepString("header")
	] = dict3_0;
	PyRep *dict3_1;
	dict3_1 = new PyRepString(rowclass, true);
	dict3->items[
		new PyRepString("rowclass")
	] = dict3_1;
	PyRep *dict3_2;
	dict3_2 = lines.Clone();
	dict3->items[
		new PyRepString("lines")
	] = dict3_2;
	args2 = dict3;
	
	dict1_1 = new PyRepObject(
			"util.Rowset",
			args2
		);
	
	dict1->items[
		new PyRepString("recoverables")
	] = dict1_1;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.KeyVal",
			args0
		);
	

	return(res);
}

PyRepObject *Rsp_GetQuote::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	dict1_0 = new PyRepInteger(quantityToProcess);
	dict1->items[
		new PyRepString("quantityToProcess")
	] = dict1_0;
	PyRep *dict1_1;
	PyRep *args2;
	PyRepDict *dict3 = new PyRepDict();
	PyRep *dict3_0;
	PyRepList *list4 = new PyRepList();
	list4->items.resize(4, NULL);
	/*  Don't change headerX !  */
	list4->items[0] = new PyRepString(header1);
	list4->items[1] = new PyRepString(header2);
	list4->items[2] = new PyRepString(header3);
	list4->items[3] = new PyRepString(header4);
	dict3_0 = list4;
	
	dict3->items[
		new PyRepString("header")
	] = dict3_0;
	PyRep *dict3_1;
	dict3_1 = new PyRepString(rowclass, true);
	dict3->items[
		new PyRepString("rowclass")
	] = dict3_1;
	PyRep *dict3_2;
	
	PyRepList *list5 = new PyRepList();
	list5->items = lines.items;
	lines.items.clear();
	dict3_2 = list5;
	dict3->items[
		new PyRepString("lines")
	] = dict3_2;
	args2 = dict3;
	
	dict1_1 = new PyRepObject(
			"util.Rowset",
			args2
		);
	
	dict1->items[
		new PyRepString("recoverables")
	] = dict1_1;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.KeyVal",
			args0
		);
	

	return(res);
}

bool Rsp_GetQuote::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Rsp_GetQuote::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "util.KeyVal") {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: obj_0 is the wrong object type. Expected 'util.KeyVal', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: dict1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict1_quantityToProcess = false;
	bool dict1_recoverables = false;
	PyRepDict *dict1 = (PyRepDict *) obj_0->arguments;
	
	PyRepDict::iterator dict1_cur, dict1_end;
	dict1_cur = dict1->items.begin();
	dict1_end = dict1->items.end();
	for(; dict1_cur != dict1_end; dict1_cur++) {
		PyRep *key__ = dict1_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: a key in dict1 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "quantityToProcess") {
			dict1_quantityToProcess = true;
	if(!dict1_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: quantityToProcess is not an int: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) dict1_cur->second;
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetQuote: truncating 64 bit into into 32 bit int for field quantityToProcess");
	}
	quantityToProcess = int_2->value;
		} else
		if(key_string__->value == "recoverables") {
			dict1_recoverables = true;
	if(!dict1_cur->second->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: obj_3 is the wrong type: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_3 = (PyRepObject *) dict1_cur->second;
	
	if(obj_3->type != "util.Rowset") {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: obj_3 is the wrong object type. Expected 'util.Rowset', got '%s'", obj_3->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_3->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: dict4 is the wrong type: %s", obj_3->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict4_header = false;
	bool dict4_rowclass = false;
	bool dict4_lines = false;
	PyRepDict *dict4 = (PyRepDict *) obj_3->arguments;
	
	PyRepDict::iterator dict4_cur, dict4_end;
	dict4_cur = dict4->items.begin();
	dict4_end = dict4->items.end();
	for(; dict4_cur != dict4_end; dict4_cur++) {
		PyRep *key__ = dict4_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: a key in dict4 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "header") {
			dict4_header = true;
	if(!dict4_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: list5 is not a list: %s", dict4_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list5 = (PyRepList *) dict4_cur->second;
	if(list5->items.size() != 4) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: list5 is the wrong size: expected 4, but got %d", list5->items.size());
		delete packet;
		return(false);
	}

	/*  Don't change headerX !  */
	if(!list5->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: header1 is not a string: %s", list5->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_6 = (PyRepString *) list5->items[0];
	header1 = string_6->value;
	if(!list5->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: header2 is not a string: %s", list5->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_7 = (PyRepString *) list5->items[1];
	header2 = string_7->value;
	if(!list5->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: header3 is not a string: %s", list5->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_8 = (PyRepString *) list5->items[2];
	header3 = string_8->value;
	if(!list5->items[3]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: header4 is not a string: %s", list5->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_9 = (PyRepString *) list5->items[3];
	header4 = string_9->value;
		} else
		if(key_string__->value == "rowclass") {
			dict4_rowclass = true;
	if(!dict4_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: rowclass is not a string: %s", dict4_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_10 = (PyRepString *) dict4_cur->second;
	rowclass = string_10->value;
	if(string_10->is_type_1 != true) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote: String type mismatch on rowclass: expected %d got %d. Continuing anyhow.", true, string_10->is_type_1);
	}
		} else
		if(key_string__->value == "lines") {
			dict4_lines = true;
	if(!dict4_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: lines is not a list: %s", dict4_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_lines = (PyRepList *) dict4_cur->second;	lines.items = list_lines->items;
	list_lines->items.clear();
	
		} else
		{
			_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: Unknown key string '%s' in dict4", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict4_header) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: Missing dict entry for 'header' in dict4");
		delete packet;
		return(false);
	}
	
	if(!dict4_rowclass) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: Missing dict entry for 'rowclass' in dict4");
		delete packet;
		return(false);
	}
	
	if(!dict4_lines) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: Missing dict entry for 'lines' in dict4");
		delete packet;
		return(false);
	}
	
		} else
		{
			_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: Unknown key string '%s' in dict1", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict1_quantityToProcess) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: Missing dict entry for 'quantityToProcess' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_recoverables) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: Missing dict entry for 'recoverables' in dict1");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

Rsp_GetQuote *Rsp_GetQuote::Clone() const {
	Rsp_GetQuote *res = new Rsp_GetQuote;
	res->CloneFrom(this);
	return(res);
}

void Rsp_GetQuote::CloneFrom(const Rsp_GetQuote *from) {
	/* object of type util.KeyVal */
	quantityToProcess = from->quantityToProcess;
	/* object of type util.Rowset */
	/*  Don't change headerX !  */
	header1 = from->header1;
	header2 = from->header2;
	header3 = from->header3;
	header4 = from->header4;
	rowclass = from->rowclass;
	lines.CloneFrom(&from->lines);
	
}


Rsp_GetQuote_Line::Rsp_GetQuote_Line() {
	typeID = 0;
	unrecoverable = 0;
	station = 0;
	client = 0;
}

Rsp_GetQuote_Line::~Rsp_GetQuote_Line() {
}

void Rsp_GetQuote_Line::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRsp_GetQuote_Line", pfx);
	_log(l_type, "%stypeID=%lu", pfx, typeID);
	_log(l_type, "%sunrecoverable=%lu", pfx, unrecoverable);
	_log(l_type, "%sstation=%lu", pfx, station);
	_log(l_type, "%sclient=%lu", pfx, client);
}

PyRepList *Rsp_GetQuote_Line::Encode() {
	PyRepList *res = NULL;
	PyRepList *list0 = new PyRepList();
	list0->items.resize(4, NULL);
	list0->items[0] = new PyRepInteger(typeID);
	list0->items[1] = new PyRepInteger(unrecoverable);
	list0->items[2] = new PyRepInteger(station);
	list0->items[3] = new PyRepInteger(client);
	res = list0;
	

	return(res);
}

PyRepList *Rsp_GetQuote_Line::FastEncode() {
	PyRepList *res = NULL;
	PyRepList *list0 = new PyRepList();
	list0->items.resize(4, NULL);
	list0->items[0] = new PyRepInteger(typeID);
	list0->items[1] = new PyRepInteger(unrecoverable);
	list0->items[2] = new PyRepInteger(station);
	list0->items[3] = new PyRepInteger(client);
	res = list0;
	

	return(res);
}

bool Rsp_GetQuote_Line::Decode(PyRepList **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Rsp_GetQuote_Line::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote_Line failed: list0 is not a list: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list0 = (PyRepList *) packet;
	if(list0->items.size() != 4) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote_Line failed: list0 is the wrong size: expected 4, but got %d", list0->items.size());
		delete packet;
		return(false);
	}

	if(!list0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote_Line failed: typeID is not an int: %s", list0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) list0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetQuote_Line: truncating 64 bit into into 32 bit int for field typeID");
	}
	typeID = int_1->value;
	if(!list0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote_Line failed: unrecoverable is not an int: %s", list0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) list0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetQuote_Line: truncating 64 bit into into 32 bit int for field unrecoverable");
	}
	unrecoverable = int_2->value;
	if(!list0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote_Line failed: station is not an int: %s", list0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) list0->items[2];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetQuote_Line: truncating 64 bit into into 32 bit int for field station");
	}
	station = int_3->value;
	if(!list0->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote_Line failed: client is not an int: %s", list0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) list0->items[3];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetQuote_Line: truncating 64 bit into into 32 bit int for field client");
	}
	client = int_4->value;

	delete packet;
	return(true);
}

Rsp_GetQuote_Line *Rsp_GetQuote_Line::Clone() const {
	Rsp_GetQuote_Line *res = new Rsp_GetQuote_Line;
	res->CloneFrom(this);
	return(res);
}

void Rsp_GetQuote_Line::CloneFrom(const Rsp_GetQuote_Line *from) {
	typeID = from->typeID;
	unrecoverable = from->unrecoverable;
	station = from->station;
	client = from->client;
	
}


Call_Reprocess::Call_Reprocess() {
}

Call_Reprocess::~Call_Reprocess() {
}

void Call_Reprocess::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_Reprocess", pfx);
	_log(l_type, "%sitemIDs: Integer list with %d enetires", pfx, itemIDs.size());
	std::vector<uint32>::const_iterator itemIDs_cur, itemIDs_end;
	itemIDs_cur = itemIDs.begin();
	itemIDs_end = itemIDs.end();
	int itemIDs_index;
	for(itemIDs_index = 0; itemIDs_cur != itemIDs_end; itemIDs_cur++, itemIDs_index++) {
		_log(l_type, "%s   [%02d] %d", pfx, itemIDs_index, *itemIDs_cur);
	}
	
}

PyRepTuple *Call_Reprocess::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator itemIDs_cur, itemIDs_end;
	itemIDs_cur = itemIDs.begin();
	itemIDs_end = itemIDs.end();
	for(; itemIDs_cur != itemIDs_end; itemIDs_cur++) {
		list1->items.push_back(
			new PyRepInteger(*itemIDs_cur)
		);
	}
	tuple0->items[0] = list1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_Reprocess::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator itemIDs_cur, itemIDs_end;
	itemIDs_cur = itemIDs.begin();
	itemIDs_end = itemIDs.end();
	for(; itemIDs_cur != itemIDs_end; itemIDs_cur++) {
		list1->items.push_back(
			new PyRepInteger(*itemIDs_cur)
		);
	}
	tuple0->items[0] = list1;
	
	res = tuple0;
	

	return(res);
}

bool Call_Reprocess::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_Reprocess::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_Reprocess failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode Call_Reprocess failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Call_Reprocess failed: itemIDs is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	itemIDs.clear();
	PyRepList *list_1 = (PyRepList *) tuple0->items[0];
	PyRepList::iterator itemIDs_cur, itemIDs_end;
	itemIDs_cur = list_1->items.begin();
	itemIDs_end = list_1->items.end();
	int itemIDs_index;
	for(itemIDs_index = 0; itemIDs_cur != itemIDs_end; itemIDs_cur++, itemIDs_index++) {
		if(!(*itemIDs_cur)->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode Call_Reprocess failed: Element %d in list itemIDs is not an integer: %s", itemIDs_index, (*itemIDs_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *t = (PyRepInteger *) (*itemIDs_cur);
		if(t->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode Call_Reprocess: truncating 64 bit into into 32 bit int for item %d in field itemIDs", itemIDs_index);
		}
		itemIDs.push_back(t->value);
	}


	delete packet;
	return(true);
}

Call_Reprocess *Call_Reprocess::Clone() const {
	Call_Reprocess *res = new Call_Reprocess;
	res->CloneFrom(this);
	return(res);
}

void Call_Reprocess::CloneFrom(const Call_Reprocess *from) {
	itemIDs = from->itemIDs;
	
}



