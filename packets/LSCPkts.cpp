/*  EVEmu: EVE Online Server Emulator
  
  **************************************************************
  This file is automatically generated, DO NOT EDIT IT DIRECTLY.
  **************************************************************
  
  (If you need to customize an object, you must copy that object
  into another source file, and give up the ability to generate it)
  
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; version 2 of the License.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY except by those people which sell it, which
  are required to give you total support for your newly bought product;
  without even the implied warranty of MERCHANTABILITY or FITNESS FOR
  A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/


#include <string>
#include "..\packets\LSCPkts.h"
#include "../common/PyRep.h"




LSCChannelMultiDesc::LSCChannelMultiDesc() {
	type = "";
	number = 0;
}

LSCChannelMultiDesc::~LSCChannelMultiDesc() {
}

void LSCChannelMultiDesc::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sLSCChannelMultiDesc", pfx);
	_log(l_type, "%stype='%s'", pfx, type.c_str());
	_log(l_type, "%snumber=%lu", pfx, number);
}

PyRepTuple *LSCChannelMultiDesc::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	PyRepTuple *tuple1 = new PyRepTuple(2);
	tuple1->items[0] = new PyRepString(type);
	tuple1->items[1] = new PyRepInteger(number);
	tuple0->items[0] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *LSCChannelMultiDesc::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	PyRepTuple *tuple1 = new PyRepTuple(2);
	tuple1->items[0] = new PyRepString(type);
	tuple1->items[1] = new PyRepInteger(number);
	tuple0->items[0] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool LSCChannelMultiDesc::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool LSCChannelMultiDesc::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode LSCChannelMultiDesc failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode LSCChannelMultiDesc failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode LSCChannelMultiDesc failed: tuple1 is the wrong type: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple1 = (PyRepTuple *) tuple0->items[0];
	if(tuple1->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode LSCChannelMultiDesc failed: tuple1 is the wrong size: expected 2, but got %d", tuple1->items.size());
		delete packet;
		return(false);
	}

	if(!tuple1->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode LSCChannelMultiDesc failed: type is not a string: %s", tuple1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple1->items[0];
	type = string_2->value;
	if(!tuple1->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode LSCChannelMultiDesc failed: number is not an int: %s", tuple1->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple1->items[1];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode LSCChannelMultiDesc: truncating 64 bit into into 32 bit int for field number");
	}
	number = int_3->value;

	delete packet;
	return(true);
}

LSCChannelMultiDesc *LSCChannelMultiDesc::Clone() const {
	LSCChannelMultiDesc *res = new LSCChannelMultiDesc;
	res->CloneFrom(this);
	return(res);
}

void LSCChannelMultiDesc::CloneFrom(const LSCChannelMultiDesc *from) {
	type = from->type;
	number = from->number;
	
}


RspGetChannels::RspGetChannels() {
	/*  0  */
}

RspGetChannels::~RspGetChannels() {
	/*  0  */
}

void RspGetChannels::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspGetChannels", pfx);
	/*  0  */
	_log(l_type, "%scachedcall:", pfx);
	std::string cachedcall_n(pfx);
	cachedcall_n += "    ";
	cachedcall.Dump(l_type, cachedcall_n.c_str());
}

PyRepTuple *RspGetChannels::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
		ss_1 = cachedcall.Encode();
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

PyRepTuple *RspGetChannels::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
		ss_1 = cachedcall.FastEncode();
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspGetChannels::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspGetChannels::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetChannels failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspGetChannels failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspGetChannels failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspGetChannels failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	PyRep *rep_2 = ss_1->decoded;
	ss_1->decoded = NULL;
	if(!cachedcall.Decode(&rep_2)) {
		_log(NET__PACKET_ERROR, "Decode RspGetChannels failed: unable to decode element cachedcall");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

RspGetChannels *RspGetChannels::Clone() const {
	RspGetChannels *res = new RspGetChannels;
	res->CloneFrom(this);
	return(res);
}

void RspGetChannels::CloneFrom(const RspGetChannels *from) {
	/*  0  */
	cachedcall.CloneFrom(&from->cachedcall);
	
}


CallJoinChannels::CallJoinChannels() {
	/*  0  */
}

CallJoinChannels::~CallJoinChannels() {
	/*  0  */
}

void CallJoinChannels::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallJoinChannels", pfx);
	/*  0  */
	_log(l_type, "%schannels: Integer list with %d enetires", pfx, channels.size());
	std::vector<uint32>::const_iterator channels_cur, channels_end;
	channels_cur = channels.begin();
	channels_end = channels.end();
	int channels_index;
	for(channels_index = 0; channels_cur != channels_end; channels_cur++, channels_index++) {
		_log(l_type, "%s   [%02d] %d", pfx, channels_index, *channels_cur);
	}
	
}

PyRepTuple *CallJoinChannels::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator channels_cur, channels_end;
	channels_cur = channels.begin();
	channels_end = channels.end();
	for(; channels_cur != channels_end; channels_cur++) {
		list1->items.push_back(
			new PyRepInteger(*channels_cur)
		);
	}
	tuple0->items[0] = list1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *CallJoinChannels::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator channels_cur, channels_end;
	channels_cur = channels.begin();
	channels_end = channels.end();
	for(; channels_cur != channels_end; channels_cur++) {
		list1->items.push_back(
			new PyRepInteger(*channels_cur)
		);
	}
	tuple0->items[0] = list1;
	
	res = tuple0;
	

	return(res);
}

bool CallJoinChannels::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallJoinChannels::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallJoinChannels failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode CallJoinChannels failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode CallJoinChannels failed: channels is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	channels.clear();
	PyRepList *list_1 = (PyRepList *) tuple0->items[0];
	PyRepList::iterator channels_cur, channels_end;
	channels_cur = list_1->items.begin();
	channels_end = list_1->items.end();
	int channels_index;
	for(channels_index = 0; channels_cur != channels_end; channels_cur++, channels_index++) {
		if(!(*channels_cur)->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode CallJoinChannels failed: Element %d in list channels is not an integer: %s", channels_index, (*channels_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *t = (PyRepInteger *) (*channels_cur);
		if(t->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode CallJoinChannels: truncating 64 bit into into 32 bit int for item %d in field channels", channels_index);
		}
		channels.push_back(t->value);
	}


	delete packet;
	return(true);
}

CallJoinChannels *CallJoinChannels::Clone() const {
	CallJoinChannels *res = new CallJoinChannels;
	res->CloneFrom(this);
	return(res);
}

void CallJoinChannels::CloneFrom(const CallJoinChannels *from) {
	/*  0  */
	channels = from->channels;
	
}


RspJoinChannels::RspJoinChannels() {
	/*  0  */
	/*  list of complex elements, one for each requested channel
	    with details about the channel  */
}

RspJoinChannels::~RspJoinChannels() {
	/*  0  */
	/*  list of complex elements, one for each requested channel
	    with details about the channel  */
}

void RspJoinChannels::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspJoinChannels", pfx);
	/*  0  */
	/*  list of complex elements, one for each requested channel
	    with details about the channel  */
	_log(l_type, "%schannels: ", pfx);
	std::string channels_n(pfx);
	channels_n += "    ";
	channels.Dump(l_type, channels_n.c_str());
}

PyRepTuple *RspJoinChannels::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	/*  list of complex elements, one for each requested channel
	    with details about the channel  */
	ss_1 = channels.Clone();
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

PyRepTuple *RspJoinChannels::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	/*  list of complex elements, one for each requested channel
	    with details about the channel  */
	
	PyRepList *list2 = new PyRepList();
	list2->items = channels.items;
	channels.items.clear();
	ss_1 = list2;
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspJoinChannels::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspJoinChannels::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspJoinChannels failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspJoinChannels failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspJoinChannels failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspJoinChannels failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	/*  list of complex elements, one for each requested channel
	    with details about the channel  */
	if(!ss_1->decoded->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode RspJoinChannels failed: channels is not a list: %s", ss_1->decoded->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_channels = (PyRepList *) ss_1->decoded;	channels.items = list_channels->items;
	list_channels->items.clear();
	

	delete packet;
	return(true);
}

RspJoinChannels *RspJoinChannels::Clone() const {
	RspJoinChannels *res = new RspJoinChannels;
	res->CloneFrom(this);
	return(res);
}

void RspJoinChannels::CloneFrom(const RspJoinChannels *from) {
	/*  0  */
	/*  list of complex elements, one for each requested channel
	    with details about the channel  */
	channels.CloneFrom(&from->channels);
	
}


OnLSC_SenderInfo::OnLSC_SenderInfo() {
	/*  0: whoAllianceID  */
	/*  1: whoCorpID  */
	corpID = 0;
	/*  2: who (could be this list, or could be just an integer ID)  */
	senderID = 0;
	senderName = "";
	senderType = 0;
	/*  3: whoRole  */
	role = 0;
	/*  4: whoCorpRole  */
	corp_role = 0;
}

OnLSC_SenderInfo::~OnLSC_SenderInfo() {
	/*  0: whoAllianceID  */
	/*  1: whoCorpID  */
	/*  2: who (could be this list, or could be just an integer ID)  */
	/*  3: whoRole  */
	/*  4: whoCorpRole  */
}

void OnLSC_SenderInfo::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sOnLSC_SenderInfo", pfx);
	/*  0: whoAllianceID  */
	/*  1: whoCorpID  */
	_log(l_type, "%scorpID=%lu", pfx, corpID);
	/*  2: who (could be this list, or could be just an integer ID)  */
	_log(l_type, "%ssenderID=%lu", pfx, senderID);
	_log(l_type, "%ssenderName='%s'", pfx, senderName.c_str());
	_log(l_type, "%ssenderType=%lu", pfx, senderType);
	/*  3: whoRole  */
	_log(l_type, "%srole=%lu", pfx, role);
	/*  4: whoCorpRole  */
	_log(l_type, "%scorp_role=%lu", pfx, corp_role);
}

PyRepTuple *OnLSC_SenderInfo::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	/*  0: whoAllianceID  */
	tuple0->items[0] = new PyRepNone();
	/*  1: whoCorpID  */
	tuple0->items[1] = new PyRepInteger(corpID);
	/*  2: who (could be this list, or could be just an integer ID)  */
	PyRepList *list1 = new PyRepList();
	list1->items.resize(3, NULL);
	list1->items[0] = new PyRepInteger(senderID);
	list1->items[1] = new PyRepString(senderName);
	list1->items[2] = new PyRepInteger(senderType);
	tuple0->items[2] = list1;
	
	/*  3: whoRole  */
	tuple0->items[3] = new PyRepInteger(role);
	/*  4: whoCorpRole  */
	tuple0->items[4] = new PyRepInteger(corp_role);
	res = tuple0;
	

	return(res);
}

PyRepTuple *OnLSC_SenderInfo::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	/*  0: whoAllianceID  */
	tuple0->items[0] = new PyRepNone();
	/*  1: whoCorpID  */
	tuple0->items[1] = new PyRepInteger(corpID);
	/*  2: who (could be this list, or could be just an integer ID)  */
	PyRepList *list1 = new PyRepList();
	list1->items.resize(3, NULL);
	list1->items[0] = new PyRepInteger(senderID);
	list1->items[1] = new PyRepString(senderName);
	list1->items[2] = new PyRepInteger(senderType);
	tuple0->items[2] = list1;
	
	/*  3: whoRole  */
	tuple0->items[3] = new PyRepInteger(role);
	/*  4: whoCorpRole  */
	tuple0->items[4] = new PyRepInteger(corp_role);
	res = tuple0;
	

	return(res);
}

bool OnLSC_SenderInfo::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool OnLSC_SenderInfo::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SenderInfo failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 5) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SenderInfo failed: tuple0 is the wrong size: expected 5, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0: whoAllianceID  */
	if(!tuple0->items[0]->CheckType(PyRep::None)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SenderInfo failed: expecting a None but got a %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	
	/*  1: whoCorpID  */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SenderInfo failed: corpID is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[1];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode OnLSC_SenderInfo: truncating 64 bit into into 32 bit int for field corpID");
	}
	corpID = int_1->value;
	/*  2: who (could be this list, or could be just an integer ID)  */
	if(!tuple0->items[2]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SenderInfo failed: list2 is not a list: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list2 = (PyRepList *) tuple0->items[2];
	if(list2->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SenderInfo failed: list2 is the wrong size: expected 3, but got %d", list2->items.size());
		delete packet;
		return(false);
	}

	if(!list2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SenderInfo failed: senderID is not an int: %s", list2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) list2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode OnLSC_SenderInfo: truncating 64 bit into into 32 bit int for field senderID");
	}
	senderID = int_3->value;
	if(!list2->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SenderInfo failed: senderName is not a string: %s", list2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_4 = (PyRepString *) list2->items[1];
	senderName = string_4->value;
	if(!list2->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SenderInfo failed: senderType is not an int: %s", list2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) list2->items[2];
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode OnLSC_SenderInfo: truncating 64 bit into into 32 bit int for field senderType");
	}
	senderType = int_5->value;
	/*  3: whoRole  */
	if(!tuple0->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SenderInfo failed: role is not an int: %s", tuple0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_6 = (PyRepInteger *) tuple0->items[3];
	if(int_6->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode OnLSC_SenderInfo: truncating 64 bit into into 32 bit int for field role");
	}
	role = int_6->value;
	/*  4: whoCorpRole  */
	if(!tuple0->items[4]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SenderInfo failed: corp_role is not an int: %s", tuple0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_7 = (PyRepInteger *) tuple0->items[4];
	if(int_7->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode OnLSC_SenderInfo: truncating 64 bit into into 32 bit int for field corp_role");
	}
	corp_role = int_7->value;

	delete packet;
	return(true);
}

OnLSC_SenderInfo *OnLSC_SenderInfo::Clone() const {
	OnLSC_SenderInfo *res = new OnLSC_SenderInfo;
	res->CloneFrom(this);
	return(res);
}

void OnLSC_SenderInfo::CloneFrom(const OnLSC_SenderInfo *from) {
	/*  0: whoAllianceID  */
	/*  1: whoCorpID  */
	corpID = from->corpID;
	/*  2: who (could be this list, or could be just an integer ID)  */
	senderID = from->senderID;
	senderName = from->senderName;
	senderType = from->senderType;
	/*  3: whoRole  */
	role = from->role;
	/*  4: whoCorpRole  */
	corp_role = from->corp_role;
	
}


NotifyOnLSC::NotifyOnLSC() {
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	channelID = NULL;
	/*  1: estimated member count  */
	member_count = 0;
	/*  2  */
	method = "";
	/*  3  */
	sender = NULL;
	/*  4  */
	arguments = NULL;
}

NotifyOnLSC::~NotifyOnLSC() {
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	delete channelID;
	/*  1: estimated member count  */
	/*  2  */
	/*  3  */
	delete sender;
	/*  4  */
	delete arguments;
}

void NotifyOnLSC::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotifyOnLSC", pfx);
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	_log(l_type, "%schannelID:", pfx);
	std::string channelID_n(pfx);
	channelID_n += "    ";
	if(channelID == NULL) {
		_log(l_type, "%sERROR: NULL REP!", channelID_n.c_str());
	} else {
		channelID->Dump(l_type, channelID_n.c_str());
	}
	/*  1: estimated member count  */
	_log(l_type, "%smember_count=%lu", pfx, member_count);
	/*  2  */
	_log(l_type, "%smethod='%s'", pfx, method.c_str());
	/*  3  */
	_log(l_type, "%ssender:", pfx);
	std::string sender_n(pfx);
	sender_n += "    ";
	if(sender == NULL) {
		_log(l_type, "%sERROR: NULL OBJECT!", sender_n.c_str());
	} else {
		sender->Dump(l_type, sender_n.c_str());
	}
	/*  4  */
	_log(l_type, "%sarguments:", pfx);
	std::string arguments_n(pfx);
	arguments_n += "    ";
	if(arguments == NULL) {
		_log(l_type, "%sERROR: NULL TUPLE!", arguments_n.c_str());
	} else {
		arguments->Dump(l_type, arguments_n.c_str());
	}
}

PyRepTuple *NotifyOnLSC::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	if(channelID == NULL) {
		_log(NET__PACKET_ERROR, "Encode NotifyOnLSC: channelID is NULL! hacking in a PyRepNone");
		channelID = new PyRepNone();
	}
	tuple0->items[0] = channelID->Clone();
	/*  1: estimated member count  */
	tuple0->items[1] = new PyRepInteger(member_count);
	/*  2  */
	tuple0->items[2] = new PyRepString(method);
	/*  3  */
	if(sender == NULL) {
		_log(NET__PACKET_ERROR, "Encode NotifyOnLSC: sender is NULL! hacking in a PyRepNone");
		tuple0->items[3] = new PyRepNone();
	} else {
		tuple0->items[3] = sender->Encode();
	}
	/*  4  */
	if(arguments == NULL) {
		_log(NET__PACKET_ERROR, "Encode NotifyOnLSC: arguments is NULL! hacking in an empty tuple.");
		arguments = new PyRepTuple(0);
	}
	tuple0->items[4] = arguments->Clone();
	res = tuple0;
	

	return(res);
}

PyRepTuple *NotifyOnLSC::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	if(channelID == NULL) {
		_log(NET__PACKET_ERROR, "Encode NotifyOnLSC: channelID is NULL! hacking in a PyRepNone");
		channelID = new PyRepNone();
	}
	tuple0->items[0] = channelID;
	channelID = NULL;
	/*  1: estimated member count  */
	tuple0->items[1] = new PyRepInteger(member_count);
	/*  2  */
	tuple0->items[2] = new PyRepString(method);
	/*  3  */
	if(sender == NULL) {
		_log(NET__PACKET_ERROR, "Encode NotifyOnLSC: sender is NULL! hacking in a PyRepNone");
		tuple0->items[3] = new PyRepNone();
	} else {
		tuple0->items[3] = sender->FastEncode();
	}
	/*  4  */
	if(arguments == NULL) {
		_log(NET__PACKET_ERROR, "Encode NotifyOnLSC: arguments is NULL! hacking in an empty tuple.");
		arguments = new PyRepTuple(0);
	}
	
	PyRepTuple *list1 = new PyRepTuple(0);
	list1->items = arguments->items;
	arguments->items.clear();
	tuple0->items[4] = list1;
	res = tuple0;
	

	return(res);
}

bool NotifyOnLSC::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool NotifyOnLSC::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnLSC failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 5) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnLSC failed: tuple0 is the wrong size: expected 5, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	delete channelID;
	channelID = tuple0->items[0];
	tuple0->items[0] = NULL;
	
	/*  1: estimated member count  */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnLSC failed: member_count is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[1];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode NotifyOnLSC: truncating 64 bit into into 32 bit int for field member_count");
	}
	member_count = int_1->value;
	/*  2  */
	if(!tuple0->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnLSC failed: method is not a string: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple0->items[2];
	method = string_2->value;
	/*  3  */
	PyRep *rep_3 = tuple0->items[3];
	tuple0->items[3] = NULL;
	delete sender;
	sender = new OnLSC_SenderInfo;
	if(!sender->Decode(&rep_3)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnLSC failed: unable to decode element sender");
		delete packet;
		return(false);
	}
	
	/*  4  */
	if(!tuple0->items[4]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnLSC failed: arguments is not a tuple: %s", tuple0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	arguments = (PyRepTuple *) tuple0->items[4];
	tuple0->items[4] = NULL;
	

	delete packet;
	return(true);
}

NotifyOnLSC *NotifyOnLSC::Clone() const {
	NotifyOnLSC *res = new NotifyOnLSC;
	res->CloneFrom(this);
	return(res);
}

void NotifyOnLSC::CloneFrom(const NotifyOnLSC *from) {
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	delete channelID;
	if(from->channelID == NULL) {
		channelID = NULL;
	} else {
		channelID = from->channelID->Clone();
	}
	/*  1: estimated member count  */
	member_count = from->member_count;
	/*  2  */
	method = from->method;
	/*  3  */
	delete sender;
	if(from->sender == NULL) {
		sender = NULL;
	} else {
		sender = from->sender->Clone();
	}
	/*  4  */
	delete arguments;
	if(from->arguments == NULL) {
		arguments = NULL;
	} else {
		arguments = from->arguments->TypedClone();
	}
	
}


OnLSC_SendMessage::OnLSC_SendMessage() {
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	channelID = NULL;
	/*  1  */
	member_count = 0;
	/*  2  */
	method = "SendMessage";
	/*  3: sender info  */
	sender = NULL;
	/*  4  */
	/*  0  */
	message = "";
}

OnLSC_SendMessage::~OnLSC_SendMessage() {
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	delete channelID;
	/*  1  */
	/*  2  */
	/*  3: sender info  */
	delete sender;
	/*  4  */
	/*  0  */
}

void OnLSC_SendMessage::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sOnLSC_SendMessage", pfx);
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	_log(l_type, "%schannelID:", pfx);
	std::string channelID_n(pfx);
	channelID_n += "    ";
	if(channelID == NULL) {
		_log(l_type, "%sERROR: NULL REP!", channelID_n.c_str());
	} else {
		channelID->Dump(l_type, channelID_n.c_str());
	}
	/*  1  */
	_log(l_type, "%smember_count=%lu", pfx, member_count);
	/*  2  */
	_log(l_type, "%smethod='%s'", pfx, method.c_str());
	/*  3: sender info  */
	_log(l_type, "%ssender:", pfx);
	std::string sender_n(pfx);
	sender_n += "    ";
	if(sender == NULL) {
		_log(l_type, "%sERROR: NULL OBJECT!", sender_n.c_str());
	} else {
		sender->Dump(l_type, sender_n.c_str());
	}
	/*  4  */
	/*  0  */
	_log(l_type, "%smessage='%s'", pfx, message.c_str());
}

PyRepTuple *OnLSC_SendMessage::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	if(channelID == NULL) {
		_log(NET__PACKET_ERROR, "Encode OnLSC_SendMessage: channelID is NULL! hacking in a PyRepNone");
		channelID = new PyRepNone();
	}
	tuple0->items[0] = channelID->Clone();
	/*  1  */
	tuple0->items[1] = new PyRepInteger(member_count);
	/*  2  */
	tuple0->items[2] = new PyRepString(method);
	/*  3: sender info  */
	if(sender == NULL) {
		_log(NET__PACKET_ERROR, "Encode OnLSC_SendMessage: sender is NULL! hacking in a PyRepNone");
		tuple0->items[3] = new PyRepNone();
	} else {
		tuple0->items[3] = sender->Encode();
	}
	/*  4  */
	PyRepTuple *tuple1 = new PyRepTuple(1);
	/*  0  */
	tuple1->items[0] = new PyRepString(message);
	tuple0->items[4] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *OnLSC_SendMessage::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	if(channelID == NULL) {
		_log(NET__PACKET_ERROR, "Encode OnLSC_SendMessage: channelID is NULL! hacking in a PyRepNone");
		channelID = new PyRepNone();
	}
	tuple0->items[0] = channelID;
	channelID = NULL;
	/*  1  */
	tuple0->items[1] = new PyRepInteger(member_count);
	/*  2  */
	tuple0->items[2] = new PyRepString(method);
	/*  3: sender info  */
	if(sender == NULL) {
		_log(NET__PACKET_ERROR, "Encode OnLSC_SendMessage: sender is NULL! hacking in a PyRepNone");
		tuple0->items[3] = new PyRepNone();
	} else {
		tuple0->items[3] = sender->FastEncode();
	}
	/*  4  */
	PyRepTuple *tuple1 = new PyRepTuple(1);
	/*  0  */
	tuple1->items[0] = new PyRepString(message);
	tuple0->items[4] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool OnLSC_SendMessage::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool OnLSC_SendMessage::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SendMessage failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 5) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SendMessage failed: tuple0 is the wrong size: expected 5, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	delete channelID;
	channelID = tuple0->items[0];
	tuple0->items[0] = NULL;
	
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SendMessage failed: member_count is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[1];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode OnLSC_SendMessage: truncating 64 bit into into 32 bit int for field member_count");
	}
	member_count = int_1->value;
	/*  2  */
	if(!tuple0->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SendMessage failed: method is not a string: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple0->items[2];
	method = string_2->value;
	/*  3: sender info  */
	PyRep *rep_3 = tuple0->items[3];
	tuple0->items[3] = NULL;
	delete sender;
	sender = new OnLSC_SenderInfo;
	if(!sender->Decode(&rep_3)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SendMessage failed: unable to decode element sender");
		delete packet;
		return(false);
	}
	
	/*  4  */
	if(!tuple0->items[4]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SendMessage failed: tuple4 is the wrong type: %s", tuple0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple4 = (PyRepTuple *) tuple0->items[4];
	if(tuple4->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SendMessage failed: tuple4 is the wrong size: expected 1, but got %d", tuple4->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple4->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SendMessage failed: message is not a string: %s", tuple4->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_5 = (PyRepString *) tuple4->items[0];
	message = string_5->value;

	delete packet;
	return(true);
}

OnLSC_SendMessage *OnLSC_SendMessage::Clone() const {
	OnLSC_SendMessage *res = new OnLSC_SendMessage;
	res->CloneFrom(this);
	return(res);
}

void OnLSC_SendMessage::CloneFrom(const OnLSC_SendMessage *from) {
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	delete channelID;
	if(from->channelID == NULL) {
		channelID = NULL;
	} else {
		channelID = from->channelID->Clone();
	}
	/*  1  */
	member_count = from->member_count;
	/*  2  */
	method = from->method;
	/*  3: sender info  */
	delete sender;
	if(from->sender == NULL) {
		sender = NULL;
	} else {
		sender = from->sender->Clone();
	}
	/*  4  */
	/*  0  */
	message = from->message;
	
}


OnLSC_JoinChannel::OnLSC_JoinChannel() {
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	channelID = NULL;
	/*  1  */
	member_count = 0;
	/*  2  */
	method = "JoinChannel";
	/*  3: sender info  */
	sender = NULL;
	/*  4  */
}

OnLSC_JoinChannel::~OnLSC_JoinChannel() {
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	delete channelID;
	/*  1  */
	/*  2  */
	/*  3: sender info  */
	delete sender;
	/*  4  */
}

void OnLSC_JoinChannel::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sOnLSC_JoinChannel", pfx);
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	_log(l_type, "%schannelID:", pfx);
	std::string channelID_n(pfx);
	channelID_n += "    ";
	if(channelID == NULL) {
		_log(l_type, "%sERROR: NULL REP!", channelID_n.c_str());
	} else {
		channelID->Dump(l_type, channelID_n.c_str());
	}
	/*  1  */
	_log(l_type, "%smember_count=%lu", pfx, member_count);
	/*  2  */
	_log(l_type, "%smethod='%s'", pfx, method.c_str());
	/*  3: sender info  */
	_log(l_type, "%ssender:", pfx);
	std::string sender_n(pfx);
	sender_n += "    ";
	if(sender == NULL) {
		_log(l_type, "%sERROR: NULL OBJECT!", sender_n.c_str());
	} else {
		sender->Dump(l_type, sender_n.c_str());
	}
	/*  4  */
}

PyRepTuple *OnLSC_JoinChannel::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	if(channelID == NULL) {
		_log(NET__PACKET_ERROR, "Encode OnLSC_JoinChannel: channelID is NULL! hacking in a PyRepNone");
		channelID = new PyRepNone();
	}
	tuple0->items[0] = channelID->Clone();
	/*  1  */
	tuple0->items[1] = new PyRepInteger(member_count);
	/*  2  */
	tuple0->items[2] = new PyRepString(method);
	/*  3: sender info  */
	if(sender == NULL) {
		_log(NET__PACKET_ERROR, "Encode OnLSC_JoinChannel: sender is NULL! hacking in a PyRepNone");
		tuple0->items[3] = new PyRepNone();
	} else {
		tuple0->items[3] = sender->Encode();
	}
	/*  4  */
	PyRepTuple *tuple1 = new PyRepTuple(0);
	tuple0->items[4] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *OnLSC_JoinChannel::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	if(channelID == NULL) {
		_log(NET__PACKET_ERROR, "Encode OnLSC_JoinChannel: channelID is NULL! hacking in a PyRepNone");
		channelID = new PyRepNone();
	}
	tuple0->items[0] = channelID;
	channelID = NULL;
	/*  1  */
	tuple0->items[1] = new PyRepInteger(member_count);
	/*  2  */
	tuple0->items[2] = new PyRepString(method);
	/*  3: sender info  */
	if(sender == NULL) {
		_log(NET__PACKET_ERROR, "Encode OnLSC_JoinChannel: sender is NULL! hacking in a PyRepNone");
		tuple0->items[3] = new PyRepNone();
	} else {
		tuple0->items[3] = sender->FastEncode();
	}
	/*  4  */
	PyRepTuple *tuple1 = new PyRepTuple(0);
	tuple0->items[4] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool OnLSC_JoinChannel::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool OnLSC_JoinChannel::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_JoinChannel failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 5) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_JoinChannel failed: tuple0 is the wrong size: expected 5, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	delete channelID;
	channelID = tuple0->items[0];
	tuple0->items[0] = NULL;
	
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_JoinChannel failed: member_count is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[1];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode OnLSC_JoinChannel: truncating 64 bit into into 32 bit int for field member_count");
	}
	member_count = int_1->value;
	/*  2  */
	if(!tuple0->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_JoinChannel failed: method is not a string: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple0->items[2];
	method = string_2->value;
	/*  3: sender info  */
	PyRep *rep_3 = tuple0->items[3];
	tuple0->items[3] = NULL;
	delete sender;
	sender = new OnLSC_SenderInfo;
	if(!sender->Decode(&rep_3)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_JoinChannel failed: unable to decode element sender");
		delete packet;
		return(false);
	}
	
	/*  4  */
	if(!tuple0->items[4]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_JoinChannel failed: tuple4 is the wrong type: %s", tuple0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple4 = (PyRepTuple *) tuple0->items[4];
	if(tuple4->items.size() != 0) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_JoinChannel failed: tuple4 is the wrong size: expected 0, but got %d", tuple4->items.size());
		delete packet;
		return(false);
	}


	delete packet;
	return(true);
}

OnLSC_JoinChannel *OnLSC_JoinChannel::Clone() const {
	OnLSC_JoinChannel *res = new OnLSC_JoinChannel;
	res->CloneFrom(this);
	return(res);
}

void OnLSC_JoinChannel::CloneFrom(const OnLSC_JoinChannel *from) {
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	delete channelID;
	if(from->channelID == NULL) {
		channelID = NULL;
	} else {
		channelID = from->channelID->Clone();
	}
	/*  1  */
	member_count = from->member_count;
	/*  2  */
	method = from->method;
	/*  3: sender info  */
	delete sender;
	if(from->sender == NULL) {
		sender = NULL;
	} else {
		sender = from->sender->Clone();
	}
	/*  4  */
	
}


OnLSC_LeaveChannel::OnLSC_LeaveChannel() {
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	channelID = NULL;
	/*  1  */
	member_count = 0;
	/*  2  */
	method = "LeaveChannel";
	/*  3: sender info  */
	sender = NULL;
	/*  4  */
}

OnLSC_LeaveChannel::~OnLSC_LeaveChannel() {
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	delete channelID;
	/*  1  */
	/*  2  */
	/*  3: sender info  */
	delete sender;
	/*  4  */
}

void OnLSC_LeaveChannel::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sOnLSC_LeaveChannel", pfx);
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	_log(l_type, "%schannelID:", pfx);
	std::string channelID_n(pfx);
	channelID_n += "    ";
	if(channelID == NULL) {
		_log(l_type, "%sERROR: NULL REP!", channelID_n.c_str());
	} else {
		channelID->Dump(l_type, channelID_n.c_str());
	}
	/*  1  */
	_log(l_type, "%smember_count=%lu", pfx, member_count);
	/*  2  */
	_log(l_type, "%smethod='%s'", pfx, method.c_str());
	/*  3: sender info  */
	_log(l_type, "%ssender:", pfx);
	std::string sender_n(pfx);
	sender_n += "    ";
	if(sender == NULL) {
		_log(l_type, "%sERROR: NULL OBJECT!", sender_n.c_str());
	} else {
		sender->Dump(l_type, sender_n.c_str());
	}
	/*  4  */
}

PyRepTuple *OnLSC_LeaveChannel::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	if(channelID == NULL) {
		_log(NET__PACKET_ERROR, "Encode OnLSC_LeaveChannel: channelID is NULL! hacking in a PyRepNone");
		channelID = new PyRepNone();
	}
	tuple0->items[0] = channelID->Clone();
	/*  1  */
	tuple0->items[1] = new PyRepInteger(member_count);
	/*  2  */
	tuple0->items[2] = new PyRepString(method);
	/*  3: sender info  */
	if(sender == NULL) {
		_log(NET__PACKET_ERROR, "Encode OnLSC_LeaveChannel: sender is NULL! hacking in a PyRepNone");
		tuple0->items[3] = new PyRepNone();
	} else {
		tuple0->items[3] = sender->Encode();
	}
	/*  4  */
	PyRepTuple *tuple1 = new PyRepTuple(0);
	tuple0->items[4] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *OnLSC_LeaveChannel::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	if(channelID == NULL) {
		_log(NET__PACKET_ERROR, "Encode OnLSC_LeaveChannel: channelID is NULL! hacking in a PyRepNone");
		channelID = new PyRepNone();
	}
	tuple0->items[0] = channelID;
	channelID = NULL;
	/*  1  */
	tuple0->items[1] = new PyRepInteger(member_count);
	/*  2  */
	tuple0->items[2] = new PyRepString(method);
	/*  3: sender info  */
	if(sender == NULL) {
		_log(NET__PACKET_ERROR, "Encode OnLSC_LeaveChannel: sender is NULL! hacking in a PyRepNone");
		tuple0->items[3] = new PyRepNone();
	} else {
		tuple0->items[3] = sender->FastEncode();
	}
	/*  4  */
	PyRepTuple *tuple1 = new PyRepTuple(0);
	tuple0->items[4] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool OnLSC_LeaveChannel::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool OnLSC_LeaveChannel::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_LeaveChannel failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 5) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_LeaveChannel failed: tuple0 is the wrong size: expected 5, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	delete channelID;
	channelID = tuple0->items[0];
	tuple0->items[0] = NULL;
	
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_LeaveChannel failed: member_count is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[1];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode OnLSC_LeaveChannel: truncating 64 bit into into 32 bit int for field member_count");
	}
	member_count = int_1->value;
	/*  2  */
	if(!tuple0->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_LeaveChannel failed: method is not a string: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple0->items[2];
	method = string_2->value;
	/*  3: sender info  */
	PyRep *rep_3 = tuple0->items[3];
	tuple0->items[3] = NULL;
	delete sender;
	sender = new OnLSC_SenderInfo;
	if(!sender->Decode(&rep_3)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_LeaveChannel failed: unable to decode element sender");
		delete packet;
		return(false);
	}
	
	/*  4  */
	if(!tuple0->items[4]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_LeaveChannel failed: tuple4 is the wrong type: %s", tuple0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple4 = (PyRepTuple *) tuple0->items[4];
	if(tuple4->items.size() != 0) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_LeaveChannel failed: tuple4 is the wrong size: expected 0, but got %d", tuple4->items.size());
		delete packet;
		return(false);
	}


	delete packet;
	return(true);
}

OnLSC_LeaveChannel *OnLSC_LeaveChannel::Clone() const {
	OnLSC_LeaveChannel *res = new OnLSC_LeaveChannel;
	res->CloneFrom(this);
	return(res);
}

void OnLSC_LeaveChannel::CloneFrom(const OnLSC_LeaveChannel *from) {
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	delete channelID;
	if(from->channelID == NULL) {
		channelID = NULL;
	} else {
		channelID = from->channelID->Clone();
	}
	/*  1  */
	member_count = from->member_count;
	/*  2  */
	method = from->method;
	/*  3: sender info  */
	delete sender;
	if(from->sender == NULL) {
		sender = NULL;
	} else {
		sender = from->sender->Clone();
	}
	/*  4  */
	
}


CallLeaveChannels::CallLeaveChannels() {
	/*  0  */
	/*  1  */
	unsubscribe = 0;
}

CallLeaveChannels::~CallLeaveChannels() {
	/*  0  */
	/*  1  */
}

void CallLeaveChannels::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallLeaveChannels", pfx);
	/*  0  */
	_log(l_type, "%schannels: ", pfx);
	std::string channels_n(pfx);
	channels_n += "    ";
	channels.Dump(l_type, channels_n.c_str());
	/*  1  */
	_log(l_type, "%sunsubscribe=%lu", pfx, unsubscribe);
}

PyRepTuple *CallLeaveChannels::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = channels.Clone();
	/*  1  */
	tuple0->items[1] = new PyRepInteger(unsubscribe);
	res = tuple0;
	

	return(res);
}

PyRepTuple *CallLeaveChannels::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	
	PyRepList *list1 = new PyRepList();
	list1->items = channels.items;
	channels.items.clear();
	tuple0->items[0] = list1;
	/*  1  */
	tuple0->items[1] = new PyRepInteger(unsubscribe);
	res = tuple0;
	

	return(res);
}

bool CallLeaveChannels::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallLeaveChannels::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallLeaveChannels failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode CallLeaveChannels failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode CallLeaveChannels failed: channels is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_channels = (PyRepList *) tuple0->items[0];	channels.items = list_channels->items;
	list_channels->items.clear();
	
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallLeaveChannels failed: unsubscribe is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[1];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallLeaveChannels: truncating 64 bit into into 32 bit int for field unsubscribe");
	}
	unsubscribe = int_1->value;

	delete packet;
	return(true);
}

CallLeaveChannels *CallLeaveChannels::Clone() const {
	CallLeaveChannels *res = new CallLeaveChannels;
	res->CloneFrom(this);
	return(res);
}

void CallLeaveChannels::CloneFrom(const CallLeaveChannels *from) {
	/*  0  */
	channels.CloneFrom(&from->channels);
	/*  1  */
	unsubscribe = from->unsubscribe;
	
}


CallLeaveChannel::CallLeaveChannel() {
	/*  0  */
	channel = NULL;
	/*  1  */
	unsubscribe = 0;
}

CallLeaveChannel::~CallLeaveChannel() {
	/*  0  */
	delete channel;
	/*  1  */
}

void CallLeaveChannel::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallLeaveChannel", pfx);
	/*  0  */
	_log(l_type, "%schannel:", pfx);
	std::string channel_n(pfx);
	channel_n += "    ";
	if(channel == NULL) {
		_log(l_type, "%sERROR: NULL REP!", channel_n.c_str());
	} else {
		channel->Dump(l_type, channel_n.c_str());
	}
	/*  1  */
	_log(l_type, "%sunsubscribe=%lu", pfx, unsubscribe);
}

PyRepTuple *CallLeaveChannel::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	if(channel == NULL) {
		_log(NET__PACKET_ERROR, "Encode CallLeaveChannel: channel is NULL! hacking in a PyRepNone");
		channel = new PyRepNone();
	}
	tuple0->items[0] = channel->Clone();
	/*  1  */
	tuple0->items[1] = new PyRepInteger(unsubscribe);
	res = tuple0;
	

	return(res);
}

PyRepTuple *CallLeaveChannel::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	if(channel == NULL) {
		_log(NET__PACKET_ERROR, "Encode CallLeaveChannel: channel is NULL! hacking in a PyRepNone");
		channel = new PyRepNone();
	}
	tuple0->items[0] = channel;
	channel = NULL;
	/*  1  */
	tuple0->items[1] = new PyRepInteger(unsubscribe);
	res = tuple0;
	

	return(res);
}

bool CallLeaveChannel::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallLeaveChannel::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallLeaveChannel failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode CallLeaveChannel failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	delete channel;
	channel = tuple0->items[0];
	tuple0->items[0] = NULL;
	
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallLeaveChannel failed: unsubscribe is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[1];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallLeaveChannel: truncating 64 bit into into 32 bit int for field unsubscribe");
	}
	unsubscribe = int_1->value;

	delete packet;
	return(true);
}

CallLeaveChannel *CallLeaveChannel::Clone() const {
	CallLeaveChannel *res = new CallLeaveChannel;
	res->CloneFrom(this);
	return(res);
}

void CallLeaveChannel::CloneFrom(const CallLeaveChannel *from) {
	/*  0  */
	delete channel;
	if(from->channel == NULL) {
		channel = NULL;
	} else {
		channel = from->channel->Clone();
	}
	/*  1  */
	unsubscribe = from->unsubscribe;
	
}


Call_Page::Call_Page() {
	subject = "";
	body = "";
}

Call_Page::~Call_Page() {
}

void Call_Page::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_Page", pfx);
	_log(l_type, "%srecipients: Integer list with %d enetires", pfx, recipients.size());
	std::vector<uint32>::const_iterator recipients_cur, recipients_end;
	recipients_cur = recipients.begin();
	recipients_end = recipients.end();
	int recipients_index;
	for(recipients_index = 0; recipients_cur != recipients_end; recipients_cur++, recipients_index++) {
		_log(l_type, "%s   [%02d] %d", pfx, recipients_index, *recipients_cur);
	}
	
	_log(l_type, "%ssubject='%s'", pfx, subject.c_str());
	_log(l_type, "%sbody='%s'", pfx, body.c_str());
}

PyRepTuple *Call_Page::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator recipients_cur, recipients_end;
	recipients_cur = recipients.begin();
	recipients_end = recipients.end();
	for(; recipients_cur != recipients_end; recipients_cur++) {
		list1->items.push_back(
			new PyRepInteger(*recipients_cur)
		);
	}
	tuple0->items[0] = list1;
	
	tuple0->items[1] = new PyRepString(subject);
	tuple0->items[2] = new PyRepString(body);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_Page::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator recipients_cur, recipients_end;
	recipients_cur = recipients.begin();
	recipients_end = recipients.end();
	for(; recipients_cur != recipients_end; recipients_cur++) {
		list1->items.push_back(
			new PyRepInteger(*recipients_cur)
		);
	}
	tuple0->items[0] = list1;
	
	tuple0->items[1] = new PyRepString(subject);
	tuple0->items[2] = new PyRepString(body);
	res = tuple0;
	

	return(res);
}

bool Call_Page::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_Page::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_Page failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode Call_Page failed: tuple0 is the wrong size: expected 3, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Call_Page failed: recipients is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	recipients.clear();
	PyRepList *list_1 = (PyRepList *) tuple0->items[0];
	PyRepList::iterator recipients_cur, recipients_end;
	recipients_cur = list_1->items.begin();
	recipients_end = list_1->items.end();
	int recipients_index;
	for(recipients_index = 0; recipients_cur != recipients_end; recipients_cur++, recipients_index++) {
		if(!(*recipients_cur)->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode Call_Page failed: Element %d in list recipients is not an integer: %s", recipients_index, (*recipients_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *t = (PyRepInteger *) (*recipients_cur);
		if(t->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode Call_Page: truncating 64 bit into into 32 bit int for item %d in field recipients", recipients_index);
		}
		recipients.push_back(t->value);
	}

	if(!tuple0->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Call_Page failed: subject is not a string: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple0->items[1];
	subject = string_2->value;
	if(!tuple0->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Call_Page failed: body is not a string: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) tuple0->items[2];
	body = string_3->value;

	delete packet;
	return(true);
}

Call_Page *Call_Page::Clone() const {
	Call_Page *res = new Call_Page;
	res->CloneFrom(this);
	return(res);
}

void Call_Page::CloneFrom(const Call_Page *from) {
	recipients = from->recipients;
	subject = from->subject;
	body = from->body;
	
}


NotifyOnMessage::NotifyOnMessage() {
	/*  1: messageID: this might be a more complex type in the future.   */
	messageID = 0;
	senderID = 0;
	subject = "";
	sentTime = 0;
	/*  not sure _exactly_ what timestamp this should be  */
}

NotifyOnMessage::~NotifyOnMessage() {
	/*  1: messageID: this might be a more complex type in the future.   */
	/*  not sure _exactly_ what timestamp this should be  */
}

void NotifyOnMessage::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotifyOnMessage", pfx);
	_log(l_type, "%srecipients: Integer list with %d enetires", pfx, recipients.size());
	std::vector<uint32>::const_iterator recipients_cur, recipients_end;
	recipients_cur = recipients.begin();
	recipients_end = recipients.end();
	int recipients_index;
	for(recipients_index = 0; recipients_cur != recipients_end; recipients_cur++, recipients_index++) {
		_log(l_type, "%s   [%02d] %d", pfx, recipients_index, *recipients_cur);
	}
	
	/*  1: messageID: this might be a more complex type in the future.   */
	_log(l_type, "%smessageID=%lu", pfx, messageID);
	_log(l_type, "%ssenderID=%lu", pfx, senderID);
	_log(l_type, "%ssubject='%s'", pfx, subject.c_str());
	_log(l_type, "%ssentTime=" I64u, pfx, sentTime);
	/*  not sure _exactly_ what timestamp this should be  */
}

PyRepTuple *NotifyOnMessage::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator recipients_cur, recipients_end;
	recipients_cur = recipients.begin();
	recipients_end = recipients.end();
	for(; recipients_cur != recipients_end; recipients_cur++) {
		list1->items.push_back(
			new PyRepInteger(*recipients_cur)
		);
	}
	tuple0->items[0] = list1;
	
	/*  1: messageID: this might be a more complex type in the future.   */
	tuple0->items[1] = new PyRepInteger(messageID);
	tuple0->items[2] = new PyRepInteger(senderID);
	tuple0->items[3] = new PyRepString(subject);
	tuple0->items[4] = new PyRepInteger(sentTime);
	/*  not sure _exactly_ what timestamp this should be  */
	res = tuple0;
	

	return(res);
}

PyRepTuple *NotifyOnMessage::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator recipients_cur, recipients_end;
	recipients_cur = recipients.begin();
	recipients_end = recipients.end();
	for(; recipients_cur != recipients_end; recipients_cur++) {
		list1->items.push_back(
			new PyRepInteger(*recipients_cur)
		);
	}
	tuple0->items[0] = list1;
	
	/*  1: messageID: this might be a more complex type in the future.   */
	tuple0->items[1] = new PyRepInteger(messageID);
	tuple0->items[2] = new PyRepInteger(senderID);
	tuple0->items[3] = new PyRepString(subject);
	tuple0->items[4] = new PyRepInteger(sentTime);
	/*  not sure _exactly_ what timestamp this should be  */
	res = tuple0;
	

	return(res);
}

bool NotifyOnMessage::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool NotifyOnMessage::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnMessage failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 5) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnMessage failed: tuple0 is the wrong size: expected 5, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnMessage failed: recipients is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	recipients.clear();
	PyRepList *list_1 = (PyRepList *) tuple0->items[0];
	PyRepList::iterator recipients_cur, recipients_end;
	recipients_cur = list_1->items.begin();
	recipients_end = list_1->items.end();
	int recipients_index;
	for(recipients_index = 0; recipients_cur != recipients_end; recipients_cur++, recipients_index++) {
		if(!(*recipients_cur)->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode NotifyOnMessage failed: Element %d in list recipients is not an integer: %s", recipients_index, (*recipients_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *t = (PyRepInteger *) (*recipients_cur);
		if(t->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode NotifyOnMessage: truncating 64 bit into into 32 bit int for item %d in field recipients", recipients_index);
		}
		recipients.push_back(t->value);
	}

	/*  1: messageID: this might be a more complex type in the future.   */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnMessage failed: messageID is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode NotifyOnMessage: truncating 64 bit into into 32 bit int for field messageID");
	}
	messageID = int_2->value;
	if(!tuple0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnMessage failed: senderID is not an int: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple0->items[2];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode NotifyOnMessage: truncating 64 bit into into 32 bit int for field senderID");
	}
	senderID = int_3->value;
	if(!tuple0->items[3]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnMessage failed: subject is not a string: %s", tuple0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_4 = (PyRepString *) tuple0->items[3];
	subject = string_4->value;
	if(!tuple0->items[4]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnMessage failed: sentTime is not an int: %s", tuple0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_5 = (PyRepInteger *) tuple0->items[4];
	sentTime = int64_5->value;
	/*  not sure _exactly_ what timestamp this should be  */

	delete packet;
	return(true);
}

NotifyOnMessage *NotifyOnMessage::Clone() const {
	NotifyOnMessage *res = new NotifyOnMessage;
	res->CloneFrom(this);
	return(res);
}

void NotifyOnMessage::CloneFrom(const NotifyOnMessage *from) {
	recipients = from->recipients;
	/*  1: messageID: this might be a more complex type in the future.   */
	messageID = from->messageID;
	senderID = from->senderID;
	subject = from->subject;
	sentTime = from->sentTime;
	/*  not sure _exactly_ what timestamp this should be  */
	
}


Call_DeleteMessages::Call_DeleteMessages() {
	/*  most likely this could be an LSCChannelMultiDesc too...  */
	channelID = 0;
}

Call_DeleteMessages::~Call_DeleteMessages() {
	/*  most likely this could be an LSCChannelMultiDesc too...  */
}

void Call_DeleteMessages::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_DeleteMessages", pfx);
	/*  most likely this could be an LSCChannelMultiDesc too...  */
	_log(l_type, "%schannelID=%lu", pfx, channelID);
	_log(l_type, "%smessages: Integer list with %d enetires", pfx, messages.size());
	std::vector<uint32>::const_iterator messages_cur, messages_end;
	messages_cur = messages.begin();
	messages_end = messages.end();
	int messages_index;
	for(messages_index = 0; messages_cur != messages_end; messages_cur++, messages_index++) {
		_log(l_type, "%s   [%02d] %d", pfx, messages_index, *messages_cur);
	}
	
}

PyRepTuple *Call_DeleteMessages::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  most likely this could be an LSCChannelMultiDesc too...  */
	tuple0->items[0] = new PyRepInteger(channelID);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator messages_cur, messages_end;
	messages_cur = messages.begin();
	messages_end = messages.end();
	for(; messages_cur != messages_end; messages_cur++) {
		list1->items.push_back(
			new PyRepInteger(*messages_cur)
		);
	}
	tuple0->items[1] = list1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_DeleteMessages::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  most likely this could be an LSCChannelMultiDesc too...  */
	tuple0->items[0] = new PyRepInteger(channelID);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator messages_cur, messages_end;
	messages_cur = messages.begin();
	messages_end = messages.end();
	for(; messages_cur != messages_end; messages_cur++) {
		list1->items.push_back(
			new PyRepInteger(*messages_cur)
		);
	}
	tuple0->items[1] = list1;
	
	res = tuple0;
	

	return(res);
}

bool Call_DeleteMessages::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_DeleteMessages::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_DeleteMessages failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Call_DeleteMessages failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  most likely this could be an LSCChannelMultiDesc too...  */
	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_DeleteMessages failed: channelID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_DeleteMessages: truncating 64 bit into into 32 bit int for field channelID");
	}
	channelID = int_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Call_DeleteMessages failed: messages is not a list: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	messages.clear();
	PyRepList *list_2 = (PyRepList *) tuple0->items[1];
	PyRepList::iterator messages_cur, messages_end;
	messages_cur = list_2->items.begin();
	messages_end = list_2->items.end();
	int messages_index;
	for(messages_index = 0; messages_cur != messages_end; messages_cur++, messages_index++) {
		if(!(*messages_cur)->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode Call_DeleteMessages failed: Element %d in list messages is not an integer: %s", messages_index, (*messages_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *t = (PyRepInteger *) (*messages_cur);
		if(t->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode Call_DeleteMessages: truncating 64 bit into into 32 bit int for item %d in field messages", messages_index);
		}
		messages.push_back(t->value);
	}


	delete packet;
	return(true);
}

Call_DeleteMessages *Call_DeleteMessages::Clone() const {
	Call_DeleteMessages *res = new Call_DeleteMessages;
	res->CloneFrom(this);
	return(res);
}

void Call_DeleteMessages::CloneFrom(const Call_DeleteMessages *from) {
	/*  most likely this could be an LSCChannelMultiDesc too...  */
	channelID = from->channelID;
	messages = from->messages;
	
}


Rsp_GetEVEMailDetails::Rsp_GetEVEMailDetails() {
	/*  first the actul message  */
	/* object of type util.Row */
	head_messageID = "messageID";
	head_senderID = "senderID";
	head_subject = "subject";
	head_body = "body";
	head_created = "created";
	head_mimeType = "mimeType";
	head_channelID = "channelID";
	head_deleted = "deleted";
	messageID = 0;
	senderID = 0;
	subject = "";
	body = "";
	created = 0;
	/*  mimeType is a nested row... silly CCP  */
	/* object of type util.Row */
	head_mimeTypeID = "mimeTypeID";
	head_mimeType2 = "mimeType";
	head_binary = "binary";
	mimeTypeID = 0;
	mimeType = "";
	binary = 0;
	channelID = 0;
	deleted = 0;
	/*  then any attachments. this is a util.Rowset  */
	/*  this might not work due to a type1 string issue in rowclass here,
      if that is the case, then change this over to a <list> temporarily  */
}

Rsp_GetEVEMailDetails::~Rsp_GetEVEMailDetails() {
	/*  first the actul message  */
	/*  mimeType is a nested row... silly CCP  */
	/*  then any attachments. this is a util.Rowset  */
	/*  this might not work due to a type1 string issue in rowclass here,
      if that is the case, then change this over to a <list> temporarily  */
}

void Rsp_GetEVEMailDetails::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRsp_GetEVEMailDetails", pfx);
	/*  first the actul message  */
	_log(l_type, "%sObject of type util.Row:", pfx);
	_log(l_type, "%shead_messageID='%s'", pfx, head_messageID.c_str());
	_log(l_type, "%shead_senderID='%s'", pfx, head_senderID.c_str());
	_log(l_type, "%shead_subject='%s'", pfx, head_subject.c_str());
	_log(l_type, "%shead_body='%s'", pfx, head_body.c_str());
	_log(l_type, "%shead_created='%s'", pfx, head_created.c_str());
	_log(l_type, "%shead_mimeType='%s'", pfx, head_mimeType.c_str());
	_log(l_type, "%shead_channelID='%s'", pfx, head_channelID.c_str());
	_log(l_type, "%shead_deleted='%s'", pfx, head_deleted.c_str());
	_log(l_type, "%smessageID=%lu", pfx, messageID);
	_log(l_type, "%ssenderID=%lu", pfx, senderID);
	_log(l_type, "%ssubject='%s'", pfx, subject.c_str());
	_log(l_type, "%sbody='%s'", pfx, body.c_str());
	_log(l_type, "%screated=" I64u, pfx, created);
	/*  mimeType is a nested row... silly CCP  */
	_log(l_type, "%sObject of type util.Row:", pfx);
	_log(l_type, "%shead_mimeTypeID='%s'", pfx, head_mimeTypeID.c_str());
	_log(l_type, "%shead_mimeType2='%s'", pfx, head_mimeType2.c_str());
	_log(l_type, "%shead_binary='%s'", pfx, head_binary.c_str());
	_log(l_type, "%smimeTypeID=%lu", pfx, mimeTypeID);
	_log(l_type, "%smimeType='%s'", pfx, mimeType.c_str());
	_log(l_type, "%sbinary=%lu", pfx, binary);
	_log(l_type, "%schannelID=%lu", pfx, channelID);
	_log(l_type, "%sdeleted=%lu", pfx, deleted);
	/*  then any attachments. this is a util.Rowset  */
	/*  this might not work due to a type1 string issue in rowclass here,
      if that is the case, then change this over to a <list> temporarily  */
	_log(l_type, "%sattachments:", pfx);
	std::string attachments_n(pfx);
	attachments_n += "    ";
	attachments.Dump(l_type, attachments_n.c_str());
}

PyRepTuple *Rsp_GetEVEMailDetails::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  first the actul message  */
	PyRep *args1;
	PyRepDict *dict2 = new PyRepDict();
	PyRep *dict2_0;
	PyRepList *list3 = new PyRepList();
	list3->items.resize(8, NULL);
	list3->items[0] = new PyRepString(head_messageID);
	list3->items[1] = new PyRepString(head_senderID);
	list3->items[2] = new PyRepString(head_subject);
	list3->items[3] = new PyRepString(head_body);
	list3->items[4] = new PyRepString(head_created);
	list3->items[5] = new PyRepString(head_mimeType);
	list3->items[6] = new PyRepString(head_channelID);
	list3->items[7] = new PyRepString(head_deleted);
	dict2_0 = list3;
	
	dict2->items[
		new PyRepString("header")
	] = dict2_0;
	PyRep *dict2_1;
	PyRepList *list4 = new PyRepList();
	list4->items.resize(8, NULL);
	list4->items[0] = new PyRepInteger(messageID);
	list4->items[1] = new PyRepInteger(senderID);
	list4->items[2] = new PyRepString(subject);
	list4->items[3] = new PyRepString(body);
	list4->items[4] = new PyRepInteger(created);
	/*  mimeType is a nested row... silly CCP  */
	PyRep *args5;
	PyRepDict *dict6 = new PyRepDict();
	PyRep *dict6_0;
	PyRepList *list7 = new PyRepList();
	list7->items.resize(3, NULL);
	list7->items[0] = new PyRepString(head_mimeTypeID);
	list7->items[1] = new PyRepString(head_mimeType2);
	list7->items[2] = new PyRepString(head_binary);
	dict6_0 = list7;
	
	dict6->items[
		new PyRepString("header")
	] = dict6_0;
	PyRep *dict6_1;
	PyRepList *list8 = new PyRepList();
	list8->items.resize(3, NULL);
	list8->items[0] = new PyRepInteger(mimeTypeID);
	list8->items[1] = new PyRepString(mimeType);
	list8->items[2] = new PyRepInteger(binary);
	dict6_1 = list8;
	
	dict6->items[
		new PyRepString("line")
	] = dict6_1;
	args5 = dict6;
	
	list4->items[5] = new PyRepObject(
			"util.Row",
			args5
		);
	
	list4->items[6] = new PyRepInteger(channelID);
	list4->items[7] = new PyRepInteger(deleted);
	dict2_1 = list4;
	
	dict2->items[
		new PyRepString("line")
	] = dict2_1;
	args1 = dict2;
	
	tuple0->items[0] = new PyRepObject(
			"util.Row",
			args1
		);
	
	/*  then any attachments. this is a util.Rowset  */
	/*  this might not work due to a type1 string issue in rowclass here,
      if that is the case, then change this over to a <list> temporarily  */
		tuple0->items[1] = attachments.Encode();
	res = tuple0;
	

	return(res);
}

PyRepTuple *Rsp_GetEVEMailDetails::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  first the actul message  */
	PyRep *args1;
	PyRepDict *dict2 = new PyRepDict();
	PyRep *dict2_0;
	PyRepList *list3 = new PyRepList();
	list3->items.resize(8, NULL);
	list3->items[0] = new PyRepString(head_messageID);
	list3->items[1] = new PyRepString(head_senderID);
	list3->items[2] = new PyRepString(head_subject);
	list3->items[3] = new PyRepString(head_body);
	list3->items[4] = new PyRepString(head_created);
	list3->items[5] = new PyRepString(head_mimeType);
	list3->items[6] = new PyRepString(head_channelID);
	list3->items[7] = new PyRepString(head_deleted);
	dict2_0 = list3;
	
	dict2->items[
		new PyRepString("header")
	] = dict2_0;
	PyRep *dict2_1;
	PyRepList *list4 = new PyRepList();
	list4->items.resize(8, NULL);
	list4->items[0] = new PyRepInteger(messageID);
	list4->items[1] = new PyRepInteger(senderID);
	list4->items[2] = new PyRepString(subject);
	list4->items[3] = new PyRepString(body);
	list4->items[4] = new PyRepInteger(created);
	/*  mimeType is a nested row... silly CCP  */
	PyRep *args5;
	PyRepDict *dict6 = new PyRepDict();
	PyRep *dict6_0;
	PyRepList *list7 = new PyRepList();
	list7->items.resize(3, NULL);
	list7->items[0] = new PyRepString(head_mimeTypeID);
	list7->items[1] = new PyRepString(head_mimeType2);
	list7->items[2] = new PyRepString(head_binary);
	dict6_0 = list7;
	
	dict6->items[
		new PyRepString("header")
	] = dict6_0;
	PyRep *dict6_1;
	PyRepList *list8 = new PyRepList();
	list8->items.resize(3, NULL);
	list8->items[0] = new PyRepInteger(mimeTypeID);
	list8->items[1] = new PyRepString(mimeType);
	list8->items[2] = new PyRepInteger(binary);
	dict6_1 = list8;
	
	dict6->items[
		new PyRepString("line")
	] = dict6_1;
	args5 = dict6;
	
	list4->items[5] = new PyRepObject(
			"util.Row",
			args5
		);
	
	list4->items[6] = new PyRepInteger(channelID);
	list4->items[7] = new PyRepInteger(deleted);
	dict2_1 = list4;
	
	dict2->items[
		new PyRepString("line")
	] = dict2_1;
	args1 = dict2;
	
	tuple0->items[0] = new PyRepObject(
			"util.Row",
			args1
		);
	
	/*  then any attachments. this is a util.Rowset  */
	/*  this might not work due to a type1 string issue in rowclass here,
      if that is the case, then change this over to a <list> temporarily  */
		tuple0->items[1] = attachments.FastEncode();
	res = tuple0;
	

	return(res);
}

bool Rsp_GetEVEMailDetails::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Rsp_GetEVEMailDetails::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  first the actul message  */
	if(!tuple0->items[0]->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: obj_1 is the wrong type: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_1 = (PyRepObject *) tuple0->items[0];
	
	if(obj_1->type != "util.Row") {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: obj_1 is the wrong object type. Expected 'util.Row', got '%s'", obj_1->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_1->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: dict2 is the wrong type: %s", obj_1->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict2_not_used1 = false;
	bool dict2_not_used2 = false;
	PyRepDict *dict2 = (PyRepDict *) obj_1->arguments;
	
	PyRepDict::iterator dict2_cur, dict2_end;
	dict2_cur = dict2->items.begin();
	dict2_end = dict2->items.end();
	for(; dict2_cur != dict2_end; dict2_cur++) {
		PyRep *key__ = dict2_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: a key in dict2 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "header") {
			dict2_not_used1 = true;
	if(!dict2_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: list3 is not a list: %s", dict2_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list3 = (PyRepList *) dict2_cur->second;
	if(list3->items.size() != 8) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: list3 is the wrong size: expected 8, but got %d", list3->items.size());
		delete packet;
		return(false);
	}

	if(!list3->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: head_messageID is not a string: %s", list3->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_4 = (PyRepString *) list3->items[0];
	head_messageID = string_4->value;
	if(!list3->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: head_senderID is not a string: %s", list3->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_5 = (PyRepString *) list3->items[1];
	head_senderID = string_5->value;
	if(!list3->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: head_subject is not a string: %s", list3->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_6 = (PyRepString *) list3->items[2];
	head_subject = string_6->value;
	if(!list3->items[3]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: head_body is not a string: %s", list3->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_7 = (PyRepString *) list3->items[3];
	head_body = string_7->value;
	if(!list3->items[4]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: head_created is not a string: %s", list3->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_8 = (PyRepString *) list3->items[4];
	head_created = string_8->value;
	if(!list3->items[5]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: head_mimeType is not a string: %s", list3->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_9 = (PyRepString *) list3->items[5];
	head_mimeType = string_9->value;
	if(!list3->items[6]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: head_channelID is not a string: %s", list3->items[6]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_10 = (PyRepString *) list3->items[6];
	head_channelID = string_10->value;
	if(!list3->items[7]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: head_deleted is not a string: %s", list3->items[7]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_11 = (PyRepString *) list3->items[7];
	head_deleted = string_11->value;
		} else
		if(key_string__->value == "line") {
			dict2_not_used2 = true;
	if(!dict2_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: list12 is not a list: %s", dict2_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list12 = (PyRepList *) dict2_cur->second;
	if(list12->items.size() != 8) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: list12 is the wrong size: expected 8, but got %d", list12->items.size());
		delete packet;
		return(false);
	}

	if(!list12->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: messageID is not an int: %s", list12->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_13 = (PyRepInteger *) list12->items[0];
	if(int_13->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetEVEMailDetails: truncating 64 bit into into 32 bit int for field messageID");
	}
	messageID = int_13->value;
	if(!list12->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: senderID is not an int: %s", list12->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_14 = (PyRepInteger *) list12->items[1];
	if(int_14->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetEVEMailDetails: truncating 64 bit into into 32 bit int for field senderID");
	}
	senderID = int_14->value;
	if(!list12->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: subject is not a string: %s", list12->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_15 = (PyRepString *) list12->items[2];
	subject = string_15->value;
	if(!list12->items[3]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: body is not a string: %s", list12->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_16 = (PyRepString *) list12->items[3];
	body = string_16->value;
	if(!list12->items[4]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: created is not an int: %s", list12->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_17 = (PyRepInteger *) list12->items[4];
	created = int64_17->value;
	/*  mimeType is a nested row... silly CCP  */
	if(!list12->items[5]->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: obj_18 is the wrong type: %s", list12->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_18 = (PyRepObject *) list12->items[5];
	
	if(obj_18->type != "util.Row") {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: obj_18 is the wrong object type. Expected 'util.Row', got '%s'", obj_18->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_18->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: dict19 is the wrong type: %s", obj_18->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict19_not_used3 = false;
	bool dict19_not_used4 = false;
	PyRepDict *dict19 = (PyRepDict *) obj_18->arguments;
	
	PyRepDict::iterator dict19_cur, dict19_end;
	dict19_cur = dict19->items.begin();
	dict19_end = dict19->items.end();
	for(; dict19_cur != dict19_end; dict19_cur++) {
		PyRep *key__ = dict19_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: a key in dict19 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "header") {
			dict19_not_used3 = true;
	if(!dict19_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: list20 is not a list: %s", dict19_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list20 = (PyRepList *) dict19_cur->second;
	if(list20->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: list20 is the wrong size: expected 3, but got %d", list20->items.size());
		delete packet;
		return(false);
	}

	if(!list20->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: head_mimeTypeID is not a string: %s", list20->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_21 = (PyRepString *) list20->items[0];
	head_mimeTypeID = string_21->value;
	if(!list20->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: head_mimeType2 is not a string: %s", list20->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_22 = (PyRepString *) list20->items[1];
	head_mimeType2 = string_22->value;
	if(!list20->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: head_binary is not a string: %s", list20->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_23 = (PyRepString *) list20->items[2];
	head_binary = string_23->value;
		} else
		if(key_string__->value == "line") {
			dict19_not_used4 = true;
	if(!dict19_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: list24 is not a list: %s", dict19_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list24 = (PyRepList *) dict19_cur->second;
	if(list24->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: list24 is the wrong size: expected 3, but got %d", list24->items.size());
		delete packet;
		return(false);
	}

	if(!list24->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: mimeTypeID is not an int: %s", list24->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_25 = (PyRepInteger *) list24->items[0];
	if(int_25->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetEVEMailDetails: truncating 64 bit into into 32 bit int for field mimeTypeID");
	}
	mimeTypeID = int_25->value;
	if(!list24->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: mimeType is not a string: %s", list24->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_26 = (PyRepString *) list24->items[1];
	mimeType = string_26->value;
	if(!list24->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: binary is not an int: %s", list24->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_27 = (PyRepInteger *) list24->items[2];
	if(int_27->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetEVEMailDetails: truncating 64 bit into into 32 bit int for field binary");
	}
	binary = int_27->value;
		} else
		{
			_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: Unknown key string '%s' in dict19", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict19_not_used3) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: Missing dict entry for 'not_used3' in dict19");
		delete packet;
		return(false);
	}
	
	if(!dict19_not_used4) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: Missing dict entry for 'not_used4' in dict19");
		delete packet;
		return(false);
	}
	
	if(!list12->items[6]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: channelID is not an int: %s", list12->items[6]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_28 = (PyRepInteger *) list12->items[6];
	if(int_28->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetEVEMailDetails: truncating 64 bit into into 32 bit int for field channelID");
	}
	channelID = int_28->value;
	if(!list12->items[7]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: deleted is not an int: %s", list12->items[7]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_29 = (PyRepInteger *) list12->items[7];
	if(int_29->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetEVEMailDetails: truncating 64 bit into into 32 bit int for field deleted");
	}
	deleted = int_29->value;
		} else
		{
			_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: Unknown key string '%s' in dict2", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict2_not_used1) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: Missing dict entry for 'not_used1' in dict2");
		delete packet;
		return(false);
	}
	
	if(!dict2_not_used2) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: Missing dict entry for 'not_used2' in dict2");
		delete packet;
		return(false);
	}
	
	/*  then any attachments. this is a util.Rowset  */
	/*  this might not work due to a type1 string issue in rowclass here,
      if that is the case, then change this over to a <list> temporarily  */
	PyRep *rep_30 = tuple0->items[1];
	tuple0->items[1] = NULL;
	if(!attachments.Decode(&rep_30)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: unable to decode element attachments");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

Rsp_GetEVEMailDetails *Rsp_GetEVEMailDetails::Clone() const {
	Rsp_GetEVEMailDetails *res = new Rsp_GetEVEMailDetails;
	res->CloneFrom(this);
	return(res);
}

void Rsp_GetEVEMailDetails::CloneFrom(const Rsp_GetEVEMailDetails *from) {
	/*  first the actul message  */
	/* object of type util.Row */
	head_messageID = from->head_messageID;
	head_senderID = from->head_senderID;
	head_subject = from->head_subject;
	head_body = from->head_body;
	head_created = from->head_created;
	head_mimeType = from->head_mimeType;
	head_channelID = from->head_channelID;
	head_deleted = from->head_deleted;
	messageID = from->messageID;
	senderID = from->senderID;
	subject = from->subject;
	body = from->body;
	created = from->created;
	/*  mimeType is a nested row... silly CCP  */
	/* object of type util.Row */
	head_mimeTypeID = from->head_mimeTypeID;
	head_mimeType2 = from->head_mimeType2;
	head_binary = from->head_binary;
	mimeTypeID = from->mimeTypeID;
	mimeType = from->mimeType;
	binary = from->binary;
	channelID = from->channelID;
	deleted = from->deleted;
	/*  then any attachments. this is a util.Rowset  */
	/*  this might not work due to a type1 string issue in rowclass here,
      if that is the case, then change this over to a <list> temporarily  */
	attachments.CloneFrom(&from->attachments);
	
}


Call_LookupStringInt::Call_LookupStringInt() {
	searchString = "";
	searchOption = 0;
}

Call_LookupStringInt::~Call_LookupStringInt() {
}

void Call_LookupStringInt::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_LookupStringInt", pfx);
	_log(l_type, "%ssearchString='%s'", pfx, searchString.c_str());
	_log(l_type, "%ssearchOption=%lu", pfx, searchOption);
}

PyRepTuple *Call_LookupStringInt::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepString(searchString);
	tuple0->items[1] = new PyRepInteger(searchOption);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_LookupStringInt::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepString(searchString);
	tuple0->items[1] = new PyRepInteger(searchOption);
	res = tuple0;
	

	return(res);
}

bool Call_LookupStringInt::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_LookupStringInt::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_LookupStringInt failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Call_LookupStringInt failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Call_LookupStringInt failed: searchString is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	searchString = string_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_LookupStringInt failed: searchOption is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_LookupStringInt: truncating 64 bit into into 32 bit int for field searchOption");
	}
	searchOption = int_2->value;

	delete packet;
	return(true);
}

Call_LookupStringInt *Call_LookupStringInt::Clone() const {
	Call_LookupStringInt *res = new Call_LookupStringInt;
	res->CloneFrom(this);
	return(res);
}

void Call_LookupStringInt::CloneFrom(const Call_LookupStringInt *from) {
	searchString = from->searchString;
	searchOption = from->searchOption;
	
}


Call_LookupIntString::Call_LookupIntString() {
	searchOption = 0;
	searchString = "";
}

Call_LookupIntString::~Call_LookupIntString() {
}

void Call_LookupIntString::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_LookupIntString", pfx);
	_log(l_type, "%ssearchOption=%lu", pfx, searchOption);
	_log(l_type, "%ssearchString='%s'", pfx, searchString.c_str());
}

PyRepTuple *Call_LookupIntString::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(searchOption);
	tuple0->items[1] = new PyRepString(searchString);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_LookupIntString::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(searchOption);
	tuple0->items[1] = new PyRepString(searchString);
	res = tuple0;
	

	return(res);
}

bool Call_LookupIntString::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_LookupIntString::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_LookupIntString failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Call_LookupIntString failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_LookupIntString failed: searchOption is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_LookupIntString: truncating 64 bit into into 32 bit int for field searchOption");
	}
	searchOption = int_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Call_LookupIntString failed: searchString is not a string: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple0->items[1];
	searchString = string_2->value;

	delete packet;
	return(true);
}

Call_LookupIntString *Call_LookupIntString::Clone() const {
	Call_LookupIntString *res = new Call_LookupIntString;
	res->CloneFrom(this);
	return(res);
}

void Call_LookupIntString::CloneFrom(const Call_LookupIntString *from) {
	searchOption = from->searchOption;
	searchString = from->searchString;
	
}



