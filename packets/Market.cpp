/*  EVEmu: EVE Online Server Emulator
  
  **************************************************************
  This file is automatically generated, DO NOT EDIT IT DIRECTLY.
  **************************************************************
  
  (If you need to customize an object, you must copy that object
  into another source file, and give up the ability to generate it)
  
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; version 2 of the License.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY except by those people which sell it, which
  are required to give you total support for your newly bought product;
  without even the implied warranty of MERCHANTABILITY or FITNESS FOR
  A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/


#include <string>
#include "..\packets\Market.h"
#include "../common/PyRep.h"



	/*  this really dosent belong here  */

MarketGroup_Entry::MarketGroup_Entry() {
	marketGroupID = 0;
	parentGroupID = NULL;
	/*  may be None  */
	marketGroupName = "";
	description = "";
	graphicID = NULL;
	/*  may be None  */
	hasTypes = 0;
}

MarketGroup_Entry::~MarketGroup_Entry() {
	delete parentGroupID;
	/*  may be None  */
	delete graphicID;
	/*  may be None  */
}

void MarketGroup_Entry::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sMarketGroup_Entry", pfx);
	_log(l_type, "%smarketGroupID=%lu", pfx, marketGroupID);
	_log(l_type, "%sparentGroupID:", pfx);
	std::string parentGroupID_n(pfx);
	parentGroupID_n += "    ";
	if(parentGroupID == NULL) {
		_log(l_type, "%sERROR: NULL REP!", parentGroupID_n.c_str());
	} else {
		parentGroupID->Dump(l_type, parentGroupID_n.c_str());
	}
	/*  may be None  */
	_log(l_type, "%smarketGroupName='%s'", pfx, marketGroupName.c_str());
	_log(l_type, "%sdescription='%s'", pfx, description.c_str());
	_log(l_type, "%sgraphicID:", pfx);
	std::string graphicID_n(pfx);
	graphicID_n += "    ";
	if(graphicID == NULL) {
		_log(l_type, "%sERROR: NULL REP!", graphicID_n.c_str());
	} else {
		graphicID->Dump(l_type, graphicID_n.c_str());
	}
	/*  may be None  */
	_log(l_type, "%shasTypes=%lu", pfx, hasTypes);
	_log(l_type, "%stypes: Integer list with %d enetires", pfx, types.size());
	std::vector<uint32>::const_iterator types_cur, types_end;
	types_cur = types.begin();
	types_end = types.end();
	int types_index;
	for(types_index = 0; types_cur != types_end; types_cur++, types_index++) {
		_log(l_type, "%s   [%02d] %d", pfx, types_index, *types_cur);
	}
	
}

PyRepList *MarketGroup_Entry::Encode() {
	PyRepList *res = NULL;
	PyRepList *list0 = new PyRepList();
	list0->items.resize(7, NULL);
	list0->items[0] = new PyRepInteger(marketGroupID);
	if(parentGroupID == NULL) {
		_log(NET__PACKET_ERROR, "Encode MarketGroup_Entry: parentGroupID is NULL! hacking in a PyRepNone");
		parentGroupID = new PyRepNone();
	}
	list0->items[1] = parentGroupID->Clone();
	/*  may be None  */
	list0->items[2] = new PyRepString(marketGroupName);
	list0->items[3] = new PyRepString(description);
	if(graphicID == NULL) {
		_log(NET__PACKET_ERROR, "Encode MarketGroup_Entry: graphicID is NULL! hacking in a PyRepNone");
		graphicID = new PyRepNone();
	}
	list0->items[4] = graphicID->Clone();
	/*  may be None  */
	list0->items[5] = new PyRepInteger(hasTypes);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator types_cur, types_end;
	types_cur = types.begin();
	types_end = types.end();
	for(; types_cur != types_end; types_cur++) {
		list1->items.push_back(
			new PyRepInteger(*types_cur)
		);
	}
	list0->items[6] = list1;
	
	res = list0;
	

	return(res);
}

PyRepList *MarketGroup_Entry::FastEncode() {
	PyRepList *res = NULL;
	PyRepList *list0 = new PyRepList();
	list0->items.resize(7, NULL);
	list0->items[0] = new PyRepInteger(marketGroupID);
	if(parentGroupID == NULL) {
		_log(NET__PACKET_ERROR, "Encode MarketGroup_Entry: parentGroupID is NULL! hacking in a PyRepNone");
		parentGroupID = new PyRepNone();
	}
	list0->items[1] = parentGroupID;
	parentGroupID = NULL;
	/*  may be None  */
	list0->items[2] = new PyRepString(marketGroupName);
	list0->items[3] = new PyRepString(description);
	if(graphicID == NULL) {
		_log(NET__PACKET_ERROR, "Encode MarketGroup_Entry: graphicID is NULL! hacking in a PyRepNone");
		graphicID = new PyRepNone();
	}
	list0->items[4] = graphicID;
	graphicID = NULL;
	/*  may be None  */
	list0->items[5] = new PyRepInteger(hasTypes);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator types_cur, types_end;
	types_cur = types.begin();
	types_end = types.end();
	for(; types_cur != types_end; types_cur++) {
		list1->items.push_back(
			new PyRepInteger(*types_cur)
		);
	}
	list0->items[6] = list1;
	
	res = list0;
	

	return(res);
}

bool MarketGroup_Entry::Decode(PyRepList **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool MarketGroup_Entry::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode MarketGroup_Entry failed: list0 is not a list: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list0 = (PyRepList *) packet;
	if(list0->items.size() != 7) {
		_log(NET__PACKET_ERROR, "Decode MarketGroup_Entry failed: list0 is the wrong size: expected 7, but got %d", list0->items.size());
		delete packet;
		return(false);
	}

	if(!list0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode MarketGroup_Entry failed: marketGroupID is not an int: %s", list0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) list0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode MarketGroup_Entry: truncating 64 bit into into 32 bit int for field marketGroupID");
	}
	marketGroupID = int_1->value;
	delete parentGroupID;
	parentGroupID = list0->items[1];
	list0->items[1] = NULL;
	
	/*  may be None  */
	if(!list0->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode MarketGroup_Entry failed: marketGroupName is not a string: %s", list0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) list0->items[2];
	marketGroupName = string_2->value;
	if(!list0->items[3]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode MarketGroup_Entry failed: description is not a string: %s", list0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) list0->items[3];
	description = string_3->value;
	delete graphicID;
	graphicID = list0->items[4];
	list0->items[4] = NULL;
	
	/*  may be None  */
	if(!list0->items[5]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode MarketGroup_Entry failed: hasTypes is not an int: %s", list0->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) list0->items[5];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode MarketGroup_Entry: truncating 64 bit into into 32 bit int for field hasTypes");
	}
	hasTypes = int_4->value;
	if(!list0->items[6]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode MarketGroup_Entry failed: types is not a list: %s", list0->items[6]->TypeString());
		delete packet;
		return(false);
	}
	types.clear();
	PyRepList *list_5 = (PyRepList *) list0->items[6];
	PyRepList::iterator types_cur, types_end;
	types_cur = list_5->items.begin();
	types_end = list_5->items.end();
	int types_index;
	for(types_index = 0; types_cur != types_end; types_cur++, types_index++) {
		if(!(*types_cur)->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode MarketGroup_Entry failed: Element %d in list types is not an integer: %s", types_index, (*types_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *t = (PyRepInteger *) (*types_cur);
		if(t->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode MarketGroup_Entry: truncating 64 bit into into 32 bit int for item %d in field types", types_index);
		}
		types.push_back(t->value);
	}


	delete packet;
	return(true);
}

MarketGroup_Entry *MarketGroup_Entry::Clone() const {
	MarketGroup_Entry *res = new MarketGroup_Entry;
	res->CloneFrom(this);
	return(res);
}

void MarketGroup_Entry::CloneFrom(const MarketGroup_Entry *from) {
	marketGroupID = from->marketGroupID;
	delete parentGroupID;
	if(from->parentGroupID == NULL) {
		parentGroupID = NULL;
	} else {
		parentGroupID = from->parentGroupID->Clone();
	}
	/*  may be None  */
	marketGroupName = from->marketGroupName;
	description = from->description;
	delete graphicID;
	if(from->graphicID == NULL) {
		graphicID = NULL;
	} else {
		graphicID = from->graphicID->Clone();
	}
	/*  may be None  */
	hasTypes = from->hasTypes;
	types = from->types;
	
}


GetPriceHistory_Header::GetPriceHistory_Header() {
	/* object of type blue.DBRowDescriptor */
	_historyDate = "historyDate";
	_historyDateV = 64;
	_lowPrice = "lowPrice";
	_lowPriceV = 6;
	_highPrice = "highPrice";
	_highPriceV = 6;
	_avgPrice = "avgPrice";
	_avgPriceV = 6;
	_volume = "volume";
	_volumeV = 20;
	_orders = "orders";
	_ordersV = 3;
}

GetPriceHistory_Header::~GetPriceHistory_Header() {
}

void GetPriceHistory_Header::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sGetPriceHistory_Header", pfx);
	_log(l_type, "%sObject of type blue.DBRowDescriptor:", pfx);
	_log(l_type, "%s_historyDate='%s'", pfx, _historyDate.c_str());
	_log(l_type, "%s_historyDateV=%lu", pfx, _historyDateV);
	_log(l_type, "%s_lowPrice='%s'", pfx, _lowPrice.c_str());
	_log(l_type, "%s_lowPriceV=%lu", pfx, _lowPriceV);
	_log(l_type, "%s_highPrice='%s'", pfx, _highPrice.c_str());
	_log(l_type, "%s_highPriceV=%lu", pfx, _highPriceV);
	_log(l_type, "%s_avgPrice='%s'", pfx, _avgPrice.c_str());
	_log(l_type, "%s_avgPriceV=%lu", pfx, _avgPriceV);
	_log(l_type, "%s_volume='%s'", pfx, _volume.c_str());
	_log(l_type, "%s_volumeV=%lu", pfx, _volumeV);
	_log(l_type, "%s_orders='%s'", pfx, _orders.c_str());
	_log(l_type, "%s_ordersV=%lu", pfx, _ordersV);
}

PyRepObject *GetPriceHistory_Header::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepTuple *tuple1 = new PyRepTuple(6);
	PyRepTuple *tuple2 = new PyRepTuple(2);
	tuple2->items[0] = new PyRepString(_historyDate);
	tuple2->items[1] = new PyRepInteger(_historyDateV);
	tuple1->items[0] = tuple2;
	
	PyRepTuple *tuple3 = new PyRepTuple(2);
	tuple3->items[0] = new PyRepString(_lowPrice);
	tuple3->items[1] = new PyRepInteger(_lowPriceV);
	tuple1->items[1] = tuple3;
	
	PyRepTuple *tuple4 = new PyRepTuple(2);
	tuple4->items[0] = new PyRepString(_highPrice);
	tuple4->items[1] = new PyRepInteger(_highPriceV);
	tuple1->items[2] = tuple4;
	
	PyRepTuple *tuple5 = new PyRepTuple(2);
	tuple5->items[0] = new PyRepString(_avgPrice);
	tuple5->items[1] = new PyRepInteger(_avgPriceV);
	tuple1->items[3] = tuple5;
	
	PyRepTuple *tuple6 = new PyRepTuple(2);
	tuple6->items[0] = new PyRepString(_volume);
	tuple6->items[1] = new PyRepInteger(_volumeV);
	tuple1->items[4] = tuple6;
	
	PyRepTuple *tuple7 = new PyRepTuple(2);
	tuple7->items[0] = new PyRepString(_orders);
	tuple7->items[1] = new PyRepInteger(_ordersV);
	tuple1->items[5] = tuple7;
	
	args0 = tuple1;
	
	res = new PyRepObject(
			"blue.DBRowDescriptor",
			args0
		);
	

	return(res);
}

PyRepObject *GetPriceHistory_Header::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepTuple *tuple1 = new PyRepTuple(6);
	PyRepTuple *tuple2 = new PyRepTuple(2);
	tuple2->items[0] = new PyRepString(_historyDate);
	tuple2->items[1] = new PyRepInteger(_historyDateV);
	tuple1->items[0] = tuple2;
	
	PyRepTuple *tuple3 = new PyRepTuple(2);
	tuple3->items[0] = new PyRepString(_lowPrice);
	tuple3->items[1] = new PyRepInteger(_lowPriceV);
	tuple1->items[1] = tuple3;
	
	PyRepTuple *tuple4 = new PyRepTuple(2);
	tuple4->items[0] = new PyRepString(_highPrice);
	tuple4->items[1] = new PyRepInteger(_highPriceV);
	tuple1->items[2] = tuple4;
	
	PyRepTuple *tuple5 = new PyRepTuple(2);
	tuple5->items[0] = new PyRepString(_avgPrice);
	tuple5->items[1] = new PyRepInteger(_avgPriceV);
	tuple1->items[3] = tuple5;
	
	PyRepTuple *tuple6 = new PyRepTuple(2);
	tuple6->items[0] = new PyRepString(_volume);
	tuple6->items[1] = new PyRepInteger(_volumeV);
	tuple1->items[4] = tuple6;
	
	PyRepTuple *tuple7 = new PyRepTuple(2);
	tuple7->items[0] = new PyRepString(_orders);
	tuple7->items[1] = new PyRepInteger(_ordersV);
	tuple1->items[5] = tuple7;
	
	args0 = tuple1;
	
	res = new PyRepObject(
			"blue.DBRowDescriptor",
			args0
		);
	

	return(res);
}

bool GetPriceHistory_Header::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool GetPriceHistory_Header::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Header failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "blue.DBRowDescriptor") {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Header failed: obj_0 is the wrong object type. Expected 'blue.DBRowDescriptor', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Header failed: tuple1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple1 = (PyRepTuple *) obj_0->arguments;
	if(tuple1->items.size() != 6) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Header failed: tuple1 is the wrong size: expected 6, but got %d", tuple1->items.size());
		delete packet;
		return(false);
	}

	if(!tuple1->items[0]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Header failed: tuple2 is the wrong type: %s", tuple1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple1->items[0];
	if(tuple2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Header failed: tuple2 is the wrong size: expected 2, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	if(!tuple2->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Header failed: _historyDate is not a string: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) tuple2->items[0];
	_historyDate = string_3->value;
	if(!tuple2->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Header failed: _historyDateV is not an int: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple2->items[1];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode GetPriceHistory_Header: truncating 64 bit into into 32 bit int for field _historyDateV");
	}
	_historyDateV = int_4->value;
	if(!tuple1->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Header failed: tuple5 is the wrong type: %s", tuple1->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple5 = (PyRepTuple *) tuple1->items[1];
	if(tuple5->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Header failed: tuple5 is the wrong size: expected 2, but got %d", tuple5->items.size());
		delete packet;
		return(false);
	}

	if(!tuple5->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Header failed: _lowPrice is not a string: %s", tuple5->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_6 = (PyRepString *) tuple5->items[0];
	_lowPrice = string_6->value;
	if(!tuple5->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Header failed: _lowPriceV is not an int: %s", tuple5->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_7 = (PyRepInteger *) tuple5->items[1];
	if(int_7->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode GetPriceHistory_Header: truncating 64 bit into into 32 bit int for field _lowPriceV");
	}
	_lowPriceV = int_7->value;
	if(!tuple1->items[2]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Header failed: tuple8 is the wrong type: %s", tuple1->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple8 = (PyRepTuple *) tuple1->items[2];
	if(tuple8->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Header failed: tuple8 is the wrong size: expected 2, but got %d", tuple8->items.size());
		delete packet;
		return(false);
	}

	if(!tuple8->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Header failed: _highPrice is not a string: %s", tuple8->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_9 = (PyRepString *) tuple8->items[0];
	_highPrice = string_9->value;
	if(!tuple8->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Header failed: _highPriceV is not an int: %s", tuple8->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_10 = (PyRepInteger *) tuple8->items[1];
	if(int_10->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode GetPriceHistory_Header: truncating 64 bit into into 32 bit int for field _highPriceV");
	}
	_highPriceV = int_10->value;
	if(!tuple1->items[3]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Header failed: tuple11 is the wrong type: %s", tuple1->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple11 = (PyRepTuple *) tuple1->items[3];
	if(tuple11->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Header failed: tuple11 is the wrong size: expected 2, but got %d", tuple11->items.size());
		delete packet;
		return(false);
	}

	if(!tuple11->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Header failed: _avgPrice is not a string: %s", tuple11->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_12 = (PyRepString *) tuple11->items[0];
	_avgPrice = string_12->value;
	if(!tuple11->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Header failed: _avgPriceV is not an int: %s", tuple11->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_13 = (PyRepInteger *) tuple11->items[1];
	if(int_13->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode GetPriceHistory_Header: truncating 64 bit into into 32 bit int for field _avgPriceV");
	}
	_avgPriceV = int_13->value;
	if(!tuple1->items[4]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Header failed: tuple14 is the wrong type: %s", tuple1->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple14 = (PyRepTuple *) tuple1->items[4];
	if(tuple14->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Header failed: tuple14 is the wrong size: expected 2, but got %d", tuple14->items.size());
		delete packet;
		return(false);
	}

	if(!tuple14->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Header failed: _volume is not a string: %s", tuple14->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_15 = (PyRepString *) tuple14->items[0];
	_volume = string_15->value;
	if(!tuple14->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Header failed: _volumeV is not an int: %s", tuple14->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_16 = (PyRepInteger *) tuple14->items[1];
	if(int_16->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode GetPriceHistory_Header: truncating 64 bit into into 32 bit int for field _volumeV");
	}
	_volumeV = int_16->value;
	if(!tuple1->items[5]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Header failed: tuple17 is the wrong type: %s", tuple1->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple17 = (PyRepTuple *) tuple1->items[5];
	if(tuple17->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Header failed: tuple17 is the wrong size: expected 2, but got %d", tuple17->items.size());
		delete packet;
		return(false);
	}

	if(!tuple17->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Header failed: _orders is not a string: %s", tuple17->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_18 = (PyRepString *) tuple17->items[0];
	_orders = string_18->value;
	if(!tuple17->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Header failed: _ordersV is not an int: %s", tuple17->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_19 = (PyRepInteger *) tuple17->items[1];
	if(int_19->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode GetPriceHistory_Header: truncating 64 bit into into 32 bit int for field _ordersV");
	}
	_ordersV = int_19->value;

	delete packet;
	return(true);
}

GetPriceHistory_Header *GetPriceHistory_Header::Clone() const {
	GetPriceHistory_Header *res = new GetPriceHistory_Header;
	res->CloneFrom(this);
	return(res);
}

void GetPriceHistory_Header::CloneFrom(const GetPriceHistory_Header *from) {
	/* object of type blue.DBRowDescriptor */
	_historyDate = from->_historyDate;
	_historyDateV = from->_historyDateV;
	_lowPrice = from->_lowPrice;
	_lowPriceV = from->_lowPriceV;
	_highPrice = from->_highPrice;
	_highPriceV = from->_highPriceV;
	_avgPrice = from->_avgPrice;
	_avgPriceV = from->_avgPriceV;
	_volume = from->_volume;
	_volumeV = from->_volumeV;
	_orders = from->_orders;
	_ordersV = from->_ordersV;
	
}


GetPriceHistory_Entry::GetPriceHistory_Entry() {
	/* object of type blue.DBRow */
	historyDate = 0;
	lowPrice = 0.0;
	highPrice = 0.0;
	avgPrice = 0.0;
	volume = 0;
	orders = 0;
}

GetPriceHistory_Entry::~GetPriceHistory_Entry() {
}

void GetPriceHistory_Entry::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sGetPriceHistory_Entry", pfx);
	_log(l_type, "%sObject of type blue.DBRow:", pfx);
	_log(l_type, "%sheader:", pfx);
	std::string header_n(pfx);
	header_n += "    ";
	header.Dump(l_type, header_n.c_str());
	_log(l_type, "%shistoryDate=" I64u, pfx, historyDate);
	_log(l_type, "%slowPrice=%.13f", pfx, lowPrice);
	_log(l_type, "%shighPrice=%.13f", pfx, highPrice);
	_log(l_type, "%savgPrice=%.13f", pfx, avgPrice);
	_log(l_type, "%svolume=" I64u, pfx, volume);
	_log(l_type, "%sorders=%lu", pfx, orders);
}

PyRepObject *GetPriceHistory_Entry::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepTuple *tuple1 = new PyRepTuple(2);
		tuple1->items[0] = header.Encode();
	PyRepTuple *tuple2 = new PyRepTuple(6);
	tuple2->items[0] = new PyRepInteger(historyDate);
	tuple2->items[1] = new PyRepReal(lowPrice);
	tuple2->items[2] = new PyRepReal(highPrice);
	tuple2->items[3] = new PyRepReal(avgPrice);
	tuple2->items[4] = new PyRepInteger(volume);
	tuple2->items[5] = new PyRepInteger(orders);
	tuple1->items[1] = tuple2;
	
	args0 = tuple1;
	
	res = new PyRepObject(
			"blue.DBRow",
			args0
		);
	

	return(res);
}

PyRepObject *GetPriceHistory_Entry::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepTuple *tuple1 = new PyRepTuple(2);
		tuple1->items[0] = header.FastEncode();
	PyRepTuple *tuple2 = new PyRepTuple(6);
	tuple2->items[0] = new PyRepInteger(historyDate);
	tuple2->items[1] = new PyRepReal(lowPrice);
	tuple2->items[2] = new PyRepReal(highPrice);
	tuple2->items[3] = new PyRepReal(avgPrice);
	tuple2->items[4] = new PyRepInteger(volume);
	tuple2->items[5] = new PyRepInteger(orders);
	tuple1->items[1] = tuple2;
	
	args0 = tuple1;
	
	res = new PyRepObject(
			"blue.DBRow",
			args0
		);
	

	return(res);
}

bool GetPriceHistory_Entry::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool GetPriceHistory_Entry::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Entry failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "blue.DBRow") {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Entry failed: obj_0 is the wrong object type. Expected 'blue.DBRow', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Entry failed: tuple1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple1 = (PyRepTuple *) obj_0->arguments;
	if(tuple1->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Entry failed: tuple1 is the wrong size: expected 2, but got %d", tuple1->items.size());
		delete packet;
		return(false);
	}

	PyRep *rep_2 = tuple1->items[0];
	tuple1->items[0] = NULL;
	if(!header.Decode(&rep_2)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Entry failed: unable to decode element header");
		delete packet;
		return(false);
	}
	
	if(!tuple1->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Entry failed: tuple3 is the wrong type: %s", tuple1->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple3 = (PyRepTuple *) tuple1->items[1];
	if(tuple3->items.size() != 6) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Entry failed: tuple3 is the wrong size: expected 6, but got %d", tuple3->items.size());
		delete packet;
		return(false);
	}

	if(!tuple3->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Entry failed: historyDate is not an int: %s", tuple3->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_4 = (PyRepInteger *) tuple3->items[0];
	historyDate = int64_4->value;
	if(!tuple3->items[1]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Entry failed: lowPrice is not a real: %s", tuple3->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_5 = (PyRepReal *) tuple3->items[1];
	lowPrice = real_5->value;
	if(!tuple3->items[2]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Entry failed: highPrice is not a real: %s", tuple3->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_6 = (PyRepReal *) tuple3->items[2];
	highPrice = real_6->value;
	if(!tuple3->items[3]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Entry failed: avgPrice is not a real: %s", tuple3->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_7 = (PyRepReal *) tuple3->items[3];
	avgPrice = real_7->value;
	if(!tuple3->items[4]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Entry failed: volume is not an int: %s", tuple3->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_8 = (PyRepInteger *) tuple3->items[4];
	volume = int64_8->value;
	if(!tuple3->items[5]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode GetPriceHistory_Entry failed: orders is not an int: %s", tuple3->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_9 = (PyRepInteger *) tuple3->items[5];
	if(int_9->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode GetPriceHistory_Entry: truncating 64 bit into into 32 bit int for field orders");
	}
	orders = int_9->value;

	delete packet;
	return(true);
}

GetPriceHistory_Entry *GetPriceHistory_Entry::Clone() const {
	GetPriceHistory_Entry *res = new GetPriceHistory_Entry;
	res->CloneFrom(this);
	return(res);
}

void GetPriceHistory_Entry::CloneFrom(const GetPriceHistory_Entry *from) {
	/* object of type blue.DBRow */
	header.CloneFrom(&from->header);
	historyDate = from->historyDate;
	lowPrice = from->lowPrice;
	highPrice = from->highPrice;
	avgPrice = from->avgPrice;
	volume = from->volume;
	orders = from->orders;
	
}


Rsp_GetPriceHistory::Rsp_GetPriceHistory() {
}

Rsp_GetPriceHistory::~Rsp_GetPriceHistory() {
}

void Rsp_GetPriceHistory::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRsp_GetPriceHistory", pfx);
	_log(l_type, "%sheader:", pfx);
	std::string header_n(pfx);
	header_n += "    ";
	header.Dump(l_type, header_n.c_str());
	_log(l_type, "%srows: ", pfx);
	std::string rows_n(pfx);
	rows_n += "    ";
	rows.Dump(l_type, rows_n.c_str());
}

PyRepTuple *Rsp_GetPriceHistory::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
		tuple0->items[0] = header.Encode();
	tuple0->items[1] = rows.Clone();
	res = tuple0;
	

	return(res);
}

PyRepTuple *Rsp_GetPriceHistory::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
		tuple0->items[0] = header.FastEncode();
	
	PyRepList *list1 = new PyRepList();
	list1->items = rows.items;
	rows.items.clear();
	tuple0->items[1] = list1;
	res = tuple0;
	

	return(res);
}

bool Rsp_GetPriceHistory::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Rsp_GetPriceHistory::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetPriceHistory failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetPriceHistory failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	PyRep *rep_1 = tuple0->items[0];
	tuple0->items[0] = NULL;
	if(!header.Decode(&rep_1)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetPriceHistory failed: unable to decode element header");
		delete packet;
		return(false);
	}
	
	if(!tuple0->items[1]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetPriceHistory failed: rows is not a list: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_rows = (PyRepList *) tuple0->items[1];	rows.items = list_rows->items;
	list_rows->items.clear();
	

	delete packet;
	return(true);
}

Rsp_GetPriceHistory *Rsp_GetPriceHistory::Clone() const {
	Rsp_GetPriceHistory *res = new Rsp_GetPriceHistory;
	res->CloneFrom(this);
	return(res);
}

void Rsp_GetPriceHistory::CloneFrom(const Rsp_GetPriceHistory *from) {
	header.CloneFrom(&from->header);
	rows.CloneFrom(&from->rows);
	
}


Call_PlaceCharOrder::Call_PlaceCharOrder() {
	stationID = 0;
	typeID = 0;
	price = 0.0;
	quantity = 0;
	bid = false;
	orderRange = 0;
	itemID = 0;
	minVolume = 0;
	duration = 0;
	/*  in days  */
	useCorp = false;
	located = false;
}

Call_PlaceCharOrder::~Call_PlaceCharOrder() {
	/*  in days  */
}

void Call_PlaceCharOrder::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_PlaceCharOrder", pfx);
	_log(l_type, "%sstationID=%lu", pfx, stationID);
	_log(l_type, "%stypeID=%lu", pfx, typeID);
	_log(l_type, "%sprice=%.13f", pfx, price);
	_log(l_type, "%squantity=%lu", pfx, quantity);
	_log(l_type, "%sbid=%s", pfx, bid?"true":"false");
	_log(l_type, "%sorderRange=%lu", pfx, orderRange);
	_log(l_type, "%sitemID=%lu", pfx, itemID);
	_log(l_type, "%sminVolume=%lu", pfx, minVolume);
	_log(l_type, "%sduration=%lu", pfx, duration);
	/*  in days  */
	_log(l_type, "%suseCorp=%s", pfx, useCorp?"true":"false");
	_log(l_type, "%slocated=%s", pfx, located?"true":"false");
}

PyRepTuple *Call_PlaceCharOrder::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(11);
	tuple0->items[0] = new PyRepInteger(stationID);
	tuple0->items[1] = new PyRepInteger(typeID);
	tuple0->items[2] = new PyRepReal(price);
	tuple0->items[3] = new PyRepInteger(quantity);
	tuple0->items[4] = new PyRepBoolean(bid);
	tuple0->items[5] = new PyRepInteger(orderRange);
	if(itemID == 0) {
		tuple0->items[6] = new PyRepNone();
	} else {
		tuple0->items[6] = new PyRepInteger(itemID);
	}
	tuple0->items[7] = new PyRepInteger(minVolume);
	tuple0->items[8] = new PyRepInteger(duration);
	/*  in days  */
	tuple0->items[9] = new PyRepBoolean(useCorp);
	tuple0->items[10] = new PyRepBoolean(located);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_PlaceCharOrder::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(11);
	tuple0->items[0] = new PyRepInteger(stationID);
	tuple0->items[1] = new PyRepInteger(typeID);
	tuple0->items[2] = new PyRepReal(price);
	tuple0->items[3] = new PyRepInteger(quantity);
	tuple0->items[4] = new PyRepBoolean(bid);
	tuple0->items[5] = new PyRepInteger(orderRange);
	if(itemID == 0) {
		tuple0->items[6] = new PyRepNone();
	} else {
		tuple0->items[6] = new PyRepInteger(itemID);
	}
	tuple0->items[7] = new PyRepInteger(minVolume);
	tuple0->items[8] = new PyRepInteger(duration);
	/*  in days  */
	tuple0->items[9] = new PyRepBoolean(useCorp);
	tuple0->items[10] = new PyRepBoolean(located);
	res = tuple0;
	

	return(res);
}

bool Call_PlaceCharOrder::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_PlaceCharOrder::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_PlaceCharOrder failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 11) {
		_log(NET__PACKET_ERROR, "Decode Call_PlaceCharOrder failed: tuple0 is the wrong size: expected 11, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_PlaceCharOrder failed: stationID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_PlaceCharOrder: truncating 64 bit into into 32 bit int for field stationID");
	}
	stationID = int_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_PlaceCharOrder failed: typeID is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_PlaceCharOrder: truncating 64 bit into into 32 bit int for field typeID");
	}
	typeID = int_2->value;
	if(!tuple0->items[2]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode Call_PlaceCharOrder failed: price is not a real: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_3 = (PyRepReal *) tuple0->items[2];
	price = real_3->value;
	if(!tuple0->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_PlaceCharOrder failed: quantity is not an int: %s", tuple0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple0->items[3];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_PlaceCharOrder: truncating 64 bit into into 32 bit int for field quantity");
	}
	quantity = int_4->value;
	if(tuple0->items[4]->CheckType(PyRep::Boolean)) {
		PyRepBoolean *bool_5 = (PyRepBoolean *) tuple0->items[4];
		bid = bool_5->value;
	} else if(tuple0->items[4]->CheckType(PyRep::Integer)) {
		PyRepInteger *bool_5 = (PyRepInteger *) tuple0->items[4];
		bid = (bool_5->value != 0);
	} else {
		_log(NET__PACKET_ERROR, "Decode Call_PlaceCharOrder failed: bid is not a boolean (or int): %s", tuple0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	if(!tuple0->items[5]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_PlaceCharOrder failed: orderRange is not an int: %s", tuple0->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_6 = (PyRepInteger *) tuple0->items[5];
	if(int_6->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_PlaceCharOrder: truncating 64 bit into into 32 bit int for field orderRange");
	}
	orderRange = int_6->value;
	if(tuple0->items[6]->CheckType(PyRep::None)) {
		itemID = 0;
	} else {
	if(!tuple0->items[6]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_PlaceCharOrder failed: itemID is not an int: %s", tuple0->items[6]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_7 = (PyRepInteger *) tuple0->items[6];
	if(int_7->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_PlaceCharOrder: truncating 64 bit into into 32 bit int for field itemID");
	}
	itemID = int_7->value;
	}
	if(!tuple0->items[7]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_PlaceCharOrder failed: minVolume is not an int: %s", tuple0->items[7]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_8 = (PyRepInteger *) tuple0->items[7];
	if(int_8->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_PlaceCharOrder: truncating 64 bit into into 32 bit int for field minVolume");
	}
	minVolume = int_8->value;
	if(!tuple0->items[8]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_PlaceCharOrder failed: duration is not an int: %s", tuple0->items[8]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_9 = (PyRepInteger *) tuple0->items[8];
	if(int_9->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_PlaceCharOrder: truncating 64 bit into into 32 bit int for field duration");
	}
	duration = int_9->value;
	/*  in days  */
	if(tuple0->items[9]->CheckType(PyRep::Boolean)) {
		PyRepBoolean *bool_10 = (PyRepBoolean *) tuple0->items[9];
		useCorp = bool_10->value;
	} else if(tuple0->items[9]->CheckType(PyRep::Integer)) {
		PyRepInteger *bool_10 = (PyRepInteger *) tuple0->items[9];
		useCorp = (bool_10->value != 0);
	} else {
		_log(NET__PACKET_ERROR, "Decode Call_PlaceCharOrder failed: useCorp is not a boolean (or int): %s", tuple0->items[9]->TypeString());
		delete packet;
		return(false);
	}
	if(tuple0->items[10]->CheckType(PyRep::None)) {
		located = false;
	} else {
	if(!tuple0->items[10]->CheckType(PyRep::Boolean)) {
		_log(NET__PACKET_ERROR, "Decode Call_PlaceCharOrder failed: located is not a boolean: %s", tuple0->items[10]->TypeString());
		delete packet;
		return(false);
	}
	PyRepBoolean *bool_11 = (PyRepBoolean *) tuple0->items[10];
	located = bool_11->value;
	}

	delete packet;
	return(true);
}

Call_PlaceCharOrder *Call_PlaceCharOrder::Clone() const {
	Call_PlaceCharOrder *res = new Call_PlaceCharOrder;
	res->CloneFrom(this);
	return(res);
}

void Call_PlaceCharOrder::CloneFrom(const Call_PlaceCharOrder *from) {
	stationID = from->stationID;
	typeID = from->typeID;
	price = from->price;
	quantity = from->quantity;
	bid = from->bid;
	orderRange = from->orderRange;
	itemID = from->itemID;
	minVolume = from->minVolume;
	duration = from->duration;
	/*  in days  */
	useCorp = from->useCorp;
	located = from->located;
	
}


Notify_OnOwnOrderChanged::Notify_OnOwnOrderChanged() {
	PackedRow = NULL;
	/*  Reason: Add or Expiry (prolly a "Change" or something too)  */
	reason = "";
}

Notify_OnOwnOrderChanged::~Notify_OnOwnOrderChanged() {
	delete PackedRow;
	/*  Reason: Add or Expiry (prolly a "Change" or something too)  */
}

void Notify_OnOwnOrderChanged::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotify_OnOwnOrderChanged", pfx);
	_log(l_type, "%sPackedRow:", pfx);
	std::string PackedRow_n(pfx);
	PackedRow_n += "    ";
	if(PackedRow == NULL) {
		_log(l_type, "%sERROR: NULL REP!", PackedRow_n.c_str());
	} else {
		PackedRow->Dump(l_type, PackedRow_n.c_str());
	}
	/*  Reason: Add or Expiry (prolly a "Change" or something too)  */
	_log(l_type, "%sreason='%s'", pfx, reason.c_str());
}

PyRepTuple *Notify_OnOwnOrderChanged::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	if(PackedRow == NULL) {
		_log(NET__PACKET_ERROR, "Encode Notify_OnOwnOrderChanged: PackedRow is NULL! hacking in a PyRepNone");
		PackedRow = new PyRepNone();
	}
	tuple0->items[0] = PackedRow->Clone();
	/*  Reason: Add or Expiry (prolly a "Change" or something too)  */
	tuple0->items[1] = new PyRepString(reason);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Notify_OnOwnOrderChanged::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	if(PackedRow == NULL) {
		_log(NET__PACKET_ERROR, "Encode Notify_OnOwnOrderChanged: PackedRow is NULL! hacking in a PyRepNone");
		PackedRow = new PyRepNone();
	}
	tuple0->items[0] = PackedRow;
	PackedRow = NULL;
	/*  Reason: Add or Expiry (prolly a "Change" or something too)  */
	tuple0->items[1] = new PyRepString(reason);
	res = tuple0;
	

	return(res);
}

bool Notify_OnOwnOrderChanged::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Notify_OnOwnOrderChanged::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnOwnOrderChanged failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnOwnOrderChanged failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	delete PackedRow;
	PackedRow = tuple0->items[0];
	tuple0->items[0] = NULL;
	
	/*  Reason: Add or Expiry (prolly a "Change" or something too)  */
	if(!tuple0->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Notify_OnOwnOrderChanged failed: reason is not a string: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[1];
	reason = string_1->value;

	delete packet;
	return(true);
}

Notify_OnOwnOrderChanged *Notify_OnOwnOrderChanged::Clone() const {
	Notify_OnOwnOrderChanged *res = new Notify_OnOwnOrderChanged;
	res->CloneFrom(this);
	return(res);
}

void Notify_OnOwnOrderChanged::CloneFrom(const Notify_OnOwnOrderChanged *from) {
	delete PackedRow;
	if(from->PackedRow == NULL) {
		PackedRow = NULL;
	} else {
		PackedRow = from->PackedRow->Clone();
	}
	/*  Reason: Add or Expiry (prolly a "Change" or something too)  */
	reason = from->reason;
	
}



