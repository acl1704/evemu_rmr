/*  EVEmu: EVE Online Server Emulator
  
  **************************************************************
  This file is automatically generated, DO NOT EDIT IT DIRECTLY.
  **************************************************************
  
  (If you need to customize an object, you must copy that object
  into another source file, and give up the ability to generate it)
  
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; version 2 of the License.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY except by those people which sell it, which
  are required to give you total support for your newly bought product;
  without even the implied warranty of MERCHANTABILITY or FITNESS FOR
  A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#ifndef _____packets_Inventory_h__
#define _____packets_Inventory_h__

#include <string>
#include <vector>
#include <map>
#include "../common/common.h"
#include "../common/logsys.h"
#include "../common/PyRep.h"



class NotifyOnItemChange {
public:
	NotifyOnItemChange();
	~NotifyOnItemChange();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	NotifyOnItemChange *Clone() const;
	void CloneFrom(const NotifyOnItemChange *from);
	
	/*  0: this is a util.Row  */
	PyRep		*itemRow;
	/*  1: map from row index (ix* constants) to the old value for the item.   */
	std::map<uint32, PyRep *>	changes;


};


class NotifyOnSkillStartTraining {
public:
	NotifyOnSkillStartTraining();
	~NotifyOnSkillStartTraining();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	NotifyOnSkillStartTraining *Clone() const;
	void CloneFrom(const NotifyOnSkillStartTraining *from);
	
	uint32		itemID;
	uint64		endOfTraining;


};


class NotifyOnSkillTrainingStopped {
public:
	NotifyOnSkillTrainingStopped();
	~NotifyOnSkillTrainingStopped();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	NotifyOnSkillTrainingStopped *Clone() const;
	void CloneFrom(const NotifyOnSkillTrainingStopped *from);
	
	uint32		itemID;
	uint64		endOfTraining;


};


class CallSetLabel {
public:
	CallSetLabel();
	~CallSetLabel();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	CallSetLabel *Clone() const;
	void CloneFrom(const CallSetLabel *from);
	
	uint32		itemID;
	std::string	itemName;


};


class InvBroker_BindArgs {
public:
	InvBroker_BindArgs();
	~InvBroker_BindArgs();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	InvBroker_BindArgs *Clone() const;
	void CloneFrom(const InvBroker_BindArgs *from);
	
	uint32		entityID;
	PyRep		*unknown1;


};


class Inventory_GetInventory {
public:
	Inventory_GetInventory();
	~Inventory_GetInventory();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	Inventory_GetInventory *Clone() const;
	void CloneFrom(const Inventory_GetInventory *from);
	
	uint32		container;
	PyRep		*argument;


};


class Inventory_CallAdd {
public:
	Inventory_CallAdd();
	~Inventory_CallAdd();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	Inventory_CallAdd *Clone() const;
	void CloneFrom(const Inventory_CallAdd *from);
	
	uint32		itemID;
	uint32		quantity;
	uint32		flag;


};


class Inventory_CallAddCargoContainer {
public:
	Inventory_CallAddCargoContainer();
	~Inventory_CallAddCargoContainer();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	Inventory_CallAddCargoContainer *Clone() const;
	void CloneFrom(const Inventory_CallAddCargoContainer *from);
	
	uint32		itemID;
	uint32		quantity;


};


class Inventory_CallMultiAdd {
public:
	Inventory_CallMultiAdd();
	~Inventory_CallMultiAdd();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	Inventory_CallMultiAdd *Clone() const;
	void CloneFrom(const Inventory_CallMultiAdd *from);
	
	std::vector<uint32>	itemIDs;
	uint32		quantity;
	/*  almost always 1 on a multiadd  */
	uint32		flag;


};


class Inventory_CallReplaceCharges {
public:
	Inventory_CallReplaceCharges();
	~Inventory_CallReplaceCharges();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	Inventory_CallReplaceCharges *Clone() const;
	void CloneFrom(const Inventory_CallReplaceCharges *from);
	
	uint32		flag;
	uint32		itemID;
	uint32		quantity;


};


class Inventory_CallMultiMergeElement {
public:
	Inventory_CallMultiMergeElement();
	~Inventory_CallMultiMergeElement();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	Inventory_CallMultiMergeElement *Clone() const;
	void CloneFrom(const Inventory_CallMultiMergeElement *from);
	
	uint32		draggedItemID;
	uint32		stationaryItemID;
	uint32		draggedQty;


};


class Inventory_CallMultiMerge {
public:
	Inventory_CallMultiMerge();
	~Inventory_CallMultiMerge();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	Inventory_CallMultiMerge *Clone() const;
	void CloneFrom(const Inventory_CallMultiMerge *from);
	
	PyRepList	MMElements;


};


class Inventory_ItemCannotBeInDroneBayException {
public:
	Inventory_ItemCannotBeInDroneBayException();
	~Inventory_ItemCannotBeInDroneBayException();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepObject **packet);
	PyRepObject *Encode();
	PyRepObject *FastEncode();
	Inventory_ItemCannotBeInDroneBayException *Clone() const;
	void CloneFrom(const Inventory_ItemCannotBeInDroneBayException *from);
	
	/* object of type ccp_exceptions.UserError */
	std::string	exceptionType;
	std::string	exceptTypeDict;


};


class Inventory_NotEnoughCargoSpaceException {
public:
	Inventory_NotEnoughCargoSpaceException();
	~Inventory_NotEnoughCargoSpaceException();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepObject **packet);
	PyRepObject *Encode();
	PyRepObject *FastEncode();
	Inventory_NotEnoughCargoSpaceException *Clone() const;
	void CloneFrom(const Inventory_NotEnoughCargoSpaceException *from);
	
	/* object of type ccp_exceptions.UserError */
	std::string	exceptionType;
	double		spaceavail;
	double		volume;
	std::string	exceptTypeDict;
	double		spaceavaildict;
	double		volumedict;


};


class Inventory_CallStackAll {
public:
	Inventory_CallStackAll();
	~Inventory_CallStackAll();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	Inventory_CallStackAll *Clone() const;
	void CloneFrom(const Inventory_CallStackAll *from);
	
	uint32		locationFlag;


};


class OnModuleAttributeChange {
public:
	OnModuleAttributeChange();
	~OnModuleAttributeChange();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	OnModuleAttributeChange *Clone() const;
	void CloneFrom(const OnModuleAttributeChange *from);
	
	/*  0  */
	/*  0  */
	/*  0  */
	std::string	string0;
	/*  1  */
	uint32		ownerID;
	/*  2  */
	uint32		itemKey;
	/*  3  */
	uint32		attributeID;
	/*  4  */
	uint64		time;
	/*  5  */
	double		newValue;
	/*  6  */
	/*  0  */
	double		newValue2;
	/*  1  */
	uint64		time2;
	/*  2  */
	double		real8;
	/*  3  */
	double		oldValue;


};


class Call_GetJournal {
public:
	Call_GetJournal();
	~Call_GetJournal();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	Call_GetJournal *Clone() const;
	void CloneFrom(const Call_GetJournal *from);
	
	uint32		accountKey;
	uint64		fromDate;
	/*  may be None (but prolly wont be)  */
	uint32		refTypeID;
	/*  may be None  */
	PyRep		*corpAccount;
	/*  soft bool  */
	PyRep		*refID;
	/*  may be None  */
	uint32		rev;


};


class Call_AssembleShip {
public:
	Call_AssembleShip();
	~Call_AssembleShip();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	Call_AssembleShip *Clone() const;
	void CloneFrom(const Call_AssembleShip *from);
	
	std::vector<uint32>	items;


};


class EntityEffectState {
public:
	EntityEffectState();
	~EntityEffectState();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepList **packet);
	PyRepList *Encode();
	PyRepList *FastEncode();
	EntityEffectState *Clone() const;
	void CloneFrom(const EntityEffectState *from);
	
	/*  the first 7 fields are the standard effect `environment`
         fields indexed by ENV_IDX_*, see OnGodmaShipEffect  */
	/*  Begin Environment  */
	uint32		env_itemID;
	uint32		env_charID;
	uint32		env_shipID;
	uint32		env_target;
	/*  optional  */
	uint32		env_other;
	/*  optional (not positive that this is an int)  */
	PyRepList	env_area;
	/*  not sure what data goes in here.  */
	uint32		env_effectID;
	/*  End Environment  */
	uint64		startTime;
	uint32		duration;
	/*  saw 0x7 placeholder  */
	uint32		repeat;
	/*  saw 0  */
	/*  randomSeed  */


};


class Rsp_CommonGetInfo_Entry {
public:
	Rsp_CommonGetInfo_Entry();
	~Rsp_CommonGetInfo_Entry();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepList **packet);
	PyRepList *Encode();
	PyRepList *FastEncode();
	Rsp_CommonGetInfo_Entry *Clone() const;
	void CloneFrom(const Rsp_CommonGetInfo_Entry *from);
	
	uint32		itemID;
	/*  this is an EntityRowObject  */
	PyRep		*invItem;
	/*  this maps effectType to EntityEffectState  */
	std::map<uint32, PyRep *>	activeEffects;
	/*  maps attribute ID to it's value, which may be int or real  */
	std::map<uint32, PyRep *>	attributes;
	uint64		time;


};


class Rsp_ItemGetInfo {
public:
	Rsp_ItemGetInfo();
	~Rsp_ItemGetInfo();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepObject **packet);
	PyRepObject *Encode();
	PyRepObject *FastEncode();
	Rsp_ItemGetInfo *Clone() const;
	void CloneFrom(const Rsp_ItemGetInfo *from);
	
	/* object of type util.Row */
	std::string	head_itemID;
	std::string	head_invItem;
	std::string	head_activeEffects;
	std::string	head_attributes;
	std::string	head_time;
	Rsp_CommonGetInfo_Entry	entry;


};


class Rsp_CommonGetInfo {
public:
	Rsp_CommonGetInfo();
	~Rsp_CommonGetInfo();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepObject **packet);
	PyRepObject *Encode();
	PyRepObject *FastEncode();
	Rsp_CommonGetInfo *Clone() const;
	void CloneFrom(const Rsp_CommonGetInfo *from);
	
	/* object of type util.IndexRowset */
	std::string	head_itemID;
	std::string	head_invItem;
	std::string	head_activeEffects;
	std::string	head_attributes;
	std::string	head_time;
	std::string	rowclass;
	std::string	idName;
	/*  For ShipGetInfo: contains a single Rsp_CommonGetInfo_Entry for the ship  */
	/*  For CharGetInfo: contains an Rsp_CommonGetInfo_Entry for the char and each of their skills (and implants?)  */
	std::map<uint32, PyRep *>	items;


};


class EntityRowObject {
public:
	EntityRowObject();
	~EntityRowObject();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepObject **packet);
	PyRepObject *Encode();
	PyRepObject *FastEncode();
	EntityRowObject *Clone() const;
	void CloneFrom(const EntityRowObject *from);
	
	/* object of type util.Row */
	std::string	head_itemID;
	std::string	head_typeID;
	std::string	head_ownerID;
	std::string	head_locationID;
	std::string	head_flag;
	std::string	head_contraband;
	std::string	head_singleton;
	std::string	head_quantity;
	std::string	head_groupID;
	std::string	head_categoryID;
	std::string	head_customInfo;
	uint32		itemID;
	uint32		typeID;
	uint32		ownerID;
	uint32		locationID;
	uint32		flag;
	uint32		contraband;
	uint32		singleton;
	uint32		quantity;
	uint32		groupID;
	uint32		categoryID;
	std::string	customInfo;


};


class Call_GetOptionsForItemTypes {
public:
	Call_GetOptionsForItemTypes();
	~Call_GetOptionsForItemTypes();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	Call_GetOptionsForItemTypes *Clone() const;
	void CloneFrom(const Call_GetOptionsForItemTypes *from);
	
	PyRepDict	typeIDs;


};


class Call_GetOptionsForItemTypes_Arg {
public:
	Call_GetOptionsForItemTypes_Arg();
	~Call_GetOptionsForItemTypes_Arg();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepObject **packet);
	PyRepObject *Encode();
	PyRepObject *FastEncode();
	Call_GetOptionsForItemTypes_Arg *Clone() const;
	void CloneFrom(const Call_GetOptionsForItemTypes_Arg *from);
	
	/* object of type util.KeyVal */
	uint32		isRecyclable;
	uint32		isRefinable;


};

	/*  this is ugly, but we dont really have a better way to deal with it right now.  */

class Rsp_GetQuote {
public:
	Rsp_GetQuote();
	~Rsp_GetQuote();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepObject **packet);
	PyRepObject *Encode();
	PyRepObject *FastEncode();
	Rsp_GetQuote *Clone() const;
	void CloneFrom(const Rsp_GetQuote *from);
	
	/* object of type util.KeyVal */
	uint32		quantityToProcess;
	/* object of type util.Rowset */
	/*  Don't change headerX !  */
	std::string	header1;
	std::string	header2;
	std::string	header3;
	std::string	header4;
	std::string	rowclass;
	PyRepList	lines;


};


class Rsp_GetQuote_Line {
public:
	Rsp_GetQuote_Line();
	~Rsp_GetQuote_Line();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepList **packet);
	PyRepList *Encode();
	PyRepList *FastEncode();
	Rsp_GetQuote_Line *Clone() const;
	void CloneFrom(const Rsp_GetQuote_Line *from);
	
	uint32		typeID;
	uint32		unrecoverable;
	uint32		station;
	uint32		client;


};


class Call_Reprocess {
public:
	Call_Reprocess();
	~Call_Reprocess();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	Call_Reprocess *Clone() const;
	void CloneFrom(const Call_Reprocess *from);
	
	std::vector<uint32>	itemIDs;


};



#endif


